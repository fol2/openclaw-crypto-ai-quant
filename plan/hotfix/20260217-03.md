# Codebase Security, Code Quality & Hardening Audit Report (Round 4)

**Project:** OpenClaw AI Quant Trading Engine (Hyperliquid DEX)
**Date:** 2026-02-17
**Status:** OPEN
**Scope:** Full codebase — Python (`engine/`, `strategy/`, `live/`, `exchange/`, `tools/`, `monitor/`, `scripts/`) + Rust (`backtester/`, `ws_sidecar/`) + config/systemd/CI/tests
**Prior audits:** `plan/hotfix/20260216-01.md` (RESOLVED), `plan/hotfix/20260217-01.md` (RESOLVED), `plan/hotfix/20260217-02.md` (RESOLVED)

---

## Summary

| Severity | Engine Core | Strategy/Live | Rust Backtester | Config/Security/Ops | Tools/Monitor/Tests | **Total** |
|----------|:-----------:|:-------------:|:---------------:|:-------------------:|:-------------------:|:---------:|
| **CRITICAL** | 3 | 3 | 0 | 0 | 1 | **7** |
| **HIGH** | 9 | 6 | 6 | 2 | 6 | **29** |
| **MEDIUM** | 13 | 8 | 12 | 5 | 11 | **49** |
| **LOW** | 8 | 6 | 8 | 8 | 9 | **39** |
| **Total** | **33** | **23** | **26** | **15** | **27** | **124** |

Positive findings (no action needed): **9** (documented at end of report).

---

## ID Convention

- `E-` = Engine Core (`engine/`)
- `S-` = Strategy / Live / Exchange (`strategy/`, `live/`, `exchange/`)
- `R-` = Rust Backtester (`backtester/`)
- `X-` = Config / Security / Ops (config, systemd, CI, DB)
- `T-` = Tools / Monitor / Tests (`tools/`, `monitor/`, `tests/`)

---

# CRITICAL (7)

---

### E-C1. `alerting.py` — `_ALERT_DROPPED_COUNT` not thread-safe

- **File:** `engine/alerting.py:233`
- **Category:** Race Condition
- **Root cause:** `_ALERT_DROPPED_COUNT` is a global `int` incremented via `+= 1` from multiple threads (main loop, background REST backfill, alert worker) without any synchronisation primitive. Python's GIL protects simple int reads/writes in CPython, but the compound read-modify-write of `+= 1` is not atomic at the bytecode level.
- **Impact:** Incorrect drop count → missed log lines when the modulo check on line 235 evaluates incorrectly. In worst case, operators lose visibility into dropped alerts during high-frequency trading bursts.
- **Acceptance criteria:**
  1. `_ALERT_DROPPED_COUNT` incremented under `threading.Lock` or replaced with `itertools.count()`.
  2. Unit test demonstrating concurrent increment correctness.
- **Suggested fix:** Wrap increment and read in `_ALERT_LOCK` or switch to `itertools.count()`.

---

### E-C2. OMS `reconcile_unmatched_fills` — connection leak risk

- **File:** `engine/oms.py:1323`
- **Category:** Resource Leak
- **Root cause:** `reconcile_unmatched_fills` opens its own `sqlite3.connect(self.store._db_path)` bypassing `OmsStore._connect()` and its PRAGMA setup. The connection is used across a large try/except block. If any exception occurs between `conn = sqlite3.connect(...)` and the final `conn.close()`, the connection leaks.
- **Impact:** Leaked SQLite connections accumulate file descriptors, eventually hitting the system limit (typically 1024) and causing all DB operations to fail — crashing the live trading loop.
- **Acceptance criteria:**
  1. Connection opened via `with sqlite3.connect(...) as conn:` or wrapped in immediate `try/finally`.
  2. PRAGMAs applied consistently via `self.store._connect()`.
  3. No leaked FDs observable after injecting exceptions in a test.
- **Suggested fix:** Use `with` context manager or `self.store._connect()`.

---

### E-C3. `core.py` — `_normalise_kernel_target_size` contains dead code / duplicate logic

- **File:** `engine/core.py:348-379`
- **Category:** Logic Bug
- **Root cause:** The function computes `notional / price` twice — once at lines 350-356 and again at lines 366-378. The second block is unreachable for any positive `raw_notional` because the first block would have already returned. The only path to the second block is when `float(raw_notional)` raised in the first block (caught at line 356), but the third block would also raise the same exception.
- **Impact:** Dead code confuses maintainers, creates risk of introducing bugs when modifying the function (editor may modify the wrong block).
- **Acceptance criteria:**
  1. The unreachable duplicate block (lines 366-378) is removed.
  2. Existing tests still pass.
- **Suggested fix:** Remove the unreachable block.

---

### S-C1. `BrokerAdapter` — No maximum notional / quantity guard

- **File:** `strategy/broker_adapter.py:285-329`
- **Category:** Financial Safety
- **Root cause:** `BrokerAdapter._execute_open()` computes quantity from `notional_usd / price` when `quantity <= 0` but does not enforce any absolute maximum on the computed quantity or notional value. The `LiveTrader` layer has its own guardrails, but `BrokerAdapter` is designed to be exchange-agnostic and could be used directly.
- **Impact:** If the kernel emits an intent with an extremely large `notional_usd` (due to a bug, corrupted state, or config error), the broker adapter submits it to the exchange without any sanity check. **Potential for catastrophic financial loss.**
- **Acceptance criteria:**
  1. `BrokerAdapter` enforces configurable `max_notional_usd` and `max_quantity` bounds.
  2. Orders exceeding bounds are rejected with `BrokerAdapterError` and logged.
  3. Unit test covering oversized notional rejection.
- **Suggested fix:** Add configurable bounds in constructor, validate before submission.

---

### S-C2. WS disconnect clears all mid-prices → stale margin estimates

- **File:** `exchange/ws.py:775-782`
- **Category:** State Management / Financial Safety
- **Root cause:** When WebSocket disconnects (`_on_close`), all `_mids` and `_bbo` dicts are cleared. During the reconnection window (`HL_WS_RECONNECT_SECS = 5` seconds or more), `get_mid()` returns `None` for all symbols. In `LiveTrader._estimate_margin_used()` (line 701-717), when `get_mid()` returns `None`, the code falls back to entry price.
- **Impact:** Entry price can be significantly different from market price. This causes incorrect margin calculations, leading to oversized entries or missed exits during volatile markets. **Potential for financial loss during WS flaps.**
- **Acceptance criteria:**
  1. On WS disconnect, mid-prices are marked with a disconnect timestamp rather than cleared.
  2. Consumers can query `max_age_s` to decide if data is still usable.
  3. `_estimate_margin_used` uses the staleness-marked mid if within acceptable age, else logs a warning and uses entry price fallback.
- **Suggested fix:** Replace clear-on-disconnect with staleness timestamps.

---

### S-C3. `compute_ema_slow_slope` called twice per candle in orchestrator

- **File:** `strategy/kernel_orchestrator.py:392-395`
- **Category:** Correctness / Performance
- **Root cause:** `compute_ema_slow_slope` is called once at line 392 (passed to `build_gate_result`) and again at line 395 (stored as `ema_slow_slope_pct`). The function computes `ta.trend.ema_indicator()` each time, which involves a full DataFrame EMA calculation.
- **Impact:** (1) Performance waste — double EMA computation every candle tick. (2) Theoretical correctness risk — if DataFrame state mutated between calls (unlikely but not impossible in concurrent contexts), the two values could diverge silently, causing a mismatch between the gate decision and the logged slope value.
- **Acceptance criteria:**
  1. `compute_ema_slow_slope` called exactly once per candle.
  2. Result reused for both `build_gate_result` and the event log.
- **Suggested fix:** Compute once, assign to local variable, pass to both consumers.

---

### T-C1. `factory_run.py` — `_run_cmd` has no subprocess timeout

- **File:** `factory_run.py:657-665`
- **Category:** Robustness / Subprocess Management
- **Root cause:** The central `_run_cmd` helper calls `subprocess.run` with no `timeout` parameter. This helper is used for ALL subprocess invocations in the factory pipeline: GPU sweep, CPU replay, walk-forward, slippage stress, sensitivity, Monte Carlo, concentration checks, cross-universe validation, data checks, and config generation.
- **Impact:** If any subprocess hangs (backtester deadlock, GPU driver stall), the entire factory run blocks indefinitely with no recovery. Since factory runs are scheduled as systemd oneshot services, a hung factory blocks all subsequent nightly runs. **Pipeline availability risk.**
- **Acceptance criteria:**
  1. `_run_cmd` accepts an optional `timeout_s` parameter with a sensible default (e.g. 3600s).
  2. On `subprocess.TimeoutExpired`, child process is killed, timeout is recorded in step metadata, and a non-zero exit code is returned.
  3. Unit test demonstrating timeout behaviour.
- **Suggested fix:** Add timeout parameter, kill on expiry, record in metadata.

---

# HIGH (29)

---

### E-H1. `daemon.py` — `acquire_lock_or_exit` leaks FD on success (intentional but undocumented)

- **File:** `engine/daemon.py:262-296`
- **Category:** Resource Leak
- **Root cause:** The lock file is opened with `open(lock_path, "a+")` and the returned handle is kept alive to hold the flock. The return value in `main()` is assigned to `_lock` — a local variable that is never closed. No `atexit` handler is registered.
- **Impact:** If `main()` exits unexpectedly (not via SystemExit), the file descriptor leaks. Across process restarts without clean shutdown, stale lock files can accumulate.
- **Acceptance criteria:**
  1. `_lock` is documented as intentionally held for process lifetime.
  2. An `atexit` handler is registered to close the lock cleanly.
- **Suggested fix:** Add `atexit.register(lambda: _lock.close())` and a code comment.

---

### E-H2. `sqlite_logger.py` — `_LineBufferingWriter.write` silently drops terminal output

- **File:** `engine/sqlite_logger.py:215-227`
- **Category:** Robustness
- **Root cause:** `write()` wraps `self._stream.write(s)` in `with suppress(OSError, ValueError, RuntimeError)`. If the underlying stdout/stderr write fails, the data is silently lost from journalctl. The method still returns `len(s)`, making callers believe the write succeeded.
- **Impact:** For a live trading system, losing error output to journalctl is dangerous — it's the primary operator monitoring channel. Critical errors could be invisible.
- **Acceptance criteria:**
  1. When the underlying stream write fails, a warning is logged to the SQLite sink.
  2. The suppression is narrowed to only `BrokenPipeError` (the one legitimate failure mode).
- **Suggested fix:** Log to SQLite sink on stream failure, narrow suppress scope.

---

### E-H3. `OmsStore` — opens/closes DB connection for every single operation

- **File:** `engine/oms.py:241-248, 387-464`
- **Category:** Performance / Resource Churn
- **Root cause:** Every `OmsStore` method opens a new `sqlite3.connect()`, runs a query, and closes in `finally`. Each connection re-runs PRAGMA setup.
- **Impact:** Under high fill rates (50+ fills/second during volatile markets), excessive connection churn adds latency to the critical trading path. Each connect/disconnect cycle is ~0.5-1ms, cumulative delay can reach 50-100ms per iteration.
- **Acceptance criteria:**
  1. Persistent connection per thread (via `threading.local()`) or connection pool.
  2. PRAGMA setup runs once per connection, not per query.
  3. Performance improvement measurable under load test.
- **Suggested fix:** Use persistent connection with `threading.local()` cache.

---

### E-H4. `rest_client.py` — retry loop sleeps on main thread

- **File:** `engine/rest_client.py:65-73`
- **Category:** Robustness
- **Root cause:** `_post` method's retry loop calls `time.sleep(backoff.delay(attempt))` which blocks the calling thread. When called from the main engine loop (e.g. `_get_rest_mid` in `market_data.py`), this can block the entire trading loop for up to 15 seconds per retry (30+ seconds total with 3 retries).
- **Impact:** Trading loop stalled for 30+ seconds → missed exits, stale signals, potential financial loss during fast-moving markets.
- **Acceptance criteria:**
  1. Main-loop REST calls have `max_retries=1` or a circuit-breaker.
  2. Background backfill calls can retain higher retry counts.
  3. No single REST failure can block the trading loop for > 5 seconds.
- **Suggested fix:** Reduce retries for main-loop path, add circuit-breaker.

---

### E-H5. `core.py` — `_decision_execute_trade` shadows module-level `logger`

- **File:** `engine/core.py:1512-1514`
- **Category:** Logic Bug
- **Root cause:** Inside the CLOSE/REDUCE branch, a local `import logging` followed by `logger = logging.getLogger(__name__)` shadows the module-level `logger` defined at line 41.
- **Impact:** Functionally equivalent currently but confusing. If module-level logger had custom handlers, this shadow would bypass them. Could mask issues during debugging.
- **Acceptance criteria:**
  1. Local `import logging` and `logger = ...` on lines 1512-1514 removed.
  2. Module-level `logger` used throughout.
- **Suggested fix:** Remove the local logger assignment.

---

### E-H6. `risk.py` — `TokenBucket` is not thread-safe

- **File:** `engine/risk.py:60-87`
- **Category:** Race Condition
- **Root cause:** `TokenBucket._refill()` and `allow()` read and write `self._tokens` and `self._last_s` without any locking. Currently only accessed from the daemon main thread, but if `note_fill` or `allow_order` is ever called from the WS fill processing thread, this will produce incorrect rate limiting.
- **Impact:** Incorrect rate limiting could allow order bursts that exceed the configured rate, or block legitimate orders. Fragile to future threading changes.
- **Acceptance criteria:**
  1. `TokenBucket` is either thread-safe (with `threading.Lock`) or documented as single-threaded only.
  2. If documented as single-threaded, a runtime assertion detects cross-thread access.
- **Suggested fix:** Add `threading.Lock` or document constraint.

---

### E-H7. `daemon.py` — `_pending_ws_fills` dropped without recovery

- **File:** `engine/daemon.py:722-729`
- **Category:** State Management
- **Root cause:** When the pending WS fills buffer exceeds `_max_pending_ws_fills`, the oldest fills are dropped silently (only a count is logged, not the fill content).
- **Impact:** Dropped fills represent real exchange fills that may never be recorded in the trading database, leading to incorrect position tracking and risk calculations. **Divergence between exchange state and local state.**
- **Acceptance criteria:**
  1. Before dropping, persist fill hashes/tids to a separate overflow file for REST backfill recovery.
  2. At minimum, log symbols and timestamps of dropped fills.
  3. REST backfill is triggered when drops occur.
- **Suggested fix:** Persist dropped fill identifiers, trigger REST backfill.

---

### E-H8. `kernel_shadow_report.py` — `ShadowReport.comparisons` list grows without bound

- **File:** `engine/kernel_shadow_report.py:35, 59-60`
- **Category:** Memory Leak
- **Root cause:** `ShadowReport.comparisons` is an unbounded `list`. In a 24/7 daemon processing signals every minute across 50 symbols, this accumulates ~4.3M entries per day.
- **Impact:** Memory consumption grows linearly, eventually causing OOM and daemon crash.
- **Acceptance criteria:**
  1. `comparisons` replaced with `collections.deque(maxlen=N)` or capped with eviction.
  2. Memory remains bounded over multi-day runs.
- **Suggested fix:** Use `deque(maxlen=N)`.

---

### E-H9. `core.py` — `_entry_is_too_late` max delay upper bound allows week-long delays

- **File:** `engine/core.py:1008`
- **Category:** Input Validation
- **Root cause:** The clamp on `_entry_max_delay_ms` allows up to `7 * 24 * 60 * 60 * 1000` (one week). An entry signal that is a week old should never be acted upon in crypto perpetual futures.
- **Impact:** Stale signals from days ago could theoretically be executed if the config is set incorrectly.
- **Acceptance criteria:**
  1. Upper bound reduced to a reasonable value (e.g. 2 hours: `2 * 60 * 60 * 1000`).
  2. Config validation rejects values above the new upper bound.
- **Suggested fix:** Reduce upper bound, add config validation.

---

### S-H1. `meta.py` — Module-level global mutable state without thread safety

- **File:** `exchange/meta.py:21-25, 37-129`
- **Category:** Race Condition
- **Root cause:** Global variables (`_cached_at_s`, `_cached_instruments`, `_cached_margin_tables`, `_next_refresh_allowed_s`) are read and written from multiple threads without locks.
- **Impact:** Data race during `_refresh_cache()` could cause the trading loop to read a partially-updated instruments dict → incorrect `sz_decimals` (wrong order size rounding), incorrect funding rates, or incorrect max leverage. **Potential for incorrectly-sized orders.**
- **Acceptance criteria:**
  1. `threading.Lock` protects all reads and writes of cached metadata.
  2. Unit test demonstrating concurrent access correctness.
- **Suggested fix:** Add `threading.Lock` around `_refresh_cache()` and reads.

---

### S-H2. `meta.py` — `round_size` uses float arithmetic that can produce incorrect results

- **File:** `exchange/meta.py:196`
- **Category:** Numeric Precision
- **Root cause:** `round_size` computes `int(size * factor) / factor` using `int()` which truncates toward zero. For values like `size=0.1, factor=10`, `size * factor` may be `0.9999999999999999` due to IEEE 754 floating point, producing `int(0.999...) = 0` instead of the expected `1`. Same issue in `broker_adapter.py:607` with `math.floor`.
- **Impact:** Order sizes could be rounded to zero or incorrectly, causing rejected orders or wrong position sizes.
- **Acceptance criteria:**
  1. `round_size` uses `Decimal` arithmetic or applies epsilon before truncation.
  2. Edge cases (0.1, 0.3, etc.) produce correct results in unit tests.
- **Suggested fix:** Use `Decimal` or `int(size * factor + 1e-9) / factor`.

---

### S-H3. `shadow_mode.py` — `ShadowDecisionTracker._comparisons` list grows without bound

- **File:** `strategy/shadow_mode.py:157`
- **Category:** Memory Leak
- **Root cause:** The `_comparisons` list is append-only and never pruned. With 50 symbols and entries every few minutes, this accumulates millions of entries over weeks.
- **Impact:** Continuous memory growth → eventual OOM crash of daemon.
- **Acceptance criteria:**
  1. `_comparisons` capped to a maximum size (e.g. `2 * window_size`) with old entry eviction.
  2. Memory bounded in long-running tests.
- **Suggested fix:** Cap list size or use `deque(maxlen=N)`.

---

### S-H4. `live/trader.py` — SQLite connections in hot paths without WAL mode

- **File:** `live/trader.py:407-416, 575-577`
- **Category:** Performance / State Management
- **Root cause:** `sync_from_exchange()` opens a SQLite connection on every trading loop iteration without setting WAL mode. If another process writes to the same DB simultaneously, SQLite can block the live trading loop for up to `_DB_TIMEOUT_S = 5` seconds.
- **Impact:** Live trading loop stalled for up to 5 seconds during DB contention → delayed exit orders during volatile markets.
- **Acceptance criteria:**
  1. `PRAGMA journal_mode=WAL` set on connections in `sync_from_exchange()` and `upsert_position_state()`.
  2. Or use a connection pool with WAL pre-configured.
- **Suggested fix:** Set WAL mode on all connections, or use connection pool.

---

### S-H5. `executor.py` — `market_close` uses private SDK method `_slippage_price`

- **File:** `exchange/executor.py:411`
- **Category:** Exchange API Safety / Fragility
- **Root cause:** `market_close()` calls `self._exchange._slippage_price()`, a private (underscore-prefixed) method of the Hyperliquid SDK. This method could be renamed or removed in any SDK update.
- **Impact:** If `_slippage_price` fails, `limit_px` becomes `None` and the close order is silently abandoned (returns `None`). A stop-loss or take-profit exit fails silently. **Financial loss risk.**
- **Acceptance criteria:**
  1. Slippage calculation implemented locally (simple `price * (1 +/- slippage)` matching `apply_slippage()` in `broker_adapter.py`).
  2. Fallback to local calculation if SDK method fails.
  3. Warning logged when SDK method unavailable.
- **Suggested fix:** Implement slippage locally, use SDK as optional optimisation.

---

### S-H6. `kernel_orchestrator.py` — No validation of kernel `schema_version`

- **File:** `strategy/kernel_orchestrator.py:695-744`
- **Category:** Signal Integrity
- **Root cause:** `_parse_kernel_response()` parses the kernel response envelope but never checks that `schema_version` matches `KERNEL_SCHEMA_VERSION = 1`.
- **Impact:** If the Rust kernel is updated to a new schema version but the Python side is not, the orchestrator could misparse intents, fills, or state → wrong trades.
- **Acceptance criteria:**
  1. `schema_version` in response validated against `KERNEL_SCHEMA_VERSION`.
  2. Mismatch logged as ERROR and response rejected (or WARN with fallback).
  3. Unit test covering version mismatch handling.
- **Suggested fix:** Validate and reject on mismatch.

---

### R-H1. Rust `RingBuf` — capacity 0 causes division by zero

- **File:** `backtester/crates/bt-core/src/indicators/mod.rs`
- **Category:** Input Validation
- **Root cause:** `RingBuf::new(window)` stores `capacity = window` and later uses `self.head % self.capacity` in `push()`. If `window == 0`, this panics with a division-by-zero. The ATR indicator has an early return for window 0, but Bollinger, RSI (via StochRsi), VolSma, and VolTrend pass their window directly through without guarding.
- **Impact:** Panic crashes the backtester sweep, losing all results computed so far.
- **Acceptance criteria:**
  1. `RingBuf::new()` asserts `window > 0` or clamps to `max(1)`.
  2. Alternatively, config validation at load time rejects all window params < 1.
  3. Unit test covering zero-window case.
- **Suggested fix:** Add `assert!(window > 0)` in `RingBuf::new()`.

---

### R-H2. Rust `AdxIndicator::new(0)` — division by zero in Wilder smoothing

- **File:** `backtester/crates/bt-core/src/indicators/adx.rs:138`
- **Category:** Input Validation
- **Root cause:** `self.window as f64` used as divisor in `wilder_step()` (line 179). When window is 0, the Wilder smoothing formula produces NaN that propagates through all ADX computations.
- **Impact:** All ADX-dependent decisions (entry gates, dynamic sizing) malfunction for the rest of the backtest run.
- **Acceptance criteria:**
  1. Zero-window guard in `AdxIndicator::new()` or `update()`.
  2. Unit test covering zero-window case.
- **Suggested fix:** Add guard matching ATR's approach.

---

### R-H3. Rust `RsiIndicator::new(0)` — division by zero

- **File:** `backtester/crates/bt-core/src/indicators/rsi.rs:52`
- **Category:** Input Validation
- **Root cause:** RSI divides by `self.window as f64` on line 52. With window 0, produces NaN. Additionally, `self.count >= self.window` is immediately true (0 >= 0), making the indicator report as "warm" after zero observations.
- **Impact:** RSI reads as NaN, gates evaluate incorrectly.
- **Acceptance criteria:**
  1. Zero-window guard in `RsiIndicator::new()`.
  2. Unit test covering zero-window case.
- **Suggested fix:** Guard against zero window.

---

### R-H4. Rust `GpuComboState` — `unsafe impl Pod/Zeroable` requires manual verification

- **File:** `backtester/crates/bt-gpu/src/buffers.rs:509-510`
- **Category:** Memory Safety
- **Root cause:** Manual `unsafe impl Pod` and `unsafe impl Zeroable` implementations because bytemuck's derive doesn't support `[T; 52]`. If the struct layout changes (e.g. adding a `bool`, `String`, `Vec`), these unsafe impls silently introduce undefined behaviour.
- **Impact:** Memory corruption, data races, or invalid GPU buffer reads/writes → wrong backtest results or crashes.
- **Acceptance criteria:**
  1. Comment explaining which invariants must be maintained for Pod safety.
  2. Compile-time assertions on struct size.
  3. `bytemuck::checked::cast_slice` used in tests for validation.
- **Suggested fix:** Add invariant documentation, compile-time checks, and test validation.

---

### R-H5. Rust GPU sweep — `expect()` panics on u32 overflow

- **File:** `backtester/crates/bt-gpu/src/lib.rs:377, 415-417`
- **Category:** Error Handling
- **Root cause:** `u32::try_from(num_symbols).expect(...)` and similar calls can panic on overflow. While `num_symbols` is capped at 52 by `GPU_MAX_SYMBOLS`, this is not enforced at the call site.
- **Impact:** Panic crashes the sweep, losing all results.
- **Acceptance criteria:**
  1. All `expect()` calls replaced with `map_err()` returning `Err` and skipping the batch.
  2. Consistent with the existing graceful error handling pattern.
- **Suggested fix:** Replace `expect()` with `map_err()`.

---

### R-H6. Rust TPE sweep — `expect()` for `num_bars` overflow

- **File:** `backtester/crates/bt-gpu/src/tpe_sweep.rs:491-493`
- **Category:** Error Handling
- **Root cause:** `u32::try_from(raw.num_bars)...expect("num_bars exceeds u32::MAX")` panics on overflow. The grid sweep path handles this gracefully; the TPE path does not.
- **Impact:** Panic crashes the sweep.
- **Acceptance criteria:**
  1. TPE path uses `.map_err(...)?` or match-and-return-empty like the grid path.
- **Suggested fix:** Match grid path's graceful handling.

---

### X-H1. `deploy_validate.py` — No upper bound on leverage

- **File:** `tools/deploy_validate.py:86`
- **Category:** Configuration Safety
- **Root cause:** Validation only checks `leverage >= 0.0` with no upper bound. Hyperliquid supports up to 50x leverage. A sweep could generate a config with dangerously high leverage that passes all validation gates.
- **Impact:** Deploying a config with e.g. 50x leverage to live trading → catastrophic loss risk.
- **Acceptance criteria:**
  1. Upper bound added: `req_number("global.trade.leverage", min_v=0.0, max_v=20.0)`.
  2. Also validate `leverage_low`, `leverage_medium`, `leverage_high`.
  3. `max_entry_orders_per_loop` gets an upper bound.
- **Suggested fix:** Add upper bounds for all leverage-related and sizing-related fields.

---

### X-H2. `deploy_sweep.py` — Bypasses all `promote_to_live.py` safety gates

- **File:** `tools/deploy_sweep.py:137-191, 278-289`
- **Category:** Deployment Safety
- **Root cause:** `deploy_sweep.py` has `--close-live` and `--restart` flags that close all live positions and restart the live trading service. Unlike `promote_to_live.py`, it does NOT: (a) call `validate_yaml_text()`, (b) verify profit factor/drawdown/kill events, (c) compute config hashes, (d) use atomic file writes.
- **Impact:** Raw sweep overrides can be deployed to live without any safety validation. **Potential for deploying untested parameters to real money trading.**
- **Acceptance criteria:**
  1. Either deprecate this tool (mark as paper-only) or add equivalent safety gates.
  2. At minimum: `validate_yaml_text()` before writing, atomic file writes, config hash tracking.
  3. `--no-live` guard preventing accidental live deployments.
- **Suggested fix:** Deprecate or harden; add safety gates equivalent to `promote_to_live.py`.

---

### T-H1. `sensitivity_check.py` — No timeout on subprocess calls

- **File:** `tools/sensitivity_check.py:86`
- **Category:** Robustness / Subprocess Management
- **Root cause:** `_run_cmd` helper calls `subprocess.run` without a `timeout` parameter. Default `--timeout-s` is 0 (no timeout).
- **Impact:** Backtester replays can hang indefinitely, stalling the entire factory pipeline.
- **Acceptance criteria:**
  1. `_run_cmd` accepts `timeout_s` parameter with sensible default (e.g. 600s).
  2. On timeout, child killed, error recorded.
- **Suggested fix:** Add timeout parameter, default to 600s.

---

### T-H2. `factory_run.py` — No signal handler for graceful shutdown

- **File:** `factory_run.py:2159-3514`
- **Category:** Process Management
- **Root cause:** `main()` does not install any signal handler for SIGTERM or SIGINT. When systemd stops the factory service, subprocesses become orphaned and metadata is not written.
- **Impact:** Orphaned backtester processes consume resources. No metadata about the interrupted run.
- **Acceptance criteria:**
  1. Signal handler sets a shutdown flag.
  2. Flag checked between pipeline stages.
  3. On shutdown, metadata written with `"status": "interrupted"` and child process terminated.
- **Suggested fix:** Install signal handler, check between stages.

---

### T-H3. `factory_run.py` — No top-level exception handler in `main()`

- **File:** `factory_run.py:2159-3514`
- **Category:** Error Handling
- **Root cause:** `main()` lacks a top-level `try/except` guard. An unexpected exception exits without writing error information to run metadata.
- **Impact:** Debugging is much harder — metadata reflects last successful checkpoint, not the actual failure.
- **Acceptance criteria:**
  1. Top-level `try/except Exception` wraps body of `main()`.
  2. Exception written to `meta["fatal_error"]`, metadata persisted via `_write_json`.
  3. Exception re-raised so exit code remains non-zero.
- **Suggested fix:** Wrap main() body in try/except, persist error metadata.

---

### T-H4. Monitor server — No rate limiting on API endpoints

- **File:** `monitor/server.py:2632-2812`
- **Category:** Security / Availability
- **Root cause:** No rate limiting on any endpoint. `/api/snapshot` performs multiple SQLite queries and Hyperliquid REST API calls per request. `ThreadingHTTPServer` creates a new thread per request.
- **Impact:** An attacker or misconfigured monitoring tool can flood the endpoint → excessive DB I/O, Hyperliquid API rate-limit exhaustion, or OOM.
- **Acceptance criteria:**
  1. Per-IP rate limiting (e.g. token bucket with 10 req/s burst).
  2. Global connection counter to reject above threshold.
  3. `ThreadingHTTPServer.request_queue_size` limited.
- **Suggested fix:** Implement rate limiting.

---

### T-H5. Test coverage gap — `slippage_stress.py` has zero tests

- **File:** Missing `tests/test_slippage_stress.py`
- **Category:** Test Coverage
- **Root cause:** The slippage stress tool (211 lines) directly influences which strategies go to paper and live trading. No dedicated tests exist.
- **Impact:** Bugs in PnL sign-flip detection or fragility computation could allow bad strategies through.
- **Acceptance criteria:**
  1. `tests/test_slippage_stress.py` created with tests for: normal operation, PnL sign flip detection, fragility metric, single replay failure handling, edge cases.
  2. At least 80% line coverage.
- **Suggested fix:** Create comprehensive test file.

---

### T-H6. Test coverage gap — `risk_drawdown_kill_switch` has only 2 tests

- **File:** `tests/test_risk_drawdown_kill_switch.py`
- **Category:** Test Coverage
- **Root cause:** The drawdown kill switch is the last line of defence against catastrophic losses. Only 2 tests exist — no boundary conditions, no recovery scenarios, no multi-kill-switch interaction.
- **Impact:** Bugs in the kill switch could allow trading to continue during severe drawdowns.
- **Acceptance criteria:**
  1. Expanded to at least 10 tests covering: boundary conditions, trigger-then-recover, multi-kill-switch interaction, persistent state, integration with engine drawdown computation.
- **Suggested fix:** Expand test suite.

---

# MEDIUM (49)

---

### E-M1. `utils.py` — `file_mtime` accepts None path without explicit check

- **File:** `engine/utils.py:33-37`
- **Category:** Input Validation
- **Root cause:** `file_mtime(path)` calls `os.path.getmtime(path)` which raises `TypeError` if `path` is `None`. The broad `except Exception` catches it, masking programming errors at call sites (e.g. `strategy_manager.py:237` where `_changelog_path` can be `None`).
- **Impact:** Programming errors masked, silent misbehaviour.
- **Acceptance criteria:** Add `if path is None: return None` at function top.

---

### E-M2. `utils.py` — `deep_merge` accepts non-dict `override` silently

- **File:** `engine/utils.py:12-30`
- **Category:** Input Validation
- **Root cause:** If `override` is not a dict (e.g. `None`, a string), `deep_merge` returns `base` unchanged with no warning. A YAML section accidentally set to a string instead of dict would cause live overrides to be silently ignored.
- **Impact:** Live trading could use paper-mode parameters without any error.
- **Acceptance criteria:** Log a warning when `override` is a non-None, non-dict value.

---

### E-M3. `strategy_manager.py` — Warns on world-writable YAML but loads anyway

- **File:** `engine/strategy_manager.py:201-224`
- **Category:** Security
- **Root cause:** When the YAML config file is world-writable (`S_IWOTH`), the method logs a warning but returns `True`, loading the file.
- **Impact:** Any user on the system can modify trading parameters for a real-money system.
- **Acceptance criteria:** Return `False` (skip reload) when file is world-writable, or make behaviour configurable via env var.

---

### E-M4. `core.py` — `_cfg_float` doesn't validate for NaN/Inf

- **File:** `engine/core.py:909-914`
- **Category:** Numeric Precision
- **Root cause:** Reads values from YAML and env vars but doesn't check for NaN or Inf. A YAML value like `heartbeat_every_s: .nan` or env var `AI_QUANT_HEARTBEAT_SECS=inf` would pass through.
- **Impact:** `heartbeat_every_s = inf` → heartbeat never fires → no operator alerts.
- **Acceptance criteria:** Add `math.isfinite(v)` check, fall back to `default` for non-finite.

---

### E-M5. `promoted_config.py` — Writes merged YAML without atomic rename

- **File:** `engine/promoted_config.py:203-212`
- **Category:** Robustness
- **Root cause:** `maybe_apply_promoted_config` writes directly to `active_path` using `write_text()`. A crash during write leaves a corrupt or truncated YAML file.
- **Impact:** Next daemon restart loads corrupt YAML → crash or misconfiguration.
- **Acceptance criteria:** Use atomic write pattern (write to `.tmp` then `os.replace()`).

---

### E-M6. `alerting.py` — `_alert_worker` has no graceful shutdown

- **File:** `engine/alerting.py:164-178`
- **Category:** Resource Leak
- **Root cause:** The alert worker thread runs `while True` with blocking `get()`. No shutdown mechanism or `atexit` handler. Pending alerts are dropped on process exit.
- **Impact:** Alerts about critical trading events (kill switch activation, exchange errors) may be lost on shutdown.
- **Acceptance criteria:** Sentinel value for shutdown, `atexit` handler to drain queue.

---

### E-M7. `market_data.py` — `_db_timeout_s` silently clamped to 5.0

- **File:** `engine/market_data.py:107`
- **Category:** Input Validation
- **Root cause:** `self._db_timeout_s = min(float(db_timeout_s), 5.0)` silently clamps the user-provided timeout. The caller in `daemon.py:1055` passes `float(os.getenv("AI_QUANT_DB_TIMEOUT_S", "30"))`, expecting 30s but getting 5s.
- **Impact:** Unexpected timeout failures during DB contention.
- **Acceptance criteria:** Either raise the cap or log when clamping occurs.

---

### E-M8. `oms.py` — `_coerce_ts_ms` heuristic for seconds vs milliseconds is imprecise

- **File:** `engine/oms.py:24-35`
- **Category:** Numeric Precision
- **Root cause:** Heuristic `if v > 1e12: return int(v)` else `return int(v * 1000)`. Works for current epoch but could misclassify boundary values or historical timestamps.
- **Impact:** Incorrect timestamp conversion → wrong trade ordering or cooldown calculations.
- **Acceptance criteria:** Document valid range, or use explicit unit specification at call sites.

---

### E-M9. `event_logger.py` — `_JsonlEventSink._run` silently returns if parent dir creation fails

- **File:** `engine/event_logger.py:154-157`
- **Category:** Error Handling
- **Root cause:** If `self._path.parent.mkdir()` raises (permission denied), the entire sink thread silently exits. No log is emitted.
- **Impact:** Events queued but never written → event data permanently lost.
- **Acceptance criteria:** Log an error before returning so operators know events are being lost.

---

### E-M10. `core.py` — `_ws_is_stale` returns True when `mids_age_s is None` without checking sidecar mode

- **File:** `engine/core.py:1023-1024`
- **Category:** Logic Bug
- **Root cause:** In sidecar-only mode, `mids_age_s` may legitimately be `None` because the sidecar doesn't report mid ages the same way. This triggers unnecessary WS restarts.
- **Impact:** WS restart during sidecar-only mode disrupts data ingestion.
- **Acceptance criteria:** Check `self._sidecar_only` and skip mid staleness check in sidecar-only mode.

---

### E-M11. `risk.py` — `_refresh_drawdown` never resets `_equity_peak` (except via `clear_kill`)

- **File:** `engine/risk.py:864-908`
- **Category:** Logic Bug
- **Root cause:** Drawdown uses all-time high-water mark. After a significant drawdown + partial recovery, even a minor pullback re-triggers the kill switch because the old peak persists.
- **Impact:** Unnecessary kill switch activations after recovery.
- **Acceptance criteria:** Either add configurable trailing window, or document the high-water-mark behaviour and add a `_equity_peak` reset when daily PnL resets.

---

### E-M12. `oms_reconciler.py` — `_cancel_exchange_order` tries `cancel_all_orders` as fallback

- **File:** `engine/oms_reconciler.py:635-638`
- **Category:** Financial Safety
- **Root cause:** The cancel method includes `cancel_all_orders(symbol=...)` as a fallback candidate. If executor's `cancel_all_orders` cancels ALL orders for a symbol (including manual protective orders), operator-placed protective orders could be cancelled.
- **Impact:** Operator's manual hedge/protective orders removed during reconciliation.
- **Acceptance criteria:** Remove `cancel_all_orders` from fallback list, or only use targeted cancels.

---

### E-M13. `risk.py` — `note_fill` early-returns on first exception, skipping subsequent checks

- **File:** `engine/risk.py:331-351`
- **Category:** Error Handling
- **Root cause:** Each `try/except` block has `return` in the except handler. If `_refresh_daily_loss` throws, `_refresh_slippage_guard` and `_refresh_perf_stop` are never called.
- **Impact:** A bug in daily loss tracking silently disables slippage guard and performance stop. **Independent safety rails cascade-fail.**
- **Acceptance criteria:** Change `return` to `pass` in except handlers so all three checks always run.

---

### S-M1. `mei_alpha_v1.py` — `bb_width` divides by Close without zero check

- **File:** `strategy/mei_alpha_v1.py:186`
- **Category:** Edge Cases / Zero Division
- **Root cause:** `bb_width = (bb_upper - bb_lower) / close` divides by close price Series. If any close is 0 (degenerate data), produces Inf/NaN.
- **Impact:** NaN propagates through gate evaluation, potentially allowing or blocking trades incorrectly.
- **Acceptance criteria:** `close.replace(0, 1)` or guard against zero.

---

### S-M2. `live/trader.py` — `_safe_float` returns 0.0 instead of None for missing `_created_at_s`

- **File:** `live/trader.py:749`
- **Category:** Edge Cases
- **Root cause:** `_safe_float(ctx.get("_created_at_s"), None)` returns `0.0` when val is None (not the `None` default). The check `if created is not None` on line 750 then passes erroneously (created is 0.0, not None).
- **Impact:** TTL check fails for entries where `_created_at_s` is genuinely missing.
- **Acceptance criteria:** Use `_safe_float(ctx.get("_created_at_s"), -1.0)` and check `if created >= 0`.

---

### S-M3. `live/trader.py` — Discord worker thread has no termination condition

- **File:** `live/trader.py:135-159`
- **Category:** Concurrency
- **Root cause:** The worker thread runs `while True` with no shutdown mechanism. In test scenarios with same-process restarts, the worker thread may leak.
- **Impact:** Thread leak in tests or process restart scenarios.
- **Acceptance criteria:** Add daemon thread flag check or `threading.Event` for shutdown.

---

### S-M4. `sidecar.py` — SidecarWSClient has no automatic reconnection

- **File:** `exchange/sidecar.py:114-209`
- **Category:** Exchange API Safety
- **Root cause:** `_rpc()` closes the connection on error but does not reconnect automatically. Callers must retry, and there is no exponential backoff at the RPC level.
- **Impact:** During sidecar restarts, every RPC call fails → reconnect → fail again. Trading data unavailable.
- **Acceptance criteria:** Add automatic reconnection with single retry after reconnect.

---

### S-M5. `mei_alpha_v1.py` — `kernel_position_to_python` `int(confidence_raw)` without error handling

- **File:** `strategy/mei_alpha_v1.py:1418`
- **Category:** Error Handling
- **Root cause:** `conf_map.get(int(confidence_raw), "medium")` can raise `TypeError`/`ValueError` if `confidence_raw` is a string, `None`, or unexpected format.
- **Impact:** Crash during position conversion → trading loop error.
- **Acceptance criteria:** Wrap in try/except with fallback.

---

### S-M6. `market_watch.py` — `_pct_return` can raise ZeroDivisionError

- **File:** `exchange/market_watch.py:119`
- **Category:** Edge Cases
- **Root cause:** `float(end) / float(start) - 1.0` raises if `start` is 0.
- **Impact:** Market watch crash.
- **Acceptance criteria:** Add `if float(start) == 0: return 0.0` guard.

---

### S-M7. `reconciler.py` — ULID generation uses `random.choices` (not cryptographic)

- **File:** `strategy/reconciler.py:667`, `shadow_mode.py:648`, `kernel_orchestrator.py:995`
- **Category:** Signal Integrity / Uniqueness
- **Root cause:** Uses `random.choices` (pseudo-random) for ULIDs. Two processes starting at the same millisecond could generate the same ULID → PRIMARY KEY collision on `decision_events` table. The `except Exception` handler swallows the collision error.
- **Impact:** Decision event silently dropped.
- **Acceptance criteria:** Use `secrets.token_hex` or `os.urandom` for the random component.

---

### S-M8. `executor.py` — `market_close` returns None silently when `_slippage_price` returns None

- **File:** `exchange/executor.py:414-416`
- **Category:** Financial Safety
- **Root cause:** If `_slippage_price` returns `None` (orderbook empty), `limit_px` is `None` and the function returns `None` without logging. The caller treats this as a rejection and does not retry.
- **Impact:** Genuine stop-loss exit fails silently when orderbook is briefly empty.
- **Acceptance criteria:** Log warning when `limit_px is None`, compute slippage locally as fallback.

---

### R-M1. Rust `Ema::new(0)` — creates alpha = 2.0, producing oscillating divergent values

- **File:** `backtester/crates/bt-core/src/indicators/ema.rs:24`
- **Category:** Input Validation / Numeric Precision
- **Root cause:** With window 0, `alpha = 2.0 / (0 + 1.0) = 2.0`. EMA formula `2.0 * price + (1.0 - 2.0) * prev = 2*price - prev` produces oscillating divergent values.
- **Impact:** All EMA-dependent computations produce garbage.
- **Acceptance criteria:** Clamp window to at least 1 in constructor.

---

### R-M2. Rust `bb_width_avg` — `RingBuf` may have zero capacity

- **File:** `backtester/crates/bt-core/src/indicators/mod.rs`
- **Category:** Input Validation
- **Root cause:** If `cfg.bb_width_avg_window == 0`, the ring buffer panics on first `push()`.
- **Impact:** Backtester panic.
- **Acceptance criteria:** Validate `bb_width_avg_window >= 1` at config load time.

---

### R-M3. Rust `MinPnlHeapEntry` — `Eq` uses f64 equality (NaN violates reflexivity)

- **File:** `backtester/crates/bt-gpu/src/layout.rs:24-29`
- **Category:** Logic Correctness
- **Root cause:** `PartialEq` compares `total_pnl` using `==` on f64. NaN != NaN violates `Eq` trait contract, potentially causing undefined `BinaryHeap` behaviour.
- **Impact:** Non-deterministic heap ordering with NaN PnL values.
- **Acceptance criteria:** Map NaN to sentinel in `PartialEq` consistent with `Ord` implementation.

---

### R-M4. Rust `generate_combinations` — recursive implementation may stack overflow

- **File:** `backtester/crates/bt-gpu/src/axis_split.rs:57`
- **Category:** Resource Management
- **Root cause:** Recursive function calling itself for `&axes[1..]`. With >100 axes, could stack overflow.
- **Impact:** Crash during extreme sweep configurations.
- **Acceptance criteria:** Convert to iterative implementation, or document axis count limit.

---

### R-M5. Rust ADX indicator — does not validate NaN/Inf inputs

- **File:** `backtester/crates/bt-core/src/indicators/adx.rs`
- **Category:** Input Validation
- **Root cause:** ATR has `is_finite()` guards (post H7 fix), but ADX does not. Non-finite inputs corrupt smoothed accumulators permanently.
- **Impact:** All ADX values produce NaN for the rest of the backtest.
- **Acceptance criteria:** Add `is_finite()` guard matching ATR's approach.

---

### R-M6. Rust RSI and Bollinger — do not validate NaN/Inf inputs

- **File:** `backtester/crates/bt-core/src/indicators/rsi.rs`, `bollinger.rs`
- **Category:** Input Validation
- **Root cause:** Same as R-M5. A single NaN close price poisons accumulators permanently.
- **Impact:** All RSI/BB values produce NaN.
- **Acceptance criteria:** Add `is_finite()` guards consistent with ATR.

---

### R-M7. Rust GPU — timestamp conversion truncation

- **File:** `backtester/crates/bt-gpu/src/raw_candles.rs:109`
- **Category:** Numeric Precision
- **Root cause:** `t_sec: (ts / 1000) as u32` truncates milliseconds to seconds in u32. Negative timestamps (pre-epoch) produce incorrect results via wrapping. u32 overflows at year 2106.
- **Impact:** Incorrect timestamps for pre-epoch test data.
- **Acceptance criteria:** `u32::try_from((ts / 1000).max(0))` with guard for negative timestamps.

---

### R-M8. Rust GPU — `f64 as f32` conversions unchecked for indicator configs

- **File:** `backtester/crates/bt-gpu/src/buffers.rs:158-177`
- **Category:** Numeric Precision
- **Root cause:** `GpuIndicatorConfig::from_strategy_config()` casts `usize` to `u32` with `as u32`. Corrupted configs with huge windows would silently truncate.
- **Impact:** Wrong indicator windows on GPU → incorrect backtest results.
- **Acceptance criteria:** Use `u32::try_from()` or validate window ranges at config load time.

---

### R-M9. Rust GPU — `GpuComboConfig` mixes `checked_f32` and unchecked `as f32` casts

- **File:** `backtester/crates/bt-gpu/src/buffers.rs:591-766`
- **Category:** Numeric Precision
- **Root cause:** Some fields use `checked_f32()` (allocation_pct, leverage) while others use plain `as f32` (trailing_start_atr, vol_baseline_pct). Inconsistent precision handling.
- **Impact:** Some fields could silently produce Inf in f32 from extreme f64 values.
- **Acceptance criteria:** Use `checked_f32()` consistently for all fields affecting trade sizing and PnL.

---

### R-M10. Rust GPU — `sub_candles_gpu.clone()` may be expensive

- **File:** `backtester/crates/bt-gpu/src/lib.rs:452-453`
- **Category:** Performance
- **Root cause:** `CudaSlice::clone()` may perform a device-to-device copy (not just ref count increment).
- **Impact:** GPU memory bandwidth wasted on redundant copies.
- **Acceptance criteria:** Verify clone is Arc-based (no-op), or pass by reference.

---

### R-M11. Rust CLI — `process::exit(1)` used throughout instead of returning `Result`

- **File:** `backtester/crates/bt-cli/src/main.rs:109-128`
- **Category:** Error Handling
- **Root cause:** Functions call `std::process::exit(1)` on error, preventing proper cleanup and making code untestable.
- **Impact:** No destructor cleanup, temporary files not removed.
- **Acceptance criteria:** Return `Result<T, Box<dyn Error>>` from helpers, propagate to `main()`.

---

### R-M12. Rust TPE — `tpe_handle.join().expect()` propagates panic to main thread

- **File:** `backtester/crates/bt-gpu/src/tpe_sweep.rs:770`
- **Category:** Error Handling
- **Root cause:** If the TPE sampler thread panics, `expect()` propagates the panic, losing all GPU results collected so far in `top_heap`.
- **Impact:** All sweep results lost on TPE thread panic.
- **Acceptance criteria:** Use `match tpe_handle.join()` and return results collected so far.

---

### X-M1. `inspect_schema.py` — Hardcoded paths and missing SQL identifier validation

- **File:** `tools/inspect_schema.py:3-4, 9`
- **Category:** Information Disclosure / SQL Injection
- **Root cause:** Hardcoded absolute paths to production DBs. `table_name` parameter used in f-string `PRAGMA table_info({table_name})` without `_validate_identifier()`.
- **Impact:** Filesystem structure revealed; SQL injection possible if function is called with untrusted input.
- **Acceptance criteria:** Use env vars or relative paths; add `_validate_identifier()`.

---

### X-M2. Example configs have aggressive parameters (allocation_pct 20-28.5%)

- **File:** `config/strategy_overrides.yaml.example:11`, `config/strategy_overrides.live.example.yaml:9`
- **Category:** Configuration Safety
- **Root cause:** Example configs contain sweep-optimised values (20-28.5% allocation, 3.3x leverage, 73.7% max_total_margin_pct) that operators may copy verbatim.
- **Impact:** Operators deploying example configs without review take excessive risk.
- **Acceptance criteria:** Ship conservative example (3% allocation), show aggressive values as comments.

---

### X-M3. `deploy_validate.py` — Missing validation for several critical fields

- **File:** `tools/deploy_validate.py:79-111`
- **Category:** Configuration Validation
- **Root cause:** Several trading-critical parameters lack validation: `leverage_low/medium/high` (no bounds), `tp_partial_pct` (should be 0-1), `max_adds_per_symbol` (unbounded), `max_entry_orders_per_loop` (unbounded), `trailing_distance_atr`/`trailing_start_atr` (could be 0 or negative), `entry_min_confidence` (not validated as enum), engine interval fields (not validated at all).
- **Impact:** Invalid config values deployed to live trading.
- **Acceptance criteria:** Add validation with reasonable bounds for all listed fields.

---

### X-M4. CI `gpu-decision-parity-gate.yml` — Missing permissions block

- **File:** `.github/workflows/gpu-decision-parity-gate.yml`
- **Category:** CI Security
- **Root cause:** Unlike other workflows which specify `permissions: contents: read`, this workflow inherits default (broader) permissions.
- **Impact:** Workflow has unnecessary write access to repo contents.
- **Acceptance criteria:** Add `permissions: contents: read`.

---

### X-M5. No dependency scanning or vulnerability checks in CI

- **File:** CI workflows directory
- **Category:** Supply Chain Security
- **Root cause:** No Dependabot, `pip-audit`, `cargo-audit`, or SAST scanning. System depends on `hyperliquid-python-sdk`, `eth-account`, and other third-party packages.
- **Impact:** Vulnerable dependencies could be exploited.
- **Acceptance criteria:** Add `pip-audit` and `cargo-audit` CI steps; enable Dependabot.

---

### T-M1. `fetch_funding_rates.py` — No retry logic for API failures

- **File:** `tools/fetch_funding_rates.py:80-130`
- **Category:** Robustness
- **Root cause:** API calls have no retry logic for transient HTTP errors (429, 503). Failed symbols are simply skipped.
- **Impact:** Missing funding rate data for some symbols → incorrect backtest results.
- **Acceptance criteria:** Wrap API call in retry loop with exponential backoff (3 retries).

---

### T-M2. `interval_orchestrator.py` — No timeout on systemctl commands

- **File:** `tools/interval_orchestrator.py`
- **Category:** Robustness
- **Root cause:** `subprocess.run` for `systemctl restart`/`is-active` with no timeout. If a systemd unit hangs, orchestrator blocks indefinitely.
- **Impact:** All trading halted with pause file in place, no recovery.
- **Acceptance criteria:** Add timeout (120s) to all subprocess calls.

---

### T-M3. `slippage_stress.py` — Exits immediately on single replay failure

- **File:** `tools/slippage_stress.py:140`
- **Category:** Error Handling
- **Root cause:** Any single failed replay causes `SystemExit`, discarding results from successful levels.
- **Impact:** One transient failure aborts entire slippage analysis.
- **Acceptance criteria:** Record failure per level, continue with remaining, mark aggregate as degraded.

---

### T-M4. `factory_run.py` — 3870-line single file with high cyclomatic complexity

- **File:** `factory_run.py` (entire file)
- **Category:** Maintainability
- **Root cause:** `main()` alone spans 1350+ lines. Contains CLI parsing, data checks, sweep orchestration, candidate generation, replay, validation, scoring, reporting, and promotion.
- **Impact:** Difficult to review, test, and modify safely.
- **Acceptance criteria:** Extract distinct pipeline stages into separate modules. `main()` orchestrates modules.

---

### T-M5. Monitor — POST handler has no request body size limit

- **File:** `monitor/server.py:2774-2778`
- **Category:** Security
- **Root cause:** `self.rfile.read(content_length)` reads arbitrary size based on `Content-Length` header with no upper bound check.
- **Impact:** Malicious client sends `Content-Length: 2147483647` → OOM crash.
- **Acceptance criteria:** Reject requests with `Content-Length > 1MB` with `413 Payload Too Large`.

---

### T-M6. Monitor — Auth token compared without constant-time comparison

- **File:** `monitor/server.py:2618-2630`
- **Category:** Security
- **Root cause:** Bearer token compared with `==` instead of `hmac.compare_digest()`.
- **Impact:** Timing side-channel attack could determine correct token character by character.
- **Acceptance criteria:** Use `hmac.compare_digest()` for token comparison.

---

### T-M7. Monitor — No HTTPS; token transmitted in plaintext

- **File:** `monitor/server.py:2820-2823`
- **Category:** Security
- **Root cause:** Server binds as plain HTTP. When a token is set but connection is HTTP, the bearer token is interceptable.
- **Impact:** Token snoopable on the network.
- **Acceptance criteria:** Document reverse-proxy requirement; refuse non-localhost bind + token + no-TLS, or add native TLS.

---

### T-M8. Test coverage gap — `sensitivity_check.py` has only 1 test

- **File:** `tests/test_sensitivity_check.py`
- **Category:** Test Coverage
- **Root cause:** 457-line tool with only 1 test (aggregation helper). No tests for perturbation generation, variant validation, YAML modification, subprocess invocation, or timeout handling.
- **Impact:** Bugs in one of the most complex tools go undetected.
- **Acceptance criteria:** Add tests for perturbation parsing, variant validation, YAML modification, positive_rate computation.

---

### T-M9. Test coverage gap — `prune_runtime_logs.py` has no tests

- **File:** Missing `tests/test_prune_runtime_logs.py`
- **Category:** Test Coverage
- **Root cause:** Log pruning tool (103 lines) has no test coverage.
- **Impact:** Bugs could silently delete too much data or fail under lock contention.
- **Acceptance criteria:** Create tests for correct row deletion, VACUUM, locked DB handling, missing tables.

---

### T-M10. Test coverage gap — `fetch_funding_rates.py` has no tests

- **File:** Missing `tests/test_fetch_funding_rates.py`
- **Category:** Test Coverage
- **Root cause:** Funding rates fetcher (167 lines) writes to DB consumed by backtester/factory. No tests.
- **Impact:** INSERT idempotency, symbol resolution, or error handling bugs go undetected.
- **Acceptance criteria:** Create tests with mocked HTTP responses.

---

### T-M11. Test coverage gap — `rollback_to_last_good.py` has only 2 tests (no error paths)

- **File:** `tests/test_rollback_to_last_good.py`
- **Category:** Test Coverage
- **Root cause:** Only happy-path tests. No tests for missing backup, corrupt backup, permission errors, concurrent rollback.
- **Impact:** Rollback may fail silently when needed most.
- **Acceptance criteria:** Add error-path tests.

---

### T-M12. Test coverage gap — `interval_orchestrator.py` has only 3 tests (no failure paths)

- **File:** `tests/test_interval_orchestrator.py`
- **Category:** Test Coverage
- **Root cause:** No tests for service restart failure, pause file cleanup on partial failure, or timeout during verification.
- **Impact:** Failures during interval switch could leave trading paused.
- **Acceptance criteria:** Add mocked `subprocess.run` failure-path tests.

---

### T-M13. Test coverage gap — Monitor server has no HTTP integration tests

- **File:** Missing `tests/test_monitor_server.py`
- **Category:** Test Coverage
- **Root cause:** 2839-line server with no integration tests. Auth enforcement, path traversal, Prometheus output format untested.
- **Impact:** Security and correctness bugs in HTTP handling go undetected.
- **Acceptance criteria:** Create integration tests using `http.client`.

---

### T-M14. Test coverage gap — `factory_run.py` e2e tests don't cover failure paths

- **File:** `tests/test_factory_e2e_pipeline.py`
- **Category:** Test Coverage
- **Root cause:** 22 tests exist but none cover: subprocess hanging, disk full, SIGTERM handling, resume with corrupted metadata.
- **Impact:** Production failure scenarios untested.
- **Acceptance criteria:** Add failure-scenario tests with mocked `_run_cmd`.

---

# LOW (39)

---

### E-L1. `utils.py` — `sha1_json` uses SHA-1

- **File:** `engine/utils.py:46`
- **Category:** Security
- **Root cause:** SHA-1 used for config change detection while `event_logger.py` uses SHA-256.
- **Impact:** Inconsistency; SHA-1 is cryptographically weak (though not used for auth here).
- **Acceptance criteria:** Replace with SHA-256 for consistency.

---

### E-L2. `_env_bool` defined identically in 7 files

- **Files:** `core.py:44`, `daemon.py:38`, `market_data.py:29`, `risk.py:25`, `oms_reconciler.py:14`, `alerting.py:12`, `strategy_manager.py:23`
- **Category:** DRY Violation
- **Root cause:** Copy-pasted across 7 files.
- **Impact:** Bug fix in one copy won't propagate.
- **Acceptance criteria:** Move to `utils.py` and import.

---

### E-L3. `core.py` — `KernelDecisionFileProvider._load_raw` reads JSON without size limit

- **File:** `engine/core.py:182-206`
- **Category:** Input Validation
- **Root cause:** `json.load(fh)` reads entire file into memory.
- **Impact:** If the file is extremely large (bug in writing process), excessive memory consumption.
- **Acceptance criteria:** Add size check before reading.

---

### E-L4. `_interval_to_ms` — Inconsistent defaults between `core.py` and `market_data.py`

- **Files:** `core.py:51-65`, `market_data.py:36-57`
- **Category:** Robustness
- **Root cause:** `core.py` returns 0 for invalid input; `market_data.py` returns 3600000 (1 hour).
- **Impact:** Subtle bugs if wrong default assumed.
- **Acceptance criteria:** Consolidate into single implementation in `utils.py`.

---

### E-L5. `kernel_shadow_report.py` — `to_json` opens file without encoding spec

- **File:** `engine/kernel_shadow_report.py:113-114`
- **Category:** Robustness
- **Root cause:** `open(path, "w")` uses system default encoding.
- **Impact:** Encoding mismatch across environments.
- **Acceptance criteria:** Add `encoding="utf-8"`.

---

### E-L6. `event_logger.py` — Lost items in pending list on write error

- **File:** `engine/event_logger.py:150-197`
- **Category:** Resource Leak
- **Root cause:** On exception in write loop, `pending` list is cleared, losing queued items.
- **Impact:** Queued events permanently lost.
- **Acceptance criteria:** Move items back to queue on error, or log count of lost items.

---

### E-L7. `promoted_config.py` — `_find_latest_promoted_config` scans entire artifacts tree

- **File:** `engine/promoted_config.py:45-93`
- **Category:** Performance
- **Root cause:** Iterates all date directories and run directories. Over months, hundreds of directories.
- **Impact:** Slow daemon restart on slow filesystems.
- **Acceptance criteria:** Only scan last N date directories (e.g. 7 days).

---

### E-L8. `daemon.py` — `main()` has 200+ lines of procedural setup

- **File:** `engine/daemon.py:945-1157`
- **Category:** Maintainability
- **Root cause:** Long sequence of setup steps with many try/except blocks.
- **Impact:** Hard to reason about error propagation.
- **Acceptance criteria:** Break into smaller functions.

---

### S-L1. Duplicated `_generate_event_id()` across three modules

- **Files:** `reconciler.py:654`, `shadow_mode.py:634`, `kernel_orchestrator.py:982`
- **Category:** DRY Violation
- **Root cause:** Same ULID function copy-pasted to avoid circular imports.
- **Impact:** Fix to one copy won't propagate.
- **Acceptance criteria:** Move to shared `utils/id.py`.

---

### S-L2. `ws.py` — `get_candles_df` may return DataFrame with None/NaN OHLCV

- **File:** `exchange/ws.py:442-458`
- **Category:** Edge Cases
- **Root cause:** `float(o) if o is not None else None` propagates None into DataFrame. `pd.to_numeric(errors="coerce")` converts to NaN.
- **Impact:** Downstream `ta` library indicators may produce unexpected results with NaN.
- **Acceptance criteria:** Add `df.dropna(subset=["Open","High","Low","Close","Volume"])` or fill-forward.

---

### S-L3. `mei_alpha_v1.py` — `_json_default` silently converts NaN/Inf to strings

- **File:** `strategy/mei_alpha_v1.py:271-282`
- **Category:** Error Handling
- **Root cause:** Catches all exceptions and falls back to `str(o)`. NaN becomes `"nan"` string in JSON.
- **Impact:** Rust kernel fails to parse `"nan"` as float; error masked.
- **Acceptance criteria:** Explicitly handle `float('nan')` and `float('inf')` by converting to `0.0` or `null`.

---

### S-L4. `live/trader.py` — `LiveTrader.__init__` calls `super().__init__()` last

- **File:** `live/trader.py:319`
- **Category:** Code Quality
- **Root cause:** Sets up instance variables before calling `super().__init__()` (PaperTrader). Fragile if parent constructor changes.
- **Impact:** Breakage if PaperTrader.__init__() accesses LiveTrader-specific attributes.
- **Acceptance criteria:** Document ordering dependency.

---

### S-L5. `executor.py` — Uses `print()` instead of `logger` for exchange errors

- **File:** `exchange/executor.py:265, 275, 279, 300, 344, 359`
- **Category:** Code Quality
- **Root cause:** `print()` with emoji prefixes instead of `logger.warning()`/`logger.error()`.
- **Impact:** Bypasses structured logging; harder to filter and alert in production.
- **Acceptance criteria:** Replace `print()` with appropriate `logger` calls.

---

### S-L6. `ws.py` — Module-level global `hl_ws` created at import time

- **File:** `exchange/ws.py:820`
- **Category:** Testability
- **Root cause:** `hl_ws = _make_default_ws()` runs at import time, creating real WS connection.
- **Impact:** Importing from tests creates real connections, causing flakiness.
- **Acceptance criteria:** Use lazy initialisation or factory pattern.

---

### R-L1. Rust `ACCOUNTING_QUANTUM` (1e12) — precision limit for large PnL

- **File:** `backtester/crates/bt-core/src/accounting.rs`
- **Category:** Numeric Precision
- **Root cause:** `quantise(x) = (x * 1e12).round() / 1e12` — at values exceeding $10,000, f64 mantissa leaves only ~12 significant digits. The quantum operates near the precision limit.
- **Impact:** Acceptable for typical account sizes but should be documented.
- **Acceptance criteria:** Document the precision boundary.

---

### R-L2. Rust `Confidence::from_str` — defaults unknown strings to `High`

- **File:** `backtester/crates/bt-signals/src/lib.rs:38`
- **Category:** Input Validation
- **Root cause:** `from_str("typo")` returns `Confidence::High` silently.
- **Impact:** Config typo silently treated as highest confidence → increased trade sizes.
- **Acceptance criteria:** Log a warning for unrecognised strings, or return `Result`.

---

### R-L3. Rust `MacdMode::from_str` — defaults unknown strings to `Accel`

- **File:** `backtester/crates/bt-signals/src/lib.rs:81`
- **Category:** Input Validation
- **Root cause:** Same as R-L2.
- **Impact:** Config typo silently treated as specific MACD mode.
- **Acceptance criteria:** Log warning or return `Result`.

---

### R-L4. Rust ADX — Stale `_close` parameter unused in `compute_dm_tr`

- **File:** `backtester/crates/bt-core/src/indicators/adx.rs:153`
- **Category:** Code Quality
- **Root cause:** `_close` parameter never used; True Range reads from `self.prev_close`.
- **Impact:** Misleading API; could confuse maintainers.
- **Acceptance criteria:** Remove unused parameter.

---

### R-L5. Rust `bt-runtime` — `validation_error` clones `details` unnecessarily

- **File:** `backtester/crates/bt-runtime/src/lib.rs:41`
- **Category:** Performance
- **Root cause:** `details.clone()` creates a backup used only in a JSON serialisation fallback that should never execute.
- **Impact:** Unnecessary allocation.
- **Acceptance criteria:** Clone only inside `unwrap_or_else` closure, or remove fallback.

---

### R-L6. Rust GPU — `as u32` truncation for `add_min_confidence` / `entry_min_confidence`

- **File:** `backtester/crates/bt-gpu/src/buffers.rs:641-642`
- **Category:** Numeric Precision
- **Root cause:** `Confidence` enum has only 3 variants (safe), but `as` cast is fragile if representation changes.
- **Impact:** Fragile to enum changes.
- **Acceptance criteria:** Use `Confidence::rank()` explicitly.

---

### R-L7. Rust MACD indicator — does not track warmup status

- **File:** `backtester/crates/bt-core/src/indicators/macd.rs`
- **Category:** Logic Correctness
- **Root cause:** Unlike EMA/ATR/RSI/ADX, MACD has no `is_warm()` method. Produces values from bar 0 even though the slow EMA hasn't converged.
- **Impact:** Early MACD values may not match Python reference.
- **Acceptance criteria:** Add warmup tracking or document behaviour.

---

### R-L8. Rust GPU — `partial_cmp(...).unwrap_or(Ordering::Equal)` for f64 sorting

- **File:** `backtester/crates/bt-gpu/src/lib.rs:546`
- **Category:** Logic Correctness
- **Root cause:** NaN values treated as equal to everything → non-deterministic sort.
- **Impact:** Non-deterministic result ordering with NaN PnL.
- **Acceptance criteria:** Use `f64::total_cmp()` or map NaN to `NEG_INFINITY`.

---

### X-L1. Hardcoded Discord channel ID in factory service file

- **File:** `systemd/openclaw-ai-quant-factory-v8.service.example:24`
- **Category:** Information Disclosure
- **Root cause:** Discord channel ID embedded directly in ExecStart.
- **Impact:** Minor information leakage; rotation requires service file edit.
- **Acceptance criteria:** Move to EnvironmentFile.

---

### X-L2. Monitor server exposes `main_address` in error responses

- **File:** `monitor/server.py:396-403`
- **Category:** Information Disclosure
- **Root cause:** Error response dict includes `"main_address"` even though line 1386 strips it from primary response.
- **Impact:** Public wallet address exposed via error path.
- **Acceptance criteria:** Strip `main_address` from error responses too.

---

### X-L3. Factory service missing `TimeoutStartSec`

- **File:** `systemd/openclaw-ai-quant-factory-v8.service.example`
- **Category:** Operational Safety
- **Root cause:** `Type=oneshot` with no `TimeoutStartSec`. Default is infinity for oneshot. Hung backtest runs forever.
- **Impact:** Hung factory blocks subsequent runs.
- **Acceptance criteria:** Add `TimeoutStartSec=7200` (2 hours).

---

### X-L4. No `WatchdogSec` for long-running daemon services

- **File:** All `Type=simple` service files
- **Category:** Operational Reliability
- **Root cause:** No systemd watchdog configured. Deadlocked daemon (stuck GIL, hung SQLite lock) is not detected.
- **Impact:** Deadlocked daemon stays in "active" state indefinitely.
- **Acceptance criteria:** Add `WatchdogSec=300` and implement `sd_notify(WATCHDOG=1)` in main loop.

---

### X-L5. No `SystemCallFilter` directive in systemd services

- **File:** All systemd service files
- **Category:** Defence in Depth
- **Root cause:** Services have namespace/capability restrictions but not syscall filtering.
- **Impact:** Wider syscall surface than necessary.
- **Acceptance criteria:** Add `SystemCallFilter=@system-service` (test thoroughly).

---

### X-L6. CI workflows do not run on `master` branch

- **File:** All workflow files
- **Category:** CI Coverage
- **Root cause:** All workflows trigger on `major-v8` branch only.
- **Impact:** Code merged to production gets no automated testing.
- **Acceptance criteria:** Add `master` branch triggers.

---

### X-L7. `inspect_schema.py` — missing `_validate_identifier`

- **File:** `tools/inspect_schema.py:9`
- **Category:** SQL Injection (low risk — hardcoded table names)
- **Root cause:** `table_name` interpolated into PRAGMA without validation.
- **Impact:** Inconsistent with safe pattern used elsewhere.
- **Acceptance criteria:** Add `_validate_identifier(table_name)`.

---

### X-L8. `export_live_canonical_snapshot.py` — missing `_validate_identifier`

- **File:** `tools/export_live_canonical_snapshot.py:88`
- **Category:** SQL Injection (low risk)
- **Root cause:** `_max_id` uses f-string with `table_name` without validation.
- **Impact:** Inconsistent with safe pattern.
- **Acceptance criteria:** Add `_validate_identifier(table_name)`.

---

### T-L1. `rollback_to_last_good.py` — PID-based temp file name

- **File:** `tools/rollback_to_last_good.py:47`
- **Category:** Robustness
- **Root cause:** Uses `os.getpid()` as temp file suffix. PID reuse in containers could collide.
- **Impact:** Stale temp file from crashed run interferes.
- **Acceptance criteria:** Use `tempfile.NamedTemporaryFile` instead.

---

### T-L2. `reality_check.py` — Mutates `os.environ` globally

- **File:** `tools/reality_check.py:127-134`
- **Category:** Side Effects
- **Root cause:** Sets `os.environ` keys unconditionally at module level.
- **Impact:** If imported as library, affects entire process.
- **Acceptance criteria:** Set env vars only in `if __name__ == "__main__"` block.

---

### T-L3. `prune_runtime_logs.py` — Short 2.0s SQLite timeout

- **File:** `tools/prune_runtime_logs.py:48`
- **Category:** Robustness
- **Root cause:** 2.0s SQLite timeout. Live trader actively writing to same DB can cause lock contention.
- **Impact:** Prune fails with `database is locked`.
- **Acceptance criteria:** Increase to 10-30s, set WAL mode, retry on contention.

---

### T-L4. `check_funding_rates_db.py` — Lacks PRAGMA journal_mode check

- **File:** `tools/check_funding_rates_db.py:90`
- **Category:** Robustness
- **Root cause:** Opens DB in read-only mode (good) but doesn't verify WAL journal mode.
- **Impact:** Concurrent access may be unreliable without WAL.
- **Acceptance criteria:** Add `PRAGMA journal_mode` check on open, warn if not WAL.

---

### T-L5. `factory_cycle.py` — Reads `/proc/{pid}/environ` which may contain secrets

- **File:** `tools/factory_cycle.py:~300`
- **Category:** Information Leakage
- **Root cause:** Reads process environ for introspection. May contain API keys, tokens.
- **Impact:** If logged or sent to Discord, secrets leak.
- **Acceptance criteria:** Filter out `*_KEY`, `*_SECRET`, `*_TOKEN`, `*_PASSWORD` before use.

---

### T-L6. `factory_run.py` — `_ensure_cuda_env` mutates `os.environ` globally

- **File:** `factory_run.py:2138-2156`
- **Category:** Side Effects
- **Root cause:** `os.environ["LD_LIBRARY_PATH"]` mutated at process level, affecting all child processes.
- **Impact:** Python tools that don't need CUDA get the modified env.
- **Acceptance criteria:** Pass augmented `LD_LIBRARY_PATH` only to Rust backtester subprocess `env` dict.

---

### T-L7. `factory_run.py` — File descriptor management fragile in `_run_cmd`

- **File:** `factory_run.py:644-680`
- **Category:** Resource Cleanup
- **Root cause:** If `subprocess.run` raises (e.g. `FileNotFoundError`), `exit_code` is unbound. The pattern is fragile.
- **Impact:** Potential `UnboundLocalError` on exception paths.
- **Acceptance criteria:** Initialise `exit_code = -1` before `try` block.

---

### T-L8. Monitor — Dashboard state cache has no size bound

- **File:** `monitor/server.py:~150-250`
- **Category:** Memory Management
- **Root cause:** `MidsFeed` stores per-symbol price history with no explicit memory cap.
- **Impact:** Memory grows over long-running periods.
- **Acceptance criteria:** Add explicit `maxlen` on per-symbol deques.

---

### T-L9. Monitor — `log_message` silenced entirely

- **File:** `monitor/server.py:2814-2816`
- **Category:** Observability
- **Root cause:** `log_message` overridden to no-op, suppressing all HTTP access logs.
- **Impact:** No access log for debugging auth failures or unusual patterns.
- **Acceptance criteria:** Log at DEBUG level to file; at minimum log 4xx/5xx.

---

### T-L10. Test coverage gap — `reality_check.py` has no tests

- **File:** Missing `tests/test_reality_check.py`
- **Category:** Test Coverage
- **Root cause:** Read-only diagnostic tool (191 lines) untested.
- **Impact:** Regressions in `os.environ` mutation and DB query logic go undetected.
- **Acceptance criteria:** Create basic tests for missing DB handling and trade parsing.

---

### T-L11. Test coverage gap — `promote_candidates` missing degenerate case test

- **File:** `tests/test_promote_candidates.py`
- **Category:** Test Coverage
- **Root cause:** No test for when primary/fallback/conservative roles all select the same candidate (only 1 positive-PnL candidate).
- **Impact:** Could write same config 3 times under different role names.
- **Acceptance criteria:** Add degenerate single-candidate test.

---

# POSITIVE FINDINGS (No Action Needed)

| # | Area | Status |
|---|------|--------|
| P1 | Secrets handling — `load_live_secrets()` uses atomic `os.open()` + `os.fstat()`, enforce chmod 600, validate format | Good |
| P2 | `.gitignore` properly excludes `secrets.json`, `.env`, `*.db`, `*.key`, `*.pem` | Good |
| P3 | All DB creation paths apply `PRAGMA journal_mode=WAL` and `os.chmod(0o600)` | Good |
| P4 | SQL injection protected by `_validate_identifier()` pattern where f-strings used | Good |
| P5 | Live safety gates require `AI_QUANT_LIVE_ENABLE=1` + exact string confirmation | Good |
| P6 | Risk Manager has comprehensive circuit breakers (kill switch, rate limit, drawdown, daily loss, slippage, exposure, portfolio heat, perf stop) | Good |
| P7 | Systemd services have NoNewPrivileges, ProtectSystem=strict, PrivateTmp, MemoryMax, TasksMax, StartLimitBurst | Good |
| P8 | Default mode is `dry_live` — real trading requires explicit opt-in | Good |
| P9 | Heartbeat module has thorough test coverage (11 tests) | Good |

---

# CROSS-REFERENCES WITH PRIOR AUDITS

Items below were identified in prior audits and are already resolved. They appear here only for traceability.

| Prior ID | Description | Resolved In |
|----------|-------------|-------------|
| R2-H2 | TOCTOU race in secrets file permission check | PR #446 |
| R2-H5 | `rest_client.py` `json.load(resp)` blocks indefinitely | PR #446 |
| R2-M4 | Systemd services missing resource limits | PR #446 |
| R3-C2 | GPU `.expect()` panics on recoverable errors | PR #469 |
| R3-C3 | Atomic write race in `promote_to_live.py` | PR #469 |
| R3-H5 | Monitor server — no authentication | PR #469 |

---

# SUGGESTED REMEDIATION PRIORITY

## Immediate (production safety — should fix before next market open)

1. **S-C1** — BrokerAdapter max notional guard
2. **E-M13** — `note_fill` early-return cascading safety-check failure
3. **X-H1** — `deploy_validate.py` leverage upper bound
4. **S-H1** — `meta.py` thread-safe cache
5. **S-C2** — WS disconnect staleness timestamps (not clear)
6. **T-C1** — `factory_run.py` subprocess timeout

## Short-term (1-2 weeks)

7. **T-H2 + T-H3** — Factory signal handler + top-level exception handler
8. **S-H5** — Executor local slippage calculation
9. **R-H1 + R-H2 + R-H3** — Rust indicator zero-window guards (one config validation fixes all)
10. **R-M5 + R-M6** — Rust NaN/Inf input guards for ADX/RSI/Bollinger
11. **X-H2** — Deprecate or harden `deploy_sweep.py`
12. **T-H4** — Monitor rate limiting
13. **T-H6** — Expand drawdown kill switch tests
14. **E-H7** — Pending fills recovery mechanism

## Medium-term (1-2 months)

15. **X-M5** — Add `pip-audit` / `cargo-audit` to CI
16. **T-M4** — Refactor `factory_run.py` into modules
17. **T-H5 + T-M8** — Test coverage for slippage_stress + sensitivity_check
18. **E-H3** — OMS connection pooling
19. **S-H4** — LiveTrader WAL mode
20. **E-L2 + S-L1 + E-L4** — DRY refactoring (_env_bool, _generate_event_id, _interval_to_ms)

---

*Generated by automated codebase audit. All findings require manual verification before remediation.*
