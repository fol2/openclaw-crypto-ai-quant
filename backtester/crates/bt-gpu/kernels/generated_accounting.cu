// =============================================================================
// AUTO-GENERATED from decision_kernel.rs / accounting.rs -- DO NOT EDIT
// Generated by bt-gpu/build.rs codegen
// =============================================================================
//
// These device functions mirror the Rust accounting primitives in bt-core.
// They use double-precision accumulators to match AQC-734 f64 migration.
// The manual implementations in sweep_engine.cu should be validated against
// these reference functions to guarantee CPU/GPU parity.
//
// Source of truth:
//   bt-core/src/accounting.rs  -- quantize, apply_open_fill, apply_close_fill,
//                                  build_partial_close_plan, funding_delta
//   bt-core/src/decision_kernel.rs -- step() transition function
// =============================================================================

#pragma once

// Mirrors: accounting::quantize (accounting.rs:18-20)
// Precision scale: 1e12 (ACCOUNTING_QUANTUM)
__device__ double quantize_codegen(double value) {
    const double ACCOUNTING_QUANTUM = 1000000000000.0;
    return round(value * ACCOUNTING_QUANTUM) / ACCOUNTING_QUANTUM;
}

// Mirrors: accounting::apply_open_fill (accounting.rs:65-75)
// + sweep_engine.cu entry execution (lines ~1304-1308, ~1569-1572)
//
// On the GPU, entry accounting is simpler than close: no PnL, just fee deduction.
// The position struct is populated separately by the caller.
__device__ void apply_open_codegen(
    GpuComboState* state,
    double notional,
    double fee_rate
) {
    double notional_q = quantize_codegen(notional);
    double fee = quantize_codegen(notional_q * fee_rate);

    state->balance -= fee;
    state->total_fees += fee;
}

// Mirrors: accounting::apply_close_fill (accounting.rs:84-101)
// + sweep_engine.cu apply_close (lines 811-852)
//
// Full close: computes PnL, deducts fee, updates stats, records PESC, clears position.
__device__ void apply_close_codegen(
    GpuComboState* state,
    unsigned int sym,
    float fill_price,
    float fee_rate,
    bool reason_is_signal_flip
) {
    const GpuPosition& pos = state->positions[sym];
    if (pos.active == POS_EMPTY) { return; }

    // Mark-to-market PnL (double precision, mirrors accounting::mark_to_market_pnl)
    double pnl;
    if (pos.active == POS_LONG) {
        pnl = ((double)fill_price - (double)pos.entry_price) * (double)pos.size;
    } else {
        pnl = ((double)pos.entry_price - (double)fill_price) * (double)pos.size;
    }
    pnl = quantize_codegen(pnl);

    double notional = quantize_codegen((double)pos.size * (double)fill_price);
    double fee = quantize_codegen(notional * (double)fee_rate);
    double cash_delta = quantize_codegen(pnl - fee);

    // Update state accumulators
    state->balance += cash_delta;
    state->total_pnl += pnl;
    state->total_fees += fee;
    state->total_trades += 1u;
    if (pnl > 0.0) {
        state->total_wins += 1u;
        state->gross_profit += pnl;
    } else {
        state->gross_loss += fabs(pnl);
    }
    state->num_open -= 1u;

    // PESC tracking (mirrors decision_kernel.rs last_close_info update)
    state->pesc_close_time_sec[sym] = 0u; // caller must set from snapshot t_sec
    state->pesc_close_type[sym] = pos.active;
    state->pesc_close_reason[sym] = reason_is_signal_flip ? PESC_SIGNAL_FLIP : PESC_OTHER;

    // Clear position
    clear_position(&state->positions[sym]);
}

// Mirrors: accounting::build_partial_close_plan (accounting.rs:112-122)
// + accounting::apply_close_fill for the closed portion
// + sweep_engine.cu apply_partial_close (lines 854-890)
//
// Partial close: closes `pct` of position, updates remaining size/margin, marks tp1.
__device__ void apply_partial_close_codegen(
    GpuComboState* state,
    unsigned int sym,
    float fill_price,
    float pct,
    float fee_rate
) {
    const GpuPosition& pos = state->positions[sym];
    if (pos.active == POS_EMPTY) { return; }

    // Build partial close plan (mirrors accounting::build_partial_close_plan)
    // Clamp fraction to [0, 1]
    double fraction = (double)pct;
    if (fraction < 0.0) { fraction = 0.0; }
    if (fraction > 1.0) { fraction = 1.0; }

    double exit_size = quantize_codegen((double)pos.size * fraction);
    double remaining_size = quantize_codegen((double)pos.size - exit_size);
    double remaining_margin = quantize_codegen((double)pos.margin_used * (1.0 - fraction));

    // Apply close fill for the closed portion
    double pnl;
    if (pos.active == POS_LONG) {
        pnl = ((double)fill_price - (double)pos.entry_price) * exit_size;
    } else {
        pnl = ((double)pos.entry_price - (double)fill_price) * exit_size;
    }
    pnl = quantize_codegen(pnl);

    double notional = quantize_codegen(exit_size * (double)fill_price);
    double fee = quantize_codegen(notional * (double)fee_rate);
    double cash_delta = quantize_codegen(pnl - fee);

    // Update state accumulators
    state->balance += cash_delta;
    state->total_pnl += pnl;
    state->total_fees += fee;
    state->total_trades += 1u;
    if (pnl > 0.0) {
        state->total_wins += 1u;
        state->gross_profit += pnl;
    } else {
        state->gross_loss += fabs(pnl);
    }

    // Reduce position (mirrors accounting::build_partial_close_plan output)
    state->positions[sym].size = (float)remaining_size;
    state->positions[sym].margin_used = (float)remaining_margin;
    state->positions[sym].tp1_taken = 1u;
    // CPU semantics: trailing SL is NOT modified on partial close.
}

// Mirrors: accounting::funding_delta (accounting.rs:126-129)
//
// Hyperliquid-style funding: longs pay shorts when rate > 0.
// Returns the cash delta to add to balance.
__device__ double funding_delta_codegen(
    bool is_long,
    double size,
    double mark_price,
    double rate
) {
    double signed_size = is_long ? size : -size;
    return quantize_codegen(-signed_size * mark_price * rate);
}

// Mirrors: accounting::mark_to_market_pnl (accounting.rs:78-82)
//
// Directional PnL calculation with quantized output.
__device__ double mark_to_market_pnl_codegen(
    bool is_long,
    double entry_price,
    double exit_price,
    double size
) {
    double raw_pnl = (exit_price - entry_price) * size;
    double pnl = is_long ? raw_pnl : -raw_pnl;
    return quantize_codegen(pnl);
}

