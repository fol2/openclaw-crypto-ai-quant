// =============================================================================
// AUTO-GENERATED from bt-signals + bt-core kernel source -- DO NOT EDIT
// Generated by bt-gpu/build.rs decision codegen
// =============================================================================
//
// These device functions mirror the Rust decision logic in:
//   bt-signals/src/gates.rs      -- gate evaluation
//   bt-signals/src/entry.rs      -- signal generation
//   bt-core/src/exits/*.rs       -- stop loss, trailing, take profit, smart exits
//   bt-core/src/engine.rs        -- sizing, cooldowns
//
// Source of truth: Rust kernel code. GPU code is derived, not independent.
// =============================================================================

#pragma once

// SOURCE_HASHES: {"../bt-core/src/exits/mod.rs":"2dc6dcd56371a1bbf822bc5e69903fbb9b10a99f65134df3a81a04a1231af375","../bt-core/src/exits/smart_exits.rs":"ed3a3c40f00af3277b68191099a796988ae740d4aa11d9d9ba23b09810527c60","../bt-core/src/exits/stop_loss.rs":"39a2da91cd2b9ac8355f29b70ab4e333701a7e8ca6a145448381e9b1b0dc0d9c","../bt-core/src/exits/take_profit.rs":"794e8a9ab896ee91287e8c5cc250017bf9da5ffdd773ef8b1dbd8412cefc41ce","../bt-core/src/exits/trailing.rs":"501e5b5bc7fc7f9e8fea9572784aa14550cd5658b66428cded74c3eefdc3523e","../bt-signals/src/entry.rs":"7046e519e86605bc8f631c8ee3bcadfadeea119f616a1ad07f9b19f647072fbc","../bt-signals/src/gates.rs":"730aacfca4ec69a383157e2fdce134c5e5e16a40caf4ab36cf15a6ab0fa47acb"}

// Derived from bt-signals/src/gates.rs
// Gate evaluation: 8 gates + TMC/AVE + DRE + slow-drift override.
// All indicator/price math in double precision (AQC-734).
// All tunables read from cfg (no hardcoded gate thresholds).

struct GateResultD {
    bool all_gates_pass;
    bool is_ranging;
    bool is_anomaly;
    bool is_extended;
    bool vol_confirm;
    bool is_trending_up;
    bool adx_above_min;
    bool bullish_alignment;
    bool bearish_alignment;
    double effective_min_adx;
    double rsi_long_limit;
    double rsi_short_limit;
};

__device__ GateResultD check_gates_codegen(
    const GpuComboConfig& cfg,
    double rsi,
    double adx,
    double adx_slope,
    double bb_width_ratio,
    double ema_fast,
    double ema_slow,
    double ema_macro,
    double close,
    double prev_close,
    double volume,
    double vol_sma,
    unsigned int vol_trend,
    double atr,
    double avg_atr,
    double stoch_rsi_k,
    double ema_slow_slope_pct,
    unsigned int btc_bullish,      // 0=bearish, 1=bullish, 2=unknown/no-data
    unsigned int is_btc_symbol     // 1 if symbol is BTC
) {
    GateResultD result;
    result.all_gates_pass = false;
    result.is_ranging = false;
    result.is_anomaly = false;
    result.is_extended = false;
    result.vol_confirm = true;
    result.is_trending_up = true;
    result.adx_above_min = false;
    result.bullish_alignment = (ema_fast > ema_slow);
    result.bearish_alignment = (ema_fast < ema_slow);
    result.effective_min_adx = (double)cfg.min_adx;
    result.rsi_long_limit = 0.0;
    result.rsi_short_limit = 0.0;

    // ── Gate 1: Ranging filter (vote system) ─────────────────────────────
    // Python lines 3344-3363; Rust gates.rs Gate 1.
    // Three votes: ADX below threshold, BB width ratio below threshold,
    // RSI in neutral zone.  Ranging if votes >= min_signals.
    if (cfg.enable_ranging_filter != 0u) {
        unsigned int min_signals = cfg.ranging_min_signals;
        if (min_signals < 1u) { min_signals = 1u; }
        unsigned int votes = 0u;

        // Vote 1: ADX below ranging threshold
        if (adx < (double)cfg.ranging_adx_lt) { votes += 1u; }

        // Vote 2: BB width ratio below ranging threshold
        if (bb_width_ratio < (double)cfg.ranging_bb_width_ratio_lt) { votes += 1u; }

        // Vote 3: RSI in neutral zone
        if (rsi > (double)cfg.ranging_rsi_low && rsi < (double)cfg.ranging_rsi_high) { votes += 1u; }

        result.is_ranging = (votes >= min_signals);
    }

    // ── Gate 2: Anomaly filter ───────────────────────────────────────────
    // Python lines 3365-3371; Rust gates.rs Gate 2.
    // Blocks entry when price_change_pct > threshold OR ema_dev_pct > threshold.
    if (cfg.enable_anomaly_filter != 0u) {
        double price_change_pct = 0.0;
        if (prev_close > 0.0) {
            price_change_pct = fabs(close - prev_close) / prev_close;
        }
        double ema_dev_pct = 0.0;
        if (ema_fast > 0.0) {
            ema_dev_pct = fabs(close - ema_fast) / ema_fast;
        }
        result.is_anomaly = (price_change_pct > (double)cfg.anomaly_price_change_pct)
                         || (ema_dev_pct > (double)cfg.anomaly_ema_dev_pct);
    }

    // ── Gate 3: Extension filter (distance from EMA_fast) ────────────────
    // Python lines 3533-3537; Rust gates.rs Gate 3.
    if (cfg.enable_extension_filter != 0u) {
        if (ema_fast > 0.0) {
            double dist = fabs(close - ema_fast) / ema_fast;
            result.is_extended = (dist > (double)cfg.max_dist_ema_fast);
        }
    }

    // ── Gate 4: Volume confirmation ──────────────────────────────────────
    // Python lines 3432-3440; Rust gates.rs Gate 4.
    // When vol_confirm_include_prev: relaxed (vol > vol_sma OR vol_trend).
    // Otherwise strict: (vol > vol_sma) AND vol_trend.
    if (cfg.require_volume_confirmation != 0u) {
        bool vol_above_sma = (volume > vol_sma);
        bool vol_trend_ok = (vol_trend != 0u);
        if (cfg.vol_confirm_include_prev != 0u) {
            result.vol_confirm = vol_above_sma || vol_trend_ok;
        } else {
            result.vol_confirm = vol_above_sma && vol_trend_ok;
        }
    }

    // ── Gate 5: ADX rising (or saturated) ────────────────────────────────
    // Python lines 3426-3430; Rust gates.rs Gate 5.
    if (cfg.require_adx_rising != 0u) {
        double saturation = (double)cfg.adx_rising_saturation;
        result.is_trending_up = (adx_slope > 0.0) || (adx > saturation);
    }

    // ── Gate 6: ADX threshold (effective_min_adx with TMC + AVE) ─────────
    // Python lines 3383-3424; Rust gates.rs Gate 6.
    double effective_min_adx = (double)cfg.min_adx;

    // TMC: Trend Momentum Confirmation (v4.6)
    // If ADX slope > 0.5, cap effective_min_adx at 25.0.
    if (adx_slope > 0.5) {
        effective_min_adx = fmin(effective_min_adx, 25.0);
    }

    // AVE: Adaptive Volatility Entry (v4.7)
    // If ATR / avg_ATR > threshold, multiply effective_min_adx by ave_adx_mult.
    if (cfg.ave_enabled != 0u && avg_atr > 0.0) {
        double atr_ratio = atr / avg_atr;
        if (atr_ratio > (double)cfg.ave_atr_ratio_gt) {
            double mult = ((double)cfg.ave_adx_mult > 0.0)
                ? (double)cfg.ave_adx_mult
                : 1.0;
            effective_min_adx *= mult;
        }
    }

    result.adx_above_min = (adx > effective_min_adx);
    result.effective_min_adx = effective_min_adx;

    // ── Gate 7: Macro alignment (EMA cross + optional macro EMA) ─────────
    // Python lines 3448-3452; Rust gates.rs Gate 7.
    if (cfg.require_macro_alignment != 0u) {
        result.bullish_alignment = result.bullish_alignment && (ema_slow > ema_macro);
        result.bearish_alignment = result.bearish_alignment && (ema_slow < ema_macro);
    }

    // ── Gate 8: BTC alignment (optional) ─────────────────────────────────
    // Python lines 3454-3461; Rust gates.rs Gate 8.
    // btc_bullish: 0=bearish, 1=bullish, 2=unknown/no-data.
    // If is_btc_symbol or btc_bullish unknown or alignment matches, gate passes.
    // High ADX overrides BTC alignment requirement.
    // (btc_ok is not part of all_gates_pass; it is checked per-direction by the
    //  signal generator.  We store the results for the caller.)

    // ── Slow-drift ranging override ──────────────────────────────────────
    // Python lines 3524-3526; Rust gates.rs slow-drift override.
    // If slow drift enabled and EMA_slow slope exceeds threshold, clear ranging.
    if (cfg.enable_slow_drift_entries != 0u
        && result.is_ranging
        && fabs(ema_slow_slope_pct) >= (double)cfg.slow_drift_ranging_slope_override) {
        result.is_ranging = false;
    }

    // ── DRE (Dynamic RSI Elasticity) — v4.1 ─────────────────────────────
    // Python lines 3551-3560; Rust gates.rs DRE.
    // Linear interpolation of RSI limits between weak and strong based on ADX.
    {
        double adx_min_dre = (double)cfg.dre_min_adx;
        double adx_max_dre = (double)cfg.dre_max_adx;
        if (adx_max_dre <= adx_min_dre) {
            adx_max_dre = adx_min_dre + 1.0;
        }
        double weight = (adx - adx_min_dre) / (adx_max_dre - adx_min_dre);
        weight = fmax(fmin(weight, 1.0), 0.0);  // clamp [0, 1]

        double rsi_long_weak  = (double)cfg.dre_long_rsi_limit_low;
        double rsi_long_strong = (double)cfg.dre_long_rsi_limit_high;
        result.rsi_long_limit = rsi_long_weak + weight * (rsi_long_strong - rsi_long_weak);

        double rsi_short_weak  = (double)cfg.dre_short_rsi_limit_low;
        double rsi_short_strong = (double)cfg.dre_short_rsi_limit_high;
        result.rsi_short_limit = rsi_short_weak + weight * (rsi_short_strong - rsi_short_weak);
    }

    // ── Combined check: all gates required for standard trend entry ──────
    // Rust gates.rs: adx_above_min && !ranging && !anomaly && !extended
    //                && vol_confirm && is_trending_up
    result.all_gates_pass = result.adx_above_min
        && !result.is_ranging
        && !result.is_anomaly
        && !result.is_extended
        && result.vol_confirm
        && result.is_trending_up;

    return result;
}
// Derived from bt-signals/src/entry.rs
// Signal generation: Mode 1 (standard trend), Mode 2 (pullback continuation),
// Mode 3 (slow drift).  All indicator math in double precision (AQC-734).
// All config values accessed via cfg. prefix with (double) cast.

struct SignalResult {
    int signal;             // 0=neutral, 1=buy, 2=sell
    int confidence;         // 0=low, 1=medium, 2=high
    double effective_min_adx;  // ADX threshold used by the firing mode
};

// MACD histogram helpers (mirrors bt-signals/src/entry.rs check_macd_long/short)
__device__ bool check_macd_long_codegen(unsigned int mode, double macd_hist, double prev_macd_hist) {
    if (mode == 0u) {  // MACD_ACCEL
        return macd_hist > prev_macd_hist;
    } else if (mode == 1u) {  // MACD_SIGN
        return macd_hist > 0.0;
    }
    // MACD_NONE (mode == 2)
    return true;
}

__device__ bool check_macd_short_codegen(unsigned int mode, double macd_hist, double prev_macd_hist) {
    if (mode == 0u) {  // MACD_ACCEL
        return macd_hist < prev_macd_hist;
    } else if (mode == 1u) {  // MACD_SIGN
        return macd_hist < 0.0;
    }
    // MACD_NONE (mode == 2)
    return true;
}

__device__ SignalResult generate_signal_codegen(
    const GpuComboConfig& cfg,
    double close,
    double ema_fast,
    double ema_slow,
    double adx,
    double rsi,
    double macd_hist,
    double prev_macd_hist,
    double volume,
    double vol_sma,
    double atr,
    double avg_atr,
    double stoch_k,
    double prev_close,
    double prev_ema_fast,
    double ema_slow_slope_pct,
    bool all_gates_pass,
    bool bullish_alignment,
    bool bearish_alignment,
    bool is_anomaly,
    bool is_extended,
    bool is_ranging,
    bool vol_confirm,
    unsigned int btc_bull,
    bool is_btc_symbol
) {
    SignalResult neutral;
    neutral.signal = 0;       // SIG_NEUTRAL
    neutral.confidence = 0;   // CONF_LOW
    neutral.effective_min_adx = 0.0;

    // ── BTC alignment (mirrors bt-signals/src/gates.rs btc_ok_long/short) ──
    bool btc_ok_long = true;
    bool btc_ok_short = true;
    if (cfg.require_btc_alignment != 0u
        && !is_btc_symbol
        && !(adx > (double)cfg.btc_adx_override)) {
        if (btc_bull == 1u) {         // BTC_BULL_BULLISH
            btc_ok_long = true;
            btc_ok_short = false;
        } else if (btc_bull == 0u) {  // BTC_BULL_BEARISH
            btc_ok_long = false;
            btc_ok_short = true;
        } else {
            // Unknown BTC state does not block entries (CPU parity).
            btc_ok_long = true;
            btc_ok_short = true;
        }
    }

    // =================================================================
    // Mode 1: Standard trend entry  (entry.rs lines 43-49)
    // =================================================================
    if (all_gates_pass) {
        int signal = 0;    // SIG_NEUTRAL
        int confidence = 1; // CONF_MEDIUM

        // ── Direction from alignment + close vs EMA_fast ──
        if (bullish_alignment && close > ema_fast && btc_ok_long) {
            signal = 1;  // SIG_BUY
        } else if (bearish_alignment && close < ema_fast && btc_ok_short) {
            signal = 2;  // SIG_SELL
        }
        if (signal == 0) { return neutral; }

        // ── DRE (Dynamic RSI Elasticity) ──
        double adx_min = (double)cfg.dre_min_adx;
        double adx_max = (double)cfg.dre_max_adx;
        if (adx_max <= adx_min) { adx_max = adx_min + 1.0; }
        double weight = fmax(fmin((adx - adx_min) / (adx_max - adx_min), 1.0), 0.0);
        double rsi_long_limit = (double)cfg.dre_long_rsi_limit_low
            + weight * ((double)cfg.dre_long_rsi_limit_high - (double)cfg.dre_long_rsi_limit_low);
        double rsi_short_limit = (double)cfg.dre_short_rsi_limit_low
            + weight * ((double)cfg.dre_short_rsi_limit_high - (double)cfg.dre_short_rsi_limit_low);

        // ── RSI gate ──
        if (signal == 1 && rsi <= rsi_long_limit) { return neutral; }
        if (signal == 2 && rsi >= rsi_short_limit) { return neutral; }

        // ── MACD histogram gate ──
        bool macd_ok;
        if (signal == 1) {
            macd_ok = check_macd_long_codegen(cfg.macd_mode, macd_hist, prev_macd_hist);
        } else {
            macd_ok = check_macd_short_codegen(cfg.macd_mode, macd_hist, prev_macd_hist);
        }
        if (!macd_ok) { return neutral; }

        // ── StochRSI filter ──
        if (cfg.use_stoch_rsi_filter != 0u) {
            if (signal == 1 && stoch_k > (double)cfg.stoch_rsi_block_long_gt) { return neutral; }
            if (signal == 2 && stoch_k < (double)cfg.stoch_rsi_block_short_lt) { return neutral; }
        }

        // ── AVE (Adaptive Volatility Entry): upgrade confidence ──
        if (cfg.ave_enabled != 0u && avg_atr > 0.0) {
            double atr_ratio = atr / avg_atr;
            if (atr_ratio > (double)cfg.ave_atr_ratio_gt) {
                confidence = 2;  // CONF_HIGH
            }
        }

        // ── Volume-based confidence upgrade to High ──
        if (vol_sma > 0.0 && volume > vol_sma * (double)cfg.high_conf_volume_mult) {
            confidence = 2;  // CONF_HIGH
        }

        SignalResult result;
        result.signal = signal;
        result.confidence = confidence;
        result.effective_min_adx = adx;
        return result;
    }

    // =================================================================
    // Mode 2: Pullback continuation  (entry.rs lines 54-66)
    // =================================================================
    if (cfg.enable_pullback_entries != 0u) {
        bool pullback_gates_ok =
            !is_anomaly
            && !is_extended
            && !is_ranging
            && vol_confirm
            && adx >= (double)cfg.pullback_min_adx;

        if (pullback_gates_ok) {
            // Cross detection: EMA_fast cross-up / cross-down
            bool cross_up = (prev_close <= prev_ema_fast) && (close > ema_fast);
            bool cross_dn = (prev_close >= prev_ema_fast) && (close < ema_fast);

            int pullback_conf = (int)cfg.pullback_confidence;

            // ── Long pullback continuation ──
            if (cross_up && bullish_alignment && btc_ok_long) {
                bool macd_ok = (cfg.pullback_require_macd_sign == 0u) || (macd_hist > 0.0);
                if (macd_ok && rsi >= (double)cfg.pullback_rsi_long_min) {
                    SignalResult result;
                    result.signal = 1;  // SIG_BUY
                    result.confidence = pullback_conf;
                    result.effective_min_adx = (double)cfg.pullback_min_adx;
                    return result;
                }
            }
            // ── Short pullback continuation (elif in Python) ──
            else if (cross_dn && bearish_alignment && btc_ok_short) {
                bool macd_ok = (cfg.pullback_require_macd_sign == 0u) || (macd_hist < 0.0);
                if (macd_ok && rsi <= (double)cfg.pullback_rsi_short_max) {
                    SignalResult result;
                    result.signal = 2;  // SIG_SELL
                    result.confidence = pullback_conf;
                    result.effective_min_adx = (double)cfg.pullback_min_adx;
                    return result;
                }
            }
        }
    }

    // =================================================================
    // Mode 3: Slow drift  (entry.rs lines 71-85)
    // =================================================================
    if (cfg.enable_slow_drift_entries != 0u) {
        bool slow_gates_ok =
            !is_anomaly
            && !is_extended
            && !is_ranging
            && vol_confirm
            && adx >= (double)cfg.slow_drift_min_adx;

        if (slow_gates_ok) {
            double min_slope = (double)cfg.slow_drift_min_slope_pct;

            // ── Long drift: slope >= +threshold, price above EMA_slow ──
            if (bullish_alignment
                && close > ema_slow
                && btc_ok_long
                && ema_slow_slope_pct >= min_slope) {
                bool macd_ok = (cfg.slow_drift_require_macd_sign == 0u) || (macd_hist > 0.0);
                if (macd_ok && rsi >= (double)cfg.slow_drift_rsi_long_min) {
                    SignalResult result;
                    result.signal = 1;  // SIG_BUY
                    result.confidence = 0;  // CONF_LOW (always Low for slow drift)
                    result.effective_min_adx = (double)cfg.slow_drift_min_adx;
                    return result;
                }
            }
            // ── Short drift: slope <= -threshold, price below EMA_slow (elif) ──
            else if (bearish_alignment
                     && close < ema_slow
                     && btc_ok_short
                     && ema_slow_slope_pct <= -min_slope) {
                bool macd_ok = (cfg.slow_drift_require_macd_sign == 0u) || (macd_hist < 0.0);
                if (macd_ok && rsi <= (double)cfg.slow_drift_rsi_short_max) {
                    SignalResult result;
                    result.signal = 2;  // SIG_SELL
                    result.confidence = 0;  // CONF_LOW (always Low for slow drift)
                    result.effective_min_adx = (double)cfg.slow_drift_min_adx;
                    return result;
                }
            }
        }
    }

    return neutral;
}
// Derived from bt-core/src/exits/stop_loss.rs
// Computes the dynamic stop-loss price for a position each bar.
//
// Modifiers applied to sl_atr_mult:
//   1. ASE  — ADX slope < 0 AND underwater -> tighten 20% (x0.80)
//   2. FTB  — Disabled in backtester (no funding data)
//   3. DASE — ADX > 40 AND profitable > 0.5 ATR -> widen 15% (x1.15)
//   4. SLB  — ADX > 45 -> widen 10% (x1.10)
//   5. Breakeven — profit >= be_start -> move SL to entry +/- be_buffer
__device__ double compute_sl_price_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double atr,
    double current_price,
    double adx,
    double adx_slope
) {
    // ATR fallback: legacy positions with no ATR recorded
    double eff_atr = (atr > 0.0) ? atr : (entry_price * 0.005);

    double sl_mult = (double)cfg.sl_atr_mult;

    // ── 1. ASE (ADX Slope-Adjusted Stop) ─────────────────────────────────
    // If trend is weakening (ADX slope < 0) and position is underwater,
    // tighten the stop by 20%.
    bool is_underwater;
    if (pos_type == 1) {  // POS_LONG
        is_underwater = (current_price < entry_price);
    } else {              // POS_SHORT
        is_underwater = (current_price > entry_price);
    }
    if (adx_slope < 0.0 && is_underwater) {
        sl_mult *= 0.8;
    }

    // ── 2. FTB (Funding Tailwind Buffer) ─────────────────────────────────
    // Disabled in backtester — no funding rate data available.

    // ── 3. DASE (Dynamic ADX Stop Expansion) ─────────────────────────────
    // If ADX > 40 and position is profitable by > 0.5 ATR, widen by 15%.
    if (adx > 40.0) {
        double profit_in_atr;
        if (pos_type == 1) {  // POS_LONG
            profit_in_atr = (current_price - entry_price) / eff_atr;
        } else {              // POS_SHORT
            profit_in_atr = (entry_price - current_price) / eff_atr;
        }
        if (profit_in_atr > 0.5) {
            sl_mult *= 1.15;
        }
    }

    // ── 4. SLB (Saturation Loyalty Buffer) ───────────────────────────────
    // If ADX > 45 (saturated/strong trend), widen overall SL by 10%.
    if (adx > 45.0) {
        sl_mult *= 1.10;
    }

    // ── Compute raw SL price ─────────────────────────────────────────────
    double sl_price;
    if (pos_type == 1) {  // POS_LONG
        sl_price = entry_price - (eff_atr * sl_mult);
    } else {              // POS_SHORT
        sl_price = entry_price + (eff_atr * sl_mult);
    }

    // ── 5. Breakeven Stop ────────────────────────────────────────────────
    // If profit exceeds breakeven_start_atr ATRs, move SL to
    // entry +/- breakeven_buffer_atr ATRs (protecting at least entry).
    if (cfg.enable_breakeven_stop != 0u && cfg.breakeven_start_atr > 0.0f) {
        double be_start = eff_atr * (double)cfg.breakeven_start_atr;
        double be_buffer = eff_atr * (double)cfg.breakeven_buffer_atr;

        if (pos_type == 1) {  // POS_LONG
            if ((current_price - entry_price) >= be_start) {
                // Only raise SL, never lower it from the breakeven level.
                sl_price = fmax(sl_price, entry_price + be_buffer);
            }
        } else {              // POS_SHORT
            if ((entry_price - current_price) >= be_start) {
                // Only lower SL, never raise it from the breakeven level.
                sl_price = fmin(sl_price, entry_price - be_buffer);
            }
        }
    }

    return sl_price;
}
// Derived from bt-core/src/exits/trailing.rs
// Trailing stop: per-confidence offsets, VBTS, RSI Trend-Guard, TATP, TSPV,
//                weak-trend tightening, ratchet.
// All price math in double precision (AQC-734).
// All tunables read from cfg (no hardcoded trailing params).

__device__ double compute_trailing_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double current_price,
    double atr,
    double current_trailing_sl,
    int confidence,
    double rsi,
    double adx,
    double adx_slope,
    double atr_slope,
    double bb_width_ratio,
    double profit_atr
) {
    // ── ATR fallback (mirrors Rust: if entry_atr <= 0 use 0.5% of entry) ──
    double eff_atr = (atr > 0.0) ? atr : (entry_price * 0.005);

    // ── Per-confidence overrides for trailing start / distance ─────────────
    double trailing_start = (double)cfg.trailing_start_atr;
    double trailing_dist  = (double)cfg.trailing_distance_atr;

    if (confidence == 0) {  // Confidence::Low == 0
        if (cfg.trailing_start_atr_low_conf > 0.0f) {
            trailing_start = (double)cfg.trailing_start_atr_low_conf;
        }
        if (cfg.trailing_distance_atr_low_conf > 0.0f) {
            trailing_dist = (double)cfg.trailing_distance_atr_low_conf;
        }
    }

    // ── RSI Trend-Guard floor (v5.016) ────────────────────────────────────
    // Minimum effective trailing distance.  Raised when RSI is favourable
    // (trending in the direction of the position).
    double min_trailing_dist = (double)cfg.trailing_rsi_floor_default;
    if (pos_type == POS_LONG && rsi > 60.0) {
        min_trailing_dist = (double)cfg.trailing_rsi_floor_trending;
    }
    if (pos_type == POS_SHORT && rsi < 40.0) {
        min_trailing_dist = (double)cfg.trailing_rsi_floor_trending;
    }

    // ── Effective trailing distance ───────────────────────────────────────
    double effective_dist = trailing_dist;

    // VBTS (Vol-Buffered Trailing Stop, v5.015): widen when BB expanding.
    if (cfg.enable_vol_buffered_trailing != 0u
        && bb_width_ratio > (double)cfg.trailing_vbts_bb_threshold) {
        effective_dist *= (double)cfg.trailing_vbts_mult;
    }

    // High-profit tightening (> cfg threshold ATR) with TATP / TSPV overrides.
    if (profit_atr > (double)cfg.trailing_high_profit_atr) {
        if (adx > 35.0 && adx_slope > 0.0) {
            // TATP: trend accelerating — don't tighten (1.0x).
            effective_dist = trailing_dist * 1.0;
        } else if (atr_slope > 0.0) {
            // TSPV: volatility expanding — partial tighten.
            effective_dist = trailing_dist * (double)cfg.trailing_tighten_tspv;
        } else {
            // Default high-profit tightening.
            effective_dist = trailing_dist * (double)cfg.trailing_tighten_default;
        }
    } else if (adx < 25.0) {
        // Weak-trend tightening.
        effective_dist = trailing_dist * (double)cfg.trailing_weak_trend_mult;
    }

    // Clamp to RSI Trend-Guard floor.
    effective_dist = fmax(effective_dist, min_trailing_dist);

    // ── Activation gate ───────────────────────────────────────────────────
    if (profit_atr < trailing_start) {
        // Not enough profit to activate trailing stop yet.
        // Preserve any existing trailing SL from a previous bar.
        return current_trailing_sl;
    }

    // ── Compute candidate trailing stop price ─────────────────────────────
    double candidate;
    if (pos_type == POS_LONG) {
        candidate = current_price - (eff_atr * effective_dist);
    } else {
        candidate = current_price + (eff_atr * effective_dist);
    }

    // ── Ratchet: only allow the trailing stop to improve ──────────────────
    // A non-positive current_trailing_sl means "no trailing stop yet" (first bar).
    if (current_trailing_sl > 0.0) {
        if (pos_type == POS_LONG) {
            candidate = fmax(candidate, current_trailing_sl);
        } else {
            candidate = fmin(candidate, current_trailing_sl);
        }
    }

    return candidate;
}
// Derived from bt-core/src/exits/take_profit.rs
// Take profit: full TP + partial TP ladder.
// All price math in double precision (AQC-734).
//
// Partial TP ladder:
//   1. If enable_partial_tp AND tp1_taken == 0 AND price hits partial TP level
//      -> Reduce by tp_partial_pct, caller sets trailing_sl = entry (breakeven)
//   2. If tp1_taken == 1 AND tp_partial_atr_mult > 0 AND price hits full TP
//      -> Close remainder at full TP
//   3. If tp1_taken == 1 AND tp_partial_atr_mult == 0 -> Hold (trailing manages)
//   4. If partial TP disabled or tp_partial_pct >= 1.0 -> full Close
//
// Confidence-dependent TP multipliers (tp_mult_strong for high ADX,
// tp_mult_weak for low ADX) and dynamic gate TP multiplier are resolved
// by the caller via get_tp_mult() before calling this function.

struct TpResult {
    int action;       // 0 = hold, 1 = reduce (partial), 2 = close (full)
    double fraction;  // reduce fraction (meaningful only when action == 1)
    int exit_code;    // 0 = no exit, 10 = partial TP, 11 = full TP
};

__device__ TpResult check_tp_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double entry_atr,
    double current_price,
    double size,
    unsigned int tp1_taken,
    double tp_mult
) {
    TpResult result;
    result.action = 0;
    result.fraction = 0.0;
    result.exit_code = 0;

    // ── ATR fallback (mirrors Rust: if entry_atr <= 0 use 0.5% of entry) ──
    double atr = (entry_atr > 0.0) ? entry_atr : (entry_price * 0.005);

    // ── Full TP price (always based on tp_mult) ────────────────────────────
    double tp_price;
    if (pos_type == POS_LONG) {
        tp_price = entry_price + (atr * tp_mult);
    } else {
        tp_price = entry_price - (atr * tp_mult);
    }

    // ── Partial TP path ────────────────────────────────────────────────────
    if (cfg.enable_partial_tp != 0u) {
        if (tp1_taken == 0u) {
            // Determine partial TP level: use dedicated mult if set,
            // otherwise same as full TP.
            double partial_mult = (cfg.tp_partial_atr_mult > 0.0)
                ? (double)cfg.tp_partial_atr_mult
                : tp_mult;
            double partial_tp_price;
            if (pos_type == POS_LONG) {
                partial_tp_price = entry_price + (atr * partial_mult);
            } else {
                partial_tp_price = entry_price - (atr * partial_mult);
            }
            bool partial_hit;
            if (pos_type == POS_LONG) {
                partial_hit = (current_price >= partial_tp_price);
            } else {
                partial_hit = (current_price <= partial_tp_price);
            }

            if (partial_hit) {
                double pct = fmax(fmin((double)cfg.tp_partial_pct, 1.0), 0.0);

                if (pct > 0.0 && pct < 1.0) {
                    double remaining_notional = size * (1.0 - pct) * current_price;
                    if (remaining_notional < (double)cfg.tp_partial_min_notional_usd) {
                        // Remaining too small — hold instead of partial.
                        return result;  // action=0, hold
                    }

                    // Partial reduce.
                    result.action = 1;
                    result.fraction = pct;
                    result.exit_code = 10;  // partial TP
                    return result;
                }
                // pct == 0 or pct >= 1.0 falls through to full close check.
            } else {
                // Partial TP not hit yet.
                // When tp_partial_atr_mult == 0, partial == full,
                // so full can't be hit either.
                if (cfg.tp_partial_atr_mult <= 0.0f) {
                    return result;  // action=0, hold
                }
                // When tp_partial_atr_mult > 0, fall through to check full TP
                // (handles edge case where partial_mult > tp_mult).
            }
        } else {
            // tp1 already taken.
            if (cfg.tp_partial_atr_mult > 0.0f) {
                // Separate partial level: check if full TP hit for remainder.
                bool tp_hit;
                if (pos_type == POS_LONG) {
                    tp_hit = (current_price >= tp_price);
                } else {
                    tp_hit = (current_price <= tp_price);
                }
                if (tp_hit) {
                    result.action = 2;
                    result.fraction = 1.0;
                    result.exit_code = 11;  // full TP
                    return result;
                }
            }
            // Same level (tp_partial_atr_mult == 0) or full TP not hit:
            // trailing manages.
            return result;  // action=0, hold
        }
    }

    // ── Full TP check (partial TP disabled, or pct edge case) ──────────────
    bool tp_hit;
    if (pos_type == POS_LONG) {
        tp_hit = (current_price >= tp_price);
    } else {
        tp_hit = (current_price <= tp_price);
    }

    if (!tp_hit) {
        return result;  // action=0, hold
    }

    result.action = 2;
    result.fraction = 1.0;
    result.exit_code = 11;  // full TP
    return result;
}
// Derived from bt-core/src/engine.rs sizing logic
// (SSOT: risk-core/src/lib.rs::compute_entry_sizing)
//
// Dynamic entry sizing: allocation % * confidence mult * ADX mult * vol scalar.
// Dynamic leverage selects per-confidence leverage with optional max cap.
// All monetary/size arithmetic in double precision (AQC-734).

struct SizingResultD {
    double size;
    double margin;
    double leverage;
};

__device__ SizingResultD compute_entry_size_codegen(
    double equity,
    double price,
    unsigned int confidence,
    double atr,
    double adx,
    const GpuComboConfig& cfg
) {
    // ── Base margin allocation ───────────────────────────────────────────
    double margin = equity * (double)cfg.allocation_pct;

    // ── Dynamic sizing (confidence * ADX * volatility) ──────────────────
    if (cfg.enable_dynamic_sizing != 0u) {
        // Confidence multiplier
        double conf_mult = (double)cfg.confidence_mult_medium;
        if (confidence == CONF_HIGH) { conf_mult = (double)cfg.confidence_mult_high; }
        if (confidence == CONF_LOW)  { conf_mult = (double)cfg.confidence_mult_low; }

        // ADX multiplier — linearly scales [min_mult, 1.0] over [0, full_adx]
        double adx_ratio = adx / (double)cfg.adx_sizing_full_adx;
        double adx_mult = fmax(fmin(adx_ratio, 1.0), (double)cfg.adx_sizing_min_mult);

        // Volatility scalar — inverse of vol_ratio, clamped to [min, max]
        double vol_scalar = 1.0;
        if ((double)cfg.vol_baseline_pct > 0.0 && price > 0.0) {
            double vol_ratio = (atr / price) / (double)cfg.vol_baseline_pct;
            if (vol_ratio > 0.0) {
                vol_scalar = fmax(fmin(1.0 / vol_ratio, (double)cfg.vol_scalar_max),
                                  (double)cfg.vol_scalar_min);
            }
        }

        margin *= conf_mult * adx_mult * vol_scalar;
    }

    // ── Leverage ─────────────────────────────────────────────────────────
    double lev = (double)cfg.leverage;
    if (cfg.enable_dynamic_leverage != 0u) {
        if (confidence == CONF_HIGH)        { lev = (double)cfg.leverage_high; }
        else if (confidence == CONF_MEDIUM) { lev = (double)cfg.leverage_medium; }
        else                                { lev = (double)cfg.leverage_low; }
        if ((double)cfg.leverage_max_cap > 0.0) { lev = fmin(lev, (double)cfg.leverage_max_cap); }
    }

    // ── Notional & position size ─────────────────────────────────────────
    double notional = margin * lev;
    double size = 0.0;
    if (price > 0.0) { size = notional / price; }

    SizingResultD result;
    result.size = size;
    result.margin = margin;
    result.leverage = lev;
    return result;
}
// Derived from bt-core/src/engine.rs PESC cooldown logic
// Post-Exit Same-Direction Cooldown: prevents re-entry in the same direction
// too soon after an exit, with ADX-adaptive interpolation of cooldown duration.
//
// Gate chain:
//   1. reentry_cooldown_minutes == 0 -> disabled
//   2. No prior close recorded      -> not blocked
//   3. Signal flip exit reason       -> not blocked (direction changed)
//   4. Different direction           -> not blocked
//   5. ADX-interpolated cooldown     -> blocked if elapsed < cooldown

__device__ bool is_pesc_blocked_codegen(
    const GpuComboConfig& cfg,
    int bars_since_exit,
    double adx,
    unsigned int close_ts,
    unsigned int close_reason,
    unsigned int close_type,
    unsigned int desired_type,
    unsigned int current_sec
) {
    // Gate 1: PESC disabled when reentry_cooldown_minutes == 0
    if (cfg.reentry_cooldown_minutes == 0u) { return false; }

    // Gate 2: no prior close recorded for this symbol
    if (close_ts == 0u) { return false; }

    // Gate 3: no cooldown after signal flips (PESC_SIGNAL_FLIP == 2)
    if (close_reason == 2u) { return false; }

    // Gate 4: only block same-direction re-entry
    if (close_type != desired_type) { return false; }

    // ADX-adaptive cooldown interpolation
    double min_cd = (double)(cfg.reentry_cooldown_min_mins);
    double max_cd = (double)(cfg.reentry_cooldown_max_mins);

    double cooldown_mins;
    if (adx >= 40.0) {
        // Strong trend: use minimum cooldown
        cooldown_mins = min_cd;
    } else if (adx <= 25.0) {
        // Weak trend: use maximum cooldown
        cooldown_mins = max_cd;
    } else {
        // Linear interpolation: ADX 25->40 maps max_cd->min_cd
        double t = (adx - 25.0) / 15.0;
        cooldown_mins = max_cd + t * (min_cd - max_cd);
    }

    unsigned int cooldown_sec = (unsigned int)(cooldown_mins * 60.0);
    unsigned int elapsed = current_sec - close_ts;
    return elapsed < cooldown_sec;
}
