//! CUDA code templates for decision logic functions.
//!
//! Each template mirrors the corresponding Rust function in bt-signals and bt-core.
//! Decision logic covers: gates, signals, exits (SL/TSL/TP/smart), sizing, and cooldowns.
//!
//! Templates are stubs (returning empty strings) until their respective tickets implement them:
//! - AQC-1210: check_gates_codegen()
//! - AQC-1211: generate_signal_codegen()
//! - AQC-1220: compute_sl_price_codegen()
//! - AQC-1221: compute_trailing_codegen()
//! - AQC-1222: check_tp_codegen()
//! - AQC-1223: check_smart_exits_codegen()
//! - AQC-1224: check_all_exits_codegen()
//! - AQC-1230: compute_entry_size_codegen()
//! - AQC-1231: is_pesc_blocked_codegen()

/// File header for the generated decision CUDA source.
pub const DECISION_HEADER: &str = "\
// =============================================================================
// AUTO-GENERATED from bt-signals + bt-core kernel source -- DO NOT EDIT
// Generated by bt-gpu/build.rs decision codegen
// =============================================================================
//
// These device functions mirror the Rust decision logic in:
//   bt-signals/src/gates.rs      -- gate evaluation
//   bt-signals/src/entry.rs      -- signal generation
//   bt-core/src/exits/*.rs       -- stop loss, trailing, take profit, smart exits
//   bt-core/src/engine.rs        -- sizing, cooldowns
//
// Source of truth: Rust kernel code. GPU code is derived, not independent.
// =============================================================================

#pragma once
";

// The SOURCE_HASHES line will be injected by the drift detector (AQC-1200)

/// Gates: 8 gates + TMC/AVE + DRE (AQC-1210)
pub fn check_gates_codegen() -> String { String::new() /* stub */ }

/// Signals: Mode 1/2/3 + MACD helpers (AQC-1211)
pub fn generate_signal_codegen() -> String { String::new() /* stub */ }

/// Stop loss: ASE/DASE/SLB/breakeven (AQC-1220)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/exits/stop_loss.rs::compute_sl_price`.
///
/// Uses `double` precision for all price arithmetic to match the f64 Rust
/// source and satisfy T2 precision requirements (single arithmetic:
/// price +/- atr * mult).
pub fn compute_sl_price_codegen() -> String {
    r#"// Derived from bt-core/src/exits/stop_loss.rs
// Computes the dynamic stop-loss price for a position each bar.
//
// Modifiers applied to sl_atr_mult:
//   1. ASE  — ADX slope < 0 AND underwater -> tighten 20% (x0.80)
//   2. FTB  — Disabled in backtester (no funding data)
//   3. DASE — ADX > 40 AND profitable > 0.5 ATR -> widen 15% (x1.15)
//   4. SLB  — ADX > 45 -> widen 10% (x1.10)
//   5. Breakeven — profit >= be_start -> move SL to entry +/- be_buffer
__device__ double compute_sl_price_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double atr,
    double current_price,
    double adx,
    double adx_slope
) {
    // ATR fallback: legacy positions with no ATR recorded
    double eff_atr = (atr > 0.0) ? atr : (entry_price * 0.005);

    double sl_mult = (double)cfg.sl_atr_mult;

    // ── 1. ASE (ADX Slope-Adjusted Stop) ─────────────────────────────────
    // If trend is weakening (ADX slope < 0) and position is underwater,
    // tighten the stop by 20%.
    bool is_underwater;
    if (pos_type == 1) {  // POS_LONG
        is_underwater = (current_price < entry_price);
    } else {              // POS_SHORT
        is_underwater = (current_price > entry_price);
    }
    if (adx_slope < 0.0 && is_underwater) {
        sl_mult *= 0.8;
    }

    // ── 2. FTB (Funding Tailwind Buffer) ─────────────────────────────────
    // Disabled in backtester — no funding rate data available.

    // ── 3. DASE (Dynamic ADX Stop Expansion) ─────────────────────────────
    // If ADX > 40 and position is profitable by > 0.5 ATR, widen by 15%.
    if (adx > 40.0) {
        double profit_in_atr;
        if (pos_type == 1) {  // POS_LONG
            profit_in_atr = (current_price - entry_price) / eff_atr;
        } else {              // POS_SHORT
            profit_in_atr = (entry_price - current_price) / eff_atr;
        }
        if (profit_in_atr > 0.5) {
            sl_mult *= 1.15;
        }
    }

    // ── 4. SLB (Saturation Loyalty Buffer) ───────────────────────────────
    // If ADX > 45 (saturated/strong trend), widen overall SL by 10%.
    if (adx > 45.0) {
        sl_mult *= 1.10;
    }

    // ── Compute raw SL price ─────────────────────────────────────────────
    double sl_price;
    if (pos_type == 1) {  // POS_LONG
        sl_price = entry_price - (eff_atr * sl_mult);
    } else {              // POS_SHORT
        sl_price = entry_price + (eff_atr * sl_mult);
    }

    // ── 5. Breakeven Stop ────────────────────────────────────────────────
    // If profit exceeds breakeven_start_atr ATRs, move SL to
    // entry +/- breakeven_buffer_atr ATRs (protecting at least entry).
    if (cfg.enable_breakeven_stop != 0u && cfg.breakeven_start_atr > 0.0f) {
        double be_start = eff_atr * (double)cfg.breakeven_start_atr;
        double be_buffer = eff_atr * (double)cfg.breakeven_buffer_atr;

        if (pos_type == 1) {  // POS_LONG
            if ((current_price - entry_price) >= be_start) {
                // Only raise SL, never lower it from the breakeven level.
                sl_price = fmax(sl_price, entry_price + be_buffer);
            }
        } else {              // POS_SHORT
            if ((entry_price - current_price) >= be_start) {
                // Only lower SL, never raise it from the breakeven level.
                sl_price = fmin(sl_price, entry_price - be_buffer);
            }
        }
    }

    return sl_price;
}
"#
    .to_string()
}

/// Trailing stop: VBTS/TATP/TSPV/ratchet (AQC-1221)
///
/// Translates `bt-core/src/exits/trailing.rs::compute_trailing()` into a CUDA
/// `__device__` function.  All price arithmetic uses `double` to match AQC-734
/// f64 migration.  Every tunable constant is read from `cfg.` — no hardcoded
/// magic numbers remain except the TATP multiplier (1.0, i.e. "don't tighten").
pub fn compute_trailing_codegen() -> String {
    r#"// Derived from bt-core/src/exits/trailing.rs
// Trailing stop: per-confidence offsets, VBTS, RSI Trend-Guard, TATP, TSPV,
//                weak-trend tightening, ratchet.
// All price math in double precision (AQC-734).
// All tunables read from cfg (no hardcoded trailing params).

__device__ double compute_trailing_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double current_price,
    double atr,
    double current_trailing_sl,
    int confidence,
    double rsi,
    double adx,
    double adx_slope,
    double atr_slope,
    double bb_width_ratio,
    double profit_atr
) {
    // ── ATR fallback (mirrors Rust: if entry_atr <= 0 use 0.5% of entry) ──
    double eff_atr = (atr > 0.0) ? atr : (entry_price * 0.005);

    // ── Per-confidence overrides for trailing start / distance ─────────────
    double trailing_start = (double)cfg.trailing_start_atr;
    double trailing_dist  = (double)cfg.trailing_distance_atr;

    if (confidence == 0) {  // Confidence::Low == 0
        if (cfg.trailing_start_atr_low_conf > 0.0f) {
            trailing_start = (double)cfg.trailing_start_atr_low_conf;
        }
        if (cfg.trailing_distance_atr_low_conf > 0.0f) {
            trailing_dist = (double)cfg.trailing_distance_atr_low_conf;
        }
    }

    // ── RSI Trend-Guard floor (v5.016) ────────────────────────────────────
    // Minimum effective trailing distance.  Raised when RSI is favourable
    // (trending in the direction of the position).
    double min_trailing_dist = (double)cfg.trailing_rsi_floor_default;
    if (pos_type == POS_LONG && rsi > 60.0) {
        min_trailing_dist = (double)cfg.trailing_rsi_floor_trending;
    }
    if (pos_type == POS_SHORT && rsi < 40.0) {
        min_trailing_dist = (double)cfg.trailing_rsi_floor_trending;
    }

    // ── Effective trailing distance ───────────────────────────────────────
    double effective_dist = trailing_dist;

    // VBTS (Vol-Buffered Trailing Stop, v5.015): widen when BB expanding.
    if (cfg.enable_vol_buffered_trailing != 0u
        && bb_width_ratio > (double)cfg.trailing_vbts_bb_threshold) {
        effective_dist *= (double)cfg.trailing_vbts_mult;
    }

    // High-profit tightening (> cfg threshold ATR) with TATP / TSPV overrides.
    if (profit_atr > (double)cfg.trailing_high_profit_atr) {
        if (adx > 35.0 && adx_slope > 0.0) {
            // TATP: trend accelerating — don't tighten (1.0x).
            effective_dist = trailing_dist * 1.0;
        } else if (atr_slope > 0.0) {
            // TSPV: volatility expanding — partial tighten.
            effective_dist = trailing_dist * (double)cfg.trailing_tighten_tspv;
        } else {
            // Default high-profit tightening.
            effective_dist = trailing_dist * (double)cfg.trailing_tighten_default;
        }
    } else if (adx < 25.0) {
        // Weak-trend tightening.
        effective_dist = trailing_dist * (double)cfg.trailing_weak_trend_mult;
    }

    // Clamp to RSI Trend-Guard floor.
    effective_dist = fmax(effective_dist, min_trailing_dist);

    // ── Activation gate ───────────────────────────────────────────────────
    if (profit_atr < trailing_start) {
        // Not enough profit to activate trailing stop yet.
        // Preserve any existing trailing SL from a previous bar.
        return current_trailing_sl;
    }

    // ── Compute candidate trailing stop price ─────────────────────────────
    double candidate;
    if (pos_type == POS_LONG) {
        candidate = current_price - (eff_atr * effective_dist);
    } else {
        candidate = current_price + (eff_atr * effective_dist);
    }

    // ── Ratchet: only allow the trailing stop to improve ──────────────────
    // A non-positive current_trailing_sl means "no trailing stop yet" (first bar).
    if (current_trailing_sl > 0.0) {
        if (pos_type == POS_LONG) {
            candidate = fmax(candidate, current_trailing_sl);
        } else {
            candidate = fmin(candidate, current_trailing_sl);
        }
    }

    return candidate;
}
"#
    .to_string()
}

/// Take profit: partial TP + full TP ladder (AQC-1222)
pub fn check_tp_codegen() -> String { String::new() /* stub */ }

/// Smart exits: all 8 sub-checks (AQC-1223)
pub fn check_smart_exits_codegen() -> String { String::new() /* stub */ }

/// Exit orchestrator: priority dispatch (AQC-1224)
pub fn check_all_exits_codegen() -> String { String::new() /* stub */ }

/// Entry sizing: dynamic sizing/leverage/vol scalar (AQC-1230)
pub fn compute_entry_size_codegen() -> String { String::new() /* stub */ }

/// PESC cooldown: reentry cooldown + ADX interpolation (AQC-1231)
pub fn is_pesc_blocked_codegen() -> String { String::new() /* stub */ }

// ═══════════════════════════════════════════════════════════════════════════
// Tests
// ═══════════════════════════════════════════════════════════════════════════

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sl_codegen_has_correct_function_signature() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("__device__ double compute_sl_price_codegen("),
            "must declare a __device__ double function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(
            src.contains("int pos_type"),
            "must take pos_type as int"
        );
        assert!(
            src.contains("double entry_price"),
            "must take entry_price as double"
        );
        assert!(
            src.contains("double atr"),
            "must take atr as double"
        );
        assert!(
            src.contains("double current_price"),
            "must take current_price as double"
        );
        assert!(
            src.contains("double adx"),
            "must take adx as double"
        );
        assert!(
            src.contains("double adx_slope"),
            "must take adx_slope as double"
        );
    }

    #[test]
    fn sl_codegen_uses_double_precision() {
        let src = compute_sl_price_codegen();
        // Return type is double
        assert!(src.contains("__device__ double"));
        // Internal arithmetic uses double variables
        assert!(src.contains("double sl_mult"));
        assert!(src.contains("double sl_price"));
        assert!(src.contains("double eff_atr"));
        assert!(src.contains("double be_start"));
        assert!(src.contains("double be_buffer"));
        // Must NOT use float for price-critical variables
        assert!(
            !src.contains("float sl_price"),
            "sl_price must be double, not float"
        );
        assert!(
            !src.contains("float sl_mult"),
            "sl_mult must be double, not float"
        );
    }

    #[test]
    fn sl_codegen_contains_ase_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("ASE"), "must have ASE comment marker");
        assert!(
            src.contains("adx_slope < 0.0"),
            "ASE checks for negative ADX slope"
        );
        assert!(
            src.contains("is_underwater"),
            "ASE checks underwater condition"
        );
        assert!(src.contains("*= 0.8"), "ASE tightens by 20% (x0.80)");
    }

    #[test]
    fn sl_codegen_contains_dase_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("DASE"), "must have DASE comment marker");
        assert!(
            src.contains("adx > 40.0"),
            "DASE triggers when ADX > 40"
        );
        assert!(
            src.contains("profit_in_atr"),
            "DASE computes profit in ATR units"
        );
        assert!(
            src.contains("profit_in_atr > 0.5"),
            "DASE requires > 0.5 ATR profit"
        );
        assert!(src.contains("*= 1.15"), "DASE widens by 15% (x1.15)");
    }

    #[test]
    fn sl_codegen_contains_slb_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("SLB"), "must have SLB comment marker");
        assert!(
            src.contains("adx > 45.0"),
            "SLB triggers when ADX > 45"
        );
        assert!(src.contains("*= 1.10"), "SLB widens by 10% (x1.10)");
    }

    #[test]
    fn sl_codegen_contains_breakeven_logic() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("Breakeven"),
            "must have Breakeven comment marker"
        );
        assert!(
            src.contains("cfg.enable_breakeven_stop"),
            "breakeven checks enable flag from config"
        );
        assert!(
            src.contains("cfg.breakeven_start_atr"),
            "breakeven uses start ATR threshold from config"
        );
        assert!(
            src.contains("cfg.breakeven_buffer_atr"),
            "breakeven uses buffer ATR from config"
        );
        assert!(
            src.contains("fmax(sl_price, entry_price + be_buffer)"),
            "long breakeven raises SL via fmax"
        );
        assert!(
            src.contains("fmin(sl_price, entry_price - be_buffer)"),
            "short breakeven lowers SL via fmin"
        );
    }

    #[test]
    fn sl_codegen_uses_correct_config_fields() {
        let src = compute_sl_price_codegen();
        // All config field accesses must use GpuComboConfig field names
        assert!(src.contains("cfg.sl_atr_mult"), "must use cfg.sl_atr_mult");
        assert!(
            src.contains("cfg.enable_breakeven_stop"),
            "must use cfg.enable_breakeven_stop"
        );
        assert!(
            src.contains("cfg.breakeven_start_atr"),
            "must use cfg.breakeven_start_atr"
        );
        assert!(
            src.contains("cfg.breakeven_buffer_atr"),
            "must use cfg.breakeven_buffer_atr"
        );
    }

    #[test]
    fn sl_codegen_uses_fmax_fmin_not_std_max() {
        let src = compute_sl_price_codegen();
        // Must use CUDA fmax/fmin, not std::max/std::min
        assert!(src.contains("fmax("), "must use fmax for CUDA");
        assert!(src.contains("fmin("), "must use fmin for CUDA");
        assert!(
            !src.contains("std::max"),
            "must not use std::max (use fmax for CUDA)"
        );
        assert!(
            !src.contains("std::min"),
            "must not use std::min (use fmin for CUDA)"
        );
    }

    #[test]
    fn sl_codegen_has_long_short_direction() {
        let src = compute_sl_price_codegen();
        // Long: SL below entry (entry - atr * mult)
        assert!(
            src.contains("entry_price - (eff_atr * sl_mult)"),
            "long SL = entry - atr * mult"
        );
        // Short: SL above entry (entry + atr * mult)
        assert!(
            src.contains("entry_price + (eff_atr * sl_mult)"),
            "short SL = entry + atr * mult"
        );
    }

    #[test]
    fn sl_codegen_has_atr_fallback() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("entry_price * 0.005"),
            "must have ATR fallback for legacy positions"
        );
    }

    #[test]
    fn sl_codegen_has_source_comment() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/stop_loss.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn sl_codegen_pos_type_uses_integer_constants() {
        let src = compute_sl_price_codegen();
        // Must use integer comparison, not enum
        assert!(
            src.contains("pos_type == 1"),
            "long check must use pos_type == 1 (POS_LONG)"
        );
    }

    // -- compute_trailing_codegen tests (AQC-1221) ----------------------------

    #[test]
    fn trailing_codegen_contains_function_signature() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("__device__ double compute_trailing_codegen("),
            "must emit __device__ double function signature"
        );
    }

    #[test]
    fn trailing_codegen_contains_source_comment() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/trailing.rs"),
            "must have provenance comment"
        );
    }

    #[test]
    fn trailing_codegen_uses_double_precision() {
        let src = compute_trailing_codegen();
        assert!(src.contains("double trailing_start"), "trailing_start must be double");
        assert!(src.contains("double trailing_dist"), "trailing_dist must be double");
        assert!(src.contains("double effective_dist"), "effective_dist must be double");
        assert!(src.contains("double candidate"), "candidate must be double");
        assert!(src.contains("double eff_atr"), "eff_atr must be double");
        assert!(src.contains("double min_trailing_dist"), "min_trailing_dist must be double");
    }

    #[test]
    fn trailing_codegen_reads_config_not_hardcoded() {
        let src = compute_trailing_codegen();
        assert!(src.contains("cfg.trailing_start_atr"), "trailing_start from config");
        assert!(src.contains("cfg.trailing_distance_atr"), "trailing_distance from config");
        assert!(src.contains("cfg.trailing_start_atr_low_conf"), "low_conf start from config");
        assert!(src.contains("cfg.trailing_distance_atr_low_conf"), "low_conf dist from config");
        assert!(src.contains("cfg.trailing_rsi_floor_default"), "RSI floor default from config");
        assert!(src.contains("cfg.trailing_rsi_floor_trending"), "RSI floor trending from config");
        assert!(src.contains("cfg.enable_vol_buffered_trailing"), "VBTS enable from config");
        assert!(src.contains("cfg.trailing_vbts_bb_threshold"), "VBTS BB threshold from config");
        assert!(src.contains("cfg.trailing_vbts_mult"), "VBTS mult from config");
        assert!(src.contains("cfg.trailing_high_profit_atr"), "high profit threshold from config");
        assert!(src.contains("cfg.trailing_tighten_tspv"), "TSPV tighten from config");
        assert!(src.contains("cfg.trailing_tighten_default"), "default tighten from config");
        assert!(src.contains("cfg.trailing_weak_trend_mult"), "weak trend mult from config");
    }

    #[test]
    fn trailing_codegen_contains_vbts_logic() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("VBTS") || src.contains("Vol-Buffered"),
            "must contain VBTS reference"
        );
        assert!(src.contains("bb_width_ratio"), "VBTS must check bb_width_ratio");
    }

    #[test]
    fn trailing_codegen_contains_ratchet_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("Ratchet") || src.contains("ratchet"), "must contain ratchet");
        assert!(src.contains("fmax(candidate"), "LONG ratchet uses fmax");
        assert!(src.contains("fmin(candidate"), "SHORT ratchet uses fmin");
    }

    #[test]
    fn trailing_codegen_contains_rsi_trend_guard() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("RSI Trend-Guard") || src.contains("rsi_floor"),
            "must reference RSI Trend-Guard"
        );
        assert!(src.contains("rsi > 60.0"), "LONG RSI favourability check");
        assert!(src.contains("rsi < 40.0"), "SHORT RSI favourability check");
    }

    #[test]
    fn trailing_codegen_contains_tatp_tspv_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("TATP"), "must reference TATP");
        assert!(src.contains("TSPV"), "must reference TSPV");
        assert!(src.contains("adx_slope"), "TATP checks adx_slope");
        assert!(src.contains("atr_slope"), "TSPV checks atr_slope");
    }

    #[test]
    fn trailing_codegen_contains_weak_trend_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("adx < 25.0"), "weak-trend check on adx < 25");
        assert!(src.contains("trailing_weak_trend_mult"), "weak-trend uses config mult");
    }

    #[test]
    fn trailing_codegen_contains_activation_gate() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("profit_atr < trailing_start"),
            "activation gate: profit must exceed trailing_start"
        );
        assert!(
            src.contains("return current_trailing_sl"),
            "when not active, preserve existing trailing SL"
        );
    }

    #[test]
    fn trailing_codegen_handles_low_confidence() {
        let src = compute_trailing_codegen();
        assert!(src.contains("confidence == 0"), "Low confidence mapped to 0");
    }

    #[test]
    fn trailing_codegen_handles_no_existing_trailing_sl() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("current_trailing_sl > 0.0"),
            "must check for no existing trailing SL (first computation)"
        );
    }

    #[test]
    fn trailing_codegen_uses_fmax_fmin() {
        let src = compute_trailing_codegen();
        assert!(src.contains("fmax("), "must use fmax for CUDA double math");
        assert!(src.contains("fmin("), "must use fmin for CUDA double math");
    }

    #[test]
    fn trailing_codegen_is_nonempty() {
        let src = compute_trailing_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }
}
