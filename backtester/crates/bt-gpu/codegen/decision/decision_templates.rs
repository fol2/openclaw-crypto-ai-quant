//! CUDA code templates for decision logic functions.
//!
//! Each template mirrors the corresponding Rust function in bt-signals and bt-core.
//! Decision logic covers: gates, signals, exits (SL/TSL/TP/smart), sizing, and cooldowns.
//!
//! Templates are stubs (returning empty strings) until their respective tickets implement them:
//! - AQC-1210: check_gates_codegen()
//! - AQC-1211: generate_signal_codegen()
//! - AQC-1220: compute_sl_price_codegen()
//! - AQC-1221: compute_trailing_codegen()
//! - AQC-1222: check_tp_codegen()
//! - AQC-1223: check_smart_exits_codegen()
//! - AQC-1224: check_all_exits_codegen()
//! - AQC-1230: compute_entry_size_codegen()
//! - AQC-1231: is_pesc_blocked_codegen()

/// File header for the generated decision CUDA source.
pub const DECISION_HEADER: &str = "\
// =============================================================================
// AUTO-GENERATED from bt-signals + bt-core kernel source -- DO NOT EDIT
// Generated by bt-gpu/build.rs decision codegen
// =============================================================================
//
// These device functions mirror the Rust decision logic in:
//   bt-signals/src/gates.rs      -- gate evaluation
//   bt-signals/src/entry.rs      -- signal generation
//   bt-core/src/exits/*.rs       -- stop loss, trailing, take profit, smart exits
//   bt-core/src/engine.rs        -- sizing, cooldowns
//
// Source of truth: Rust kernel code. GPU code is derived, not independent.
// =============================================================================

#pragma once
";

// The SOURCE_HASHES line will be injected by the drift detector (AQC-1200)

/// Gates: 8 gates + TMC/AVE + DRE (AQC-1210)
pub fn check_gates_codegen() -> String { String::new() /* stub */ }

/// Signals: Mode 1/2/3 + MACD helpers (AQC-1211)
pub fn generate_signal_codegen() -> String { String::new() /* stub */ }

/// Stop loss: ASE/DASE/SLB/breakeven (AQC-1220)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/exits/stop_loss.rs::compute_sl_price`.
///
/// Uses `double` precision for all price arithmetic to match the f64 Rust
/// source and satisfy T2 precision requirements (single arithmetic:
/// price +/- atr * mult).
pub fn compute_sl_price_codegen() -> String {
    r#"// Derived from bt-core/src/exits/stop_loss.rs
// Computes the dynamic stop-loss price for a position each bar.
//
// Modifiers applied to sl_atr_mult:
//   1. ASE  — ADX slope < 0 AND underwater -> tighten 20% (x0.80)
//   2. FTB  — Disabled in backtester (no funding data)
//   3. DASE — ADX > 40 AND profitable > 0.5 ATR -> widen 15% (x1.15)
//   4. SLB  — ADX > 45 -> widen 10% (x1.10)
//   5. Breakeven — profit >= be_start -> move SL to entry +/- be_buffer
__device__ double compute_sl_price_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double atr,
    double current_price,
    double adx,
    double adx_slope
) {
    // ATR fallback: legacy positions with no ATR recorded
    double eff_atr = (atr > 0.0) ? atr : (entry_price * 0.005);

    double sl_mult = (double)cfg.sl_atr_mult;

    // ── 1. ASE (ADX Slope-Adjusted Stop) ─────────────────────────────────
    // If trend is weakening (ADX slope < 0) and position is underwater,
    // tighten the stop by 20%.
    bool is_underwater;
    if (pos_type == 1) {  // POS_LONG
        is_underwater = (current_price < entry_price);
    } else {              // POS_SHORT
        is_underwater = (current_price > entry_price);
    }
    if (adx_slope < 0.0 && is_underwater) {
        sl_mult *= 0.8;
    }

    // ── 2. FTB (Funding Tailwind Buffer) ─────────────────────────────────
    // Disabled in backtester — no funding rate data available.

    // ── 3. DASE (Dynamic ADX Stop Expansion) ─────────────────────────────
    // If ADX > 40 and position is profitable by > 0.5 ATR, widen by 15%.
    if (adx > 40.0) {
        double profit_in_atr;
        if (pos_type == 1) {  // POS_LONG
            profit_in_atr = (current_price - entry_price) / eff_atr;
        } else {              // POS_SHORT
            profit_in_atr = (entry_price - current_price) / eff_atr;
        }
        if (profit_in_atr > 0.5) {
            sl_mult *= 1.15;
        }
    }

    // ── 4. SLB (Saturation Loyalty Buffer) ───────────────────────────────
    // If ADX > 45 (saturated/strong trend), widen overall SL by 10%.
    if (adx > 45.0) {
        sl_mult *= 1.10;
    }

    // ── Compute raw SL price ─────────────────────────────────────────────
    double sl_price;
    if (pos_type == 1) {  // POS_LONG
        sl_price = entry_price - (eff_atr * sl_mult);
    } else {              // POS_SHORT
        sl_price = entry_price + (eff_atr * sl_mult);
    }

    // ── 5. Breakeven Stop ────────────────────────────────────────────────
    // If profit exceeds breakeven_start_atr ATRs, move SL to
    // entry +/- breakeven_buffer_atr ATRs (protecting at least entry).
    if (cfg.enable_breakeven_stop != 0u && cfg.breakeven_start_atr > 0.0f) {
        double be_start = eff_atr * (double)cfg.breakeven_start_atr;
        double be_buffer = eff_atr * (double)cfg.breakeven_buffer_atr;

        if (pos_type == 1) {  // POS_LONG
            if ((current_price - entry_price) >= be_start) {
                // Only raise SL, never lower it from the breakeven level.
                sl_price = fmax(sl_price, entry_price + be_buffer);
            }
        } else {              // POS_SHORT
            if ((entry_price - current_price) >= be_start) {
                // Only lower SL, never raise it from the breakeven level.
                sl_price = fmin(sl_price, entry_price - be_buffer);
            }
        }
    }

    return sl_price;
}
"#
    .to_string()
}

/// Trailing stop: VBTS/TATP/TSPV/ratchet (AQC-1221)
///
/// Translates `bt-core/src/exits/trailing.rs::compute_trailing()` into a CUDA
/// `__device__` function.  All price arithmetic uses `double` to match AQC-734
/// f64 migration.  Every tunable constant is read from `cfg.` — no hardcoded
/// magic numbers remain except the TATP multiplier (1.0, i.e. "don't tighten").
pub fn compute_trailing_codegen() -> String {
    r#"// Derived from bt-core/src/exits/trailing.rs
// Trailing stop: per-confidence offsets, VBTS, RSI Trend-Guard, TATP, TSPV,
//                weak-trend tightening, ratchet.
// All price math in double precision (AQC-734).
// All tunables read from cfg (no hardcoded trailing params).

__device__ double compute_trailing_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double current_price,
    double atr,
    double current_trailing_sl,
    int confidence,
    double rsi,
    double adx,
    double adx_slope,
    double atr_slope,
    double bb_width_ratio,
    double profit_atr
) {
    // ── ATR fallback (mirrors Rust: if entry_atr <= 0 use 0.5% of entry) ──
    double eff_atr = (atr > 0.0) ? atr : (entry_price * 0.005);

    // ── Per-confidence overrides for trailing start / distance ─────────────
    double trailing_start = (double)cfg.trailing_start_atr;
    double trailing_dist  = (double)cfg.trailing_distance_atr;

    if (confidence == 0) {  // Confidence::Low == 0
        if (cfg.trailing_start_atr_low_conf > 0.0f) {
            trailing_start = (double)cfg.trailing_start_atr_low_conf;
        }
        if (cfg.trailing_distance_atr_low_conf > 0.0f) {
            trailing_dist = (double)cfg.trailing_distance_atr_low_conf;
        }
    }

    // ── RSI Trend-Guard floor (v5.016) ────────────────────────────────────
    // Minimum effective trailing distance.  Raised when RSI is favourable
    // (trending in the direction of the position).
    double min_trailing_dist = (double)cfg.trailing_rsi_floor_default;
    if (pos_type == POS_LONG && rsi > 60.0) {
        min_trailing_dist = (double)cfg.trailing_rsi_floor_trending;
    }
    if (pos_type == POS_SHORT && rsi < 40.0) {
        min_trailing_dist = (double)cfg.trailing_rsi_floor_trending;
    }

    // ── Effective trailing distance ───────────────────────────────────────
    double effective_dist = trailing_dist;

    // VBTS (Vol-Buffered Trailing Stop, v5.015): widen when BB expanding.
    if (cfg.enable_vol_buffered_trailing != 0u
        && bb_width_ratio > (double)cfg.trailing_vbts_bb_threshold) {
        effective_dist *= (double)cfg.trailing_vbts_mult;
    }

    // High-profit tightening (> cfg threshold ATR) with TATP / TSPV overrides.
    if (profit_atr > (double)cfg.trailing_high_profit_atr) {
        if (adx > 35.0 && adx_slope > 0.0) {
            // TATP: trend accelerating — don't tighten (1.0x).
            effective_dist = trailing_dist * 1.0;
        } else if (atr_slope > 0.0) {
            // TSPV: volatility expanding — partial tighten.
            effective_dist = trailing_dist * (double)cfg.trailing_tighten_tspv;
        } else {
            // Default high-profit tightening.
            effective_dist = trailing_dist * (double)cfg.trailing_tighten_default;
        }
    } else if (adx < 25.0) {
        // Weak-trend tightening.
        effective_dist = trailing_dist * (double)cfg.trailing_weak_trend_mult;
    }

    // Clamp to RSI Trend-Guard floor.
    effective_dist = fmax(effective_dist, min_trailing_dist);

    // ── Activation gate ───────────────────────────────────────────────────
    if (profit_atr < trailing_start) {
        // Not enough profit to activate trailing stop yet.
        // Preserve any existing trailing SL from a previous bar.
        return current_trailing_sl;
    }

    // ── Compute candidate trailing stop price ─────────────────────────────
    double candidate;
    if (pos_type == POS_LONG) {
        candidate = current_price - (eff_atr * effective_dist);
    } else {
        candidate = current_price + (eff_atr * effective_dist);
    }

    // ── Ratchet: only allow the trailing stop to improve ──────────────────
    // A non-positive current_trailing_sl means "no trailing stop yet" (first bar).
    if (current_trailing_sl > 0.0) {
        if (pos_type == POS_LONG) {
            candidate = fmax(candidate, current_trailing_sl);
        } else {
            candidate = fmin(candidate, current_trailing_sl);
        }
    }

    return candidate;
}
"#
    .to_string()
}

/// Take profit: partial TP + full TP ladder (AQC-1222)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/exits/take_profit.rs::check_tp`.
///
/// Returns a `TpResult` struct: `{ int action; double fraction; int exit_code; }`
///   - action 0 = Hold, action 1 = Reduce (partial TP), action 2 = Close (full TP)
///   - fraction: the reduce fraction (only meaningful when action == 1)
///   - exit_code: 0 = no exit, 10 = partial TP, 11 = full TP
///
/// Uses `double` precision for all price arithmetic to match the f64 Rust
/// source and satisfy T2 precision requirements.
///
/// The `tp_mult` parameter is resolved by the caller (confidence-dependent
/// multipliers via `tp_mult_strong`/`tp_mult_weak`, or dynamic gate TP).
pub fn check_tp_codegen() -> String {
    r#"// Derived from bt-core/src/exits/take_profit.rs
// Take profit: full TP + partial TP ladder.
// All price math in double precision (AQC-734).
//
// Partial TP ladder:
//   1. If enable_partial_tp AND tp1_taken == 0 AND price hits partial TP level
//      -> Reduce by tp_partial_pct, caller sets trailing_sl = entry (breakeven)
//   2. If tp1_taken == 1 AND tp_partial_atr_mult > 0 AND price hits full TP
//      -> Close remainder at full TP
//   3. If tp1_taken == 1 AND tp_partial_atr_mult == 0 -> Hold (trailing manages)
//   4. If partial TP disabled or tp_partial_pct >= 1.0 -> full Close
//
// Confidence-dependent TP multipliers (tp_mult_strong for high ADX,
// tp_mult_weak for low ADX) and dynamic gate TP multiplier are resolved
// by the caller via get_tp_mult() before calling this function.

struct TpResult {
    int action;       // 0 = hold, 1 = reduce (partial), 2 = close (full)
    double fraction;  // reduce fraction (meaningful only when action == 1)
    int exit_code;    // 0 = no exit, 10 = partial TP, 11 = full TP
};

__device__ TpResult check_tp_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double entry_atr,
    double current_price,
    double size,
    unsigned int tp1_taken,
    double tp_mult
) {
    TpResult result;
    result.action = 0;
    result.fraction = 0.0;
    result.exit_code = 0;

    // ── ATR fallback (mirrors Rust: if entry_atr <= 0 use 0.5% of entry) ──
    double atr = (entry_atr > 0.0) ? entry_atr : (entry_price * 0.005);

    // ── Full TP price (always based on tp_mult) ────────────────────────────
    double tp_price;
    if (pos_type == POS_LONG) {
        tp_price = entry_price + (atr * tp_mult);
    } else {
        tp_price = entry_price - (atr * tp_mult);
    }

    // ── Partial TP path ────────────────────────────────────────────────────
    if (cfg.enable_partial_tp != 0u) {
        if (tp1_taken == 0u) {
            // Determine partial TP level: use dedicated mult if set,
            // otherwise same as full TP.
            double partial_mult = (cfg.tp_partial_atr_mult > 0.0)
                ? (double)cfg.tp_partial_atr_mult
                : tp_mult;
            double partial_tp_price;
            if (pos_type == POS_LONG) {
                partial_tp_price = entry_price + (atr * partial_mult);
            } else {
                partial_tp_price = entry_price - (atr * partial_mult);
            }
            bool partial_hit;
            if (pos_type == POS_LONG) {
                partial_hit = (current_price >= partial_tp_price);
            } else {
                partial_hit = (current_price <= partial_tp_price);
            }

            if (partial_hit) {
                double pct = fmax(fmin((double)cfg.tp_partial_pct, 1.0), 0.0);

                if (pct > 0.0 && pct < 1.0) {
                    double remaining_notional = size * (1.0 - pct) * current_price;
                    if (remaining_notional < (double)cfg.tp_partial_min_notional_usd) {
                        // Remaining too small — hold instead of partial.
                        return result;  // action=0, hold
                    }

                    // Partial reduce.
                    result.action = 1;
                    result.fraction = pct;
                    result.exit_code = 10;  // partial TP
                    return result;
                }
                // pct == 0 or pct >= 1.0 falls through to full close check.
            } else {
                // Partial TP not hit yet.
                // When tp_partial_atr_mult == 0, partial == full,
                // so full can't be hit either.
                if (cfg.tp_partial_atr_mult <= 0.0f) {
                    return result;  // action=0, hold
                }
                // When tp_partial_atr_mult > 0, fall through to check full TP
                // (handles edge case where partial_mult > tp_mult).
            }
        } else {
            // tp1 already taken.
            if (cfg.tp_partial_atr_mult > 0.0f) {
                // Separate partial level: check if full TP hit for remainder.
                bool tp_hit;
                if (pos_type == POS_LONG) {
                    tp_hit = (current_price >= tp_price);
                } else {
                    tp_hit = (current_price <= tp_price);
                }
                if (tp_hit) {
                    result.action = 2;
                    result.fraction = 1.0;
                    result.exit_code = 11;  // full TP
                    return result;
                }
            }
            // Same level (tp_partial_atr_mult == 0) or full TP not hit:
            // trailing manages.
            return result;  // action=0, hold
        }
    }

    // ── Full TP check (partial TP disabled, or pct edge case) ──────────────
    bool tp_hit;
    if (pos_type == POS_LONG) {
        tp_hit = (current_price >= tp_price);
    } else {
        tp_hit = (current_price <= tp_price);
    }

    if (!tp_hit) {
        return result;  // action=0, hold
    }

    result.action = 2;
    result.fraction = 1.0;
    result.exit_code = 11;  // full TP
    return result;
}
"#
    .to_string()
}

/// Smart exits: all 8 sub-checks (AQC-1223)
pub fn check_smart_exits_codegen() -> String { String::new() /* stub */ }

/// Exit orchestrator: priority dispatch (AQC-1224)
pub fn check_all_exits_codegen() -> String { String::new() /* stub */ }

/// Entry sizing: dynamic sizing/leverage/vol scalar (AQC-1230)
///
/// Generates a CUDA `__device__` function that mirrors
/// `risk-core/src/lib.rs::compute_entry_sizing`.
///
/// Uses `double` precision for all monetary/size calculations to match the f64
/// Rust source and satisfy T2 precision requirements.  Returns a struct with
/// `size`, `margin`, and `leverage` — a local `SizingResultD` definition is
/// emitted to avoid colliding with the hand-written `float` struct in
/// `sweep_engine.cu`.
pub fn compute_entry_size_codegen() -> String {
    r#"// Derived from bt-core/src/engine.rs sizing logic
// (SSOT: risk-core/src/lib.rs::compute_entry_sizing)
//
// Dynamic entry sizing: allocation % * confidence mult * ADX mult * vol scalar.
// Dynamic leverage selects per-confidence leverage with optional max cap.
// All monetary/size arithmetic in double precision (AQC-734).

struct SizingResultD {
    double size;
    double margin;
    double leverage;
};

__device__ SizingResultD compute_entry_size_codegen(
    double equity,
    double price,
    unsigned int confidence,
    double atr,
    double adx,
    const GpuComboConfig& cfg
) {
    // ── Base margin allocation ───────────────────────────────────────────
    double margin = equity * (double)cfg.allocation_pct;

    // ── Dynamic sizing (confidence * ADX * volatility) ──────────────────
    if (cfg.enable_dynamic_sizing != 0u) {
        // Confidence multiplier
        double conf_mult = (double)cfg.confidence_mult_medium;
        if (confidence == CONF_HIGH) { conf_mult = (double)cfg.confidence_mult_high; }
        if (confidence == CONF_LOW)  { conf_mult = (double)cfg.confidence_mult_low; }

        // ADX multiplier — linearly scales [min_mult, 1.0] over [0, full_adx]
        double adx_ratio = adx / (double)cfg.adx_sizing_full_adx;
        double adx_mult = fmax(fmin(adx_ratio, 1.0), (double)cfg.adx_sizing_min_mult);

        // Volatility scalar — inverse of vol_ratio, clamped to [min, max]
        double vol_scalar = 1.0;
        if ((double)cfg.vol_baseline_pct > 0.0 && price > 0.0) {
            double vol_ratio = (atr / price) / (double)cfg.vol_baseline_pct;
            if (vol_ratio > 0.0) {
                vol_scalar = fmax(fmin(1.0 / vol_ratio, (double)cfg.vol_scalar_max),
                                  (double)cfg.vol_scalar_min);
            }
        }

        margin *= conf_mult * adx_mult * vol_scalar;
    }

    // ── Leverage ─────────────────────────────────────────────────────────
    double lev = (double)cfg.leverage;
    if (cfg.enable_dynamic_leverage != 0u) {
        if (confidence == CONF_HIGH)        { lev = (double)cfg.leverage_high; }
        else if (confidence == CONF_MEDIUM) { lev = (double)cfg.leverage_medium; }
        else                                { lev = (double)cfg.leverage_low; }
        if ((double)cfg.leverage_max_cap > 0.0) { lev = fmin(lev, (double)cfg.leverage_max_cap); }
    }

    // ── Notional & position size ─────────────────────────────────────────
    double notional = margin * lev;
    double size = 0.0;
    if (price > 0.0) { size = notional / price; }

    SizingResultD result;
    result.size = size;
    result.margin = margin;
    result.leverage = lev;
    return result;
}
"#
    .to_string()
}

/// PESC cooldown: reentry cooldown + ADX interpolation (AQC-1231)
pub fn is_pesc_blocked_codegen() -> String { String::new() /* stub */ }

// ═══════════════════════════════════════════════════════════════════════════
// Tests
// ═══════════════════════════════════════════════════════════════════════════

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sl_codegen_has_correct_function_signature() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("__device__ double compute_sl_price_codegen("),
            "must declare a __device__ double function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(
            src.contains("int pos_type"),
            "must take pos_type as int"
        );
        assert!(
            src.contains("double entry_price"),
            "must take entry_price as double"
        );
        assert!(
            src.contains("double atr"),
            "must take atr as double"
        );
        assert!(
            src.contains("double current_price"),
            "must take current_price as double"
        );
        assert!(
            src.contains("double adx"),
            "must take adx as double"
        );
        assert!(
            src.contains("double adx_slope"),
            "must take adx_slope as double"
        );
    }

    #[test]
    fn sl_codegen_uses_double_precision() {
        let src = compute_sl_price_codegen();
        // Return type is double
        assert!(src.contains("__device__ double"));
        // Internal arithmetic uses double variables
        assert!(src.contains("double sl_mult"));
        assert!(src.contains("double sl_price"));
        assert!(src.contains("double eff_atr"));
        assert!(src.contains("double be_start"));
        assert!(src.contains("double be_buffer"));
        // Must NOT use float for price-critical variables
        assert!(
            !src.contains("float sl_price"),
            "sl_price must be double, not float"
        );
        assert!(
            !src.contains("float sl_mult"),
            "sl_mult must be double, not float"
        );
    }

    #[test]
    fn sl_codegen_contains_ase_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("ASE"), "must have ASE comment marker");
        assert!(
            src.contains("adx_slope < 0.0"),
            "ASE checks for negative ADX slope"
        );
        assert!(
            src.contains("is_underwater"),
            "ASE checks underwater condition"
        );
        assert!(src.contains("*= 0.8"), "ASE tightens by 20% (x0.80)");
    }

    #[test]
    fn sl_codegen_contains_dase_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("DASE"), "must have DASE comment marker");
        assert!(
            src.contains("adx > 40.0"),
            "DASE triggers when ADX > 40"
        );
        assert!(
            src.contains("profit_in_atr"),
            "DASE computes profit in ATR units"
        );
        assert!(
            src.contains("profit_in_atr > 0.5"),
            "DASE requires > 0.5 ATR profit"
        );
        assert!(src.contains("*= 1.15"), "DASE widens by 15% (x1.15)");
    }

    #[test]
    fn sl_codegen_contains_slb_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("SLB"), "must have SLB comment marker");
        assert!(
            src.contains("adx > 45.0"),
            "SLB triggers when ADX > 45"
        );
        assert!(src.contains("*= 1.10"), "SLB widens by 10% (x1.10)");
    }

    #[test]
    fn sl_codegen_contains_breakeven_logic() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("Breakeven"),
            "must have Breakeven comment marker"
        );
        assert!(
            src.contains("cfg.enable_breakeven_stop"),
            "breakeven checks enable flag from config"
        );
        assert!(
            src.contains("cfg.breakeven_start_atr"),
            "breakeven uses start ATR threshold from config"
        );
        assert!(
            src.contains("cfg.breakeven_buffer_atr"),
            "breakeven uses buffer ATR from config"
        );
        assert!(
            src.contains("fmax(sl_price, entry_price + be_buffer)"),
            "long breakeven raises SL via fmax"
        );
        assert!(
            src.contains("fmin(sl_price, entry_price - be_buffer)"),
            "short breakeven lowers SL via fmin"
        );
    }

    #[test]
    fn sl_codegen_uses_correct_config_fields() {
        let src = compute_sl_price_codegen();
        // All config field accesses must use GpuComboConfig field names
        assert!(src.contains("cfg.sl_atr_mult"), "must use cfg.sl_atr_mult");
        assert!(
            src.contains("cfg.enable_breakeven_stop"),
            "must use cfg.enable_breakeven_stop"
        );
        assert!(
            src.contains("cfg.breakeven_start_atr"),
            "must use cfg.breakeven_start_atr"
        );
        assert!(
            src.contains("cfg.breakeven_buffer_atr"),
            "must use cfg.breakeven_buffer_atr"
        );
    }

    #[test]
    fn sl_codegen_uses_fmax_fmin_not_std_max() {
        let src = compute_sl_price_codegen();
        // Must use CUDA fmax/fmin, not std::max/std::min
        assert!(src.contains("fmax("), "must use fmax for CUDA");
        assert!(src.contains("fmin("), "must use fmin for CUDA");
        assert!(
            !src.contains("std::max"),
            "must not use std::max (use fmax for CUDA)"
        );
        assert!(
            !src.contains("std::min"),
            "must not use std::min (use fmin for CUDA)"
        );
    }

    #[test]
    fn sl_codegen_has_long_short_direction() {
        let src = compute_sl_price_codegen();
        // Long: SL below entry (entry - atr * mult)
        assert!(
            src.contains("entry_price - (eff_atr * sl_mult)"),
            "long SL = entry - atr * mult"
        );
        // Short: SL above entry (entry + atr * mult)
        assert!(
            src.contains("entry_price + (eff_atr * sl_mult)"),
            "short SL = entry + atr * mult"
        );
    }

    #[test]
    fn sl_codegen_has_atr_fallback() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("entry_price * 0.005"),
            "must have ATR fallback for legacy positions"
        );
    }

    #[test]
    fn sl_codegen_has_source_comment() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/stop_loss.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn sl_codegen_pos_type_uses_integer_constants() {
        let src = compute_sl_price_codegen();
        // Must use integer comparison, not enum
        assert!(
            src.contains("pos_type == 1"),
            "long check must use pos_type == 1 (POS_LONG)"
        );
    }

    // -- compute_trailing_codegen tests (AQC-1221) ----------------------------

    #[test]
    fn trailing_codegen_contains_function_signature() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("__device__ double compute_trailing_codegen("),
            "must emit __device__ double function signature"
        );
    }

    #[test]
    fn trailing_codegen_contains_source_comment() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/trailing.rs"),
            "must have provenance comment"
        );
    }

    #[test]
    fn trailing_codegen_uses_double_precision() {
        let src = compute_trailing_codegen();
        assert!(src.contains("double trailing_start"), "trailing_start must be double");
        assert!(src.contains("double trailing_dist"), "trailing_dist must be double");
        assert!(src.contains("double effective_dist"), "effective_dist must be double");
        assert!(src.contains("double candidate"), "candidate must be double");
        assert!(src.contains("double eff_atr"), "eff_atr must be double");
        assert!(src.contains("double min_trailing_dist"), "min_trailing_dist must be double");
    }

    #[test]
    fn trailing_codegen_reads_config_not_hardcoded() {
        let src = compute_trailing_codegen();
        assert!(src.contains("cfg.trailing_start_atr"), "trailing_start from config");
        assert!(src.contains("cfg.trailing_distance_atr"), "trailing_distance from config");
        assert!(src.contains("cfg.trailing_start_atr_low_conf"), "low_conf start from config");
        assert!(src.contains("cfg.trailing_distance_atr_low_conf"), "low_conf dist from config");
        assert!(src.contains("cfg.trailing_rsi_floor_default"), "RSI floor default from config");
        assert!(src.contains("cfg.trailing_rsi_floor_trending"), "RSI floor trending from config");
        assert!(src.contains("cfg.enable_vol_buffered_trailing"), "VBTS enable from config");
        assert!(src.contains("cfg.trailing_vbts_bb_threshold"), "VBTS BB threshold from config");
        assert!(src.contains("cfg.trailing_vbts_mult"), "VBTS mult from config");
        assert!(src.contains("cfg.trailing_high_profit_atr"), "high profit threshold from config");
        assert!(src.contains("cfg.trailing_tighten_tspv"), "TSPV tighten from config");
        assert!(src.contains("cfg.trailing_tighten_default"), "default tighten from config");
        assert!(src.contains("cfg.trailing_weak_trend_mult"), "weak trend mult from config");
    }

    #[test]
    fn trailing_codegen_contains_vbts_logic() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("VBTS") || src.contains("Vol-Buffered"),
            "must contain VBTS reference"
        );
        assert!(src.contains("bb_width_ratio"), "VBTS must check bb_width_ratio");
    }

    #[test]
    fn trailing_codegen_contains_ratchet_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("Ratchet") || src.contains("ratchet"), "must contain ratchet");
        assert!(src.contains("fmax(candidate"), "LONG ratchet uses fmax");
        assert!(src.contains("fmin(candidate"), "SHORT ratchet uses fmin");
    }

    #[test]
    fn trailing_codegen_contains_rsi_trend_guard() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("RSI Trend-Guard") || src.contains("rsi_floor"),
            "must reference RSI Trend-Guard"
        );
        assert!(src.contains("rsi > 60.0"), "LONG RSI favourability check");
        assert!(src.contains("rsi < 40.0"), "SHORT RSI favourability check");
    }

    #[test]
    fn trailing_codegen_contains_tatp_tspv_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("TATP"), "must reference TATP");
        assert!(src.contains("TSPV"), "must reference TSPV");
        assert!(src.contains("adx_slope"), "TATP checks adx_slope");
        assert!(src.contains("atr_slope"), "TSPV checks atr_slope");
    }

    #[test]
    fn trailing_codegen_contains_weak_trend_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("adx < 25.0"), "weak-trend check on adx < 25");
        assert!(src.contains("trailing_weak_trend_mult"), "weak-trend uses config mult");
    }

    #[test]
    fn trailing_codegen_contains_activation_gate() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("profit_atr < trailing_start"),
            "activation gate: profit must exceed trailing_start"
        );
        assert!(
            src.contains("return current_trailing_sl"),
            "when not active, preserve existing trailing SL"
        );
    }

    #[test]
    fn trailing_codegen_handles_low_confidence() {
        let src = compute_trailing_codegen();
        assert!(src.contains("confidence == 0"), "Low confidence mapped to 0");
    }

    #[test]
    fn trailing_codegen_handles_no_existing_trailing_sl() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("current_trailing_sl > 0.0"),
            "must check for no existing trailing SL (first computation)"
        );
    }

    #[test]
    fn trailing_codegen_uses_fmax_fmin() {
        let src = compute_trailing_codegen();
        assert!(src.contains("fmax("), "must use fmax for CUDA double math");
        assert!(src.contains("fmin("), "must use fmin for CUDA double math");
    }

    #[test]
    fn trailing_codegen_is_nonempty() {
        let src = compute_trailing_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- check_tp_codegen tests (AQC-1222) ------------------------------------

    #[test]
    fn tp_codegen_has_correct_function_signature() {
        let src = check_tp_codegen();
        assert!(
            src.contains("__device__ TpResult check_tp_codegen("),
            "must declare a __device__ TpResult function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(
            src.contains("int pos_type"),
            "must take pos_type as int"
        );
        assert!(
            src.contains("double entry_price"),
            "must take entry_price as double"
        );
        assert!(
            src.contains("double entry_atr"),
            "must take entry_atr as double"
        );
        assert!(
            src.contains("double current_price"),
            "must take current_price as double"
        );
        assert!(
            src.contains("double size"),
            "must take size as double"
        );
        assert!(
            src.contains("unsigned int tp1_taken"),
            "must take tp1_taken as unsigned int"
        );
        assert!(
            src.contains("double tp_mult"),
            "must take tp_mult as double"
        );
    }

    #[test]
    fn tp_codegen_has_source_comment() {
        let src = check_tp_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/take_profit.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn tp_codegen_uses_double_precision() {
        let src = check_tp_codegen();
        // Return struct fields
        assert!(src.contains("double fraction"), "fraction must be double");
        // Internal arithmetic uses double variables
        assert!(src.contains("double atr"), "atr must be double");
        assert!(src.contains("double tp_price"), "tp_price must be double");
        assert!(src.contains("double partial_mult"), "partial_mult must be double");
        assert!(src.contains("double partial_tp_price"), "partial_tp_price must be double");
        assert!(src.contains("double pct"), "pct must be double");
        assert!(src.contains("double remaining_notional"), "remaining_notional must be double");
        // Must NOT use float for price-critical variables
        assert!(
            !src.contains("float tp_price"),
            "tp_price must be double, not float"
        );
        assert!(
            !src.contains("float partial_tp_price"),
            "partial_tp_price must be double, not float"
        );
    }

    #[test]
    fn tp_codegen_contains_partial_tp_logic() {
        let src = check_tp_codegen();
        assert!(
            src.contains("Partial TP") || src.contains("partial TP"),
            "must have partial TP comment marker"
        );
        assert!(
            src.contains("cfg.enable_partial_tp"),
            "must check enable_partial_tp config flag"
        );
        assert!(
            src.contains("tp1_taken == 0u"),
            "must check tp1_taken flag for first partial"
        );
        assert!(
            src.contains("partial_hit"),
            "must compute partial_hit condition"
        );
        assert!(
            src.contains("result.action = 1"),
            "partial TP must set action = 1 (reduce)"
        );
        assert!(
            src.contains("result.fraction = pct"),
            "partial TP must set fraction to pct"
        );
        assert!(
            src.contains("result.exit_code = 10"),
            "partial TP must set exit_code = 10"
        );
    }

    #[test]
    fn tp_codegen_contains_full_tp_logic() {
        let src = check_tp_codegen();
        assert!(
            src.contains("Full TP") || src.contains("full TP"),
            "must have full TP comment marker"
        );
        assert!(
            src.contains("result.action = 2"),
            "full TP must set action = 2 (close)"
        );
        assert!(
            src.contains("result.exit_code = 11"),
            "full TP must set exit_code = 11"
        );
        assert!(
            src.contains("tp_hit"),
            "must compute tp_hit condition for full TP"
        );
    }

    #[test]
    fn tp_codegen_uses_correct_config_fields() {
        let src = check_tp_codegen();
        assert!(
            src.contains("cfg.enable_partial_tp"),
            "must use cfg.enable_partial_tp"
        );
        assert!(
            src.contains("cfg.tp_partial_pct"),
            "must use cfg.tp_partial_pct"
        );
        assert!(
            src.contains("cfg.tp_partial_atr_mult"),
            "must use cfg.tp_partial_atr_mult"
        );
        assert!(
            src.contains("cfg.tp_partial_min_notional_usd"),
            "must use cfg.tp_partial_min_notional_usd"
        );
    }

    #[test]
    fn tp_codegen_has_atr_fallback() {
        let src = check_tp_codegen();
        assert!(
            src.contains("entry_price * 0.005"),
            "must have ATR fallback for legacy positions"
        );
    }

    #[test]
    fn tp_codegen_has_notional_check() {
        let src = check_tp_codegen();
        assert!(
            src.contains("remaining_notional"),
            "must compute remaining notional for partial TP min check"
        );
        assert!(
            src.contains("tp_partial_min_notional_usd"),
            "must check minimum notional threshold"
        );
    }

    #[test]
    fn tp_codegen_handles_tp1_taken() {
        let src = check_tp_codegen();
        assert!(
            src.contains("tp1_taken == 0u"),
            "must check tp1_taken for first partial TP"
        );
        assert!(
            src.contains("tp1 already taken"),
            "must have comment for tp1 already taken path"
        );
    }

    #[test]
    fn tp_codegen_handles_separate_partial_level() {
        let src = check_tp_codegen();
        // When tp_partial_atr_mult > 0, partial TP fires at a different level
        assert!(
            src.contains("cfg.tp_partial_atr_mult > 0.0"),
            "must check for separate partial mult"
        );
        // When tp_partial_atr_mult == 0, partial == full
        assert!(
            src.contains("cfg.tp_partial_atr_mult <= 0.0"),
            "must handle zero partial mult (legacy)"
        );
    }

    #[test]
    fn tp_codegen_has_long_short_direction() {
        let src = check_tp_codegen();
        // Long: TP above entry (entry + atr * mult)
        assert!(
            src.contains("entry_price + (atr * tp_mult)"),
            "long full TP = entry + atr * mult"
        );
        // Short: TP below entry (entry - atr * mult)
        assert!(
            src.contains("entry_price - (atr * tp_mult)"),
            "short full TP = entry - atr * mult"
        );
    }

    #[test]
    fn tp_codegen_uses_fmax_fmin() {
        let src = check_tp_codegen();
        // Used for clamping tp_partial_pct
        assert!(src.contains("fmax("), "must use fmax for CUDA double math");
        assert!(src.contains("fmin("), "must use fmin for CUDA double math");
    }

    #[test]
    fn tp_codegen_has_tp_result_struct() {
        let src = check_tp_codegen();
        assert!(
            src.contains("struct TpResult"),
            "must define TpResult struct"
        );
        assert!(
            src.contains("int action"),
            "TpResult must have action field"
        );
        assert!(
            src.contains("double fraction"),
            "TpResult must have fraction field"
        );
        assert!(
            src.contains("int exit_code"),
            "TpResult must have exit_code field"
        );
    }

    #[test]
    fn tp_codegen_is_nonempty() {
        let src = check_tp_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- compute_entry_size_codegen tests (AQC-1230) --------------------------

    #[test]
    fn sizing_codegen_has_correct_function_signature() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("__device__ SizingResultD compute_entry_size_codegen("),
            "must declare a __device__ SizingResultD function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(
            src.contains("double equity"),
            "must take equity as double"
        );
        assert!(
            src.contains("double price"),
            "must take price as double"
        );
        assert!(
            src.contains("unsigned int confidence"),
            "must take confidence as unsigned int"
        );
        assert!(
            src.contains("double atr"),
            "must take atr as double"
        );
        assert!(
            src.contains("double adx"),
            "must take adx as double"
        );
    }

    #[test]
    fn sizing_codegen_emits_result_struct() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("struct SizingResultD"),
            "must define SizingResultD struct"
        );
        assert!(
            src.contains("double size;"),
            "SizingResultD must have double size field"
        );
        assert!(
            src.contains("double margin;"),
            "SizingResultD must have double margin field"
        );
        assert!(
            src.contains("double leverage;"),
            "SizingResultD must have double leverage field"
        );
    }

    #[test]
    fn sizing_codegen_uses_double_precision() {
        let src = compute_entry_size_codegen();
        assert!(src.contains("double margin ="), "margin must be double");
        assert!(src.contains("double conf_mult"), "conf_mult must be double");
        assert!(src.contains("double adx_mult"), "adx_mult must be double");
        assert!(src.contains("double vol_scalar"), "vol_scalar must be double");
        assert!(src.contains("double lev"), "lev must be double");
        assert!(src.contains("double notional"), "notional must be double");
        assert!(src.contains("double size"), "size must be double");
        // Must NOT use float for monetary variables
        assert!(
            !src.contains("float margin"),
            "margin must be double, not float"
        );
        assert!(
            !src.contains("float notional"),
            "notional must be double, not float"
        );
    }

    #[test]
    fn sizing_codegen_contains_confidence_multiplier() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.confidence_mult_high"),
            "must use confidence_mult_high from config"
        );
        assert!(
            src.contains("cfg.confidence_mult_medium"),
            "must use confidence_mult_medium from config"
        );
        assert!(
            src.contains("cfg.confidence_mult_low"),
            "must use confidence_mult_low from config"
        );
        assert!(src.contains("CONF_HIGH"), "must check CONF_HIGH");
        assert!(src.contains("CONF_LOW"), "must check CONF_LOW");
    }

    #[test]
    fn sizing_codegen_contains_adx_multiplier() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.adx_sizing_full_adx"),
            "must use adx_sizing_full_adx from config"
        );
        assert!(
            src.contains("cfg.adx_sizing_min_mult"),
            "must use adx_sizing_min_mult from config"
        );
        assert!(
            src.contains("adx_mult"),
            "must compute adx_mult"
        );
    }

    #[test]
    fn sizing_codegen_contains_vol_scalar() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.vol_baseline_pct"),
            "must use vol_baseline_pct from config"
        );
        assert!(
            src.contains("cfg.vol_scalar_min"),
            "must use vol_scalar_min from config"
        );
        assert!(
            src.contains("cfg.vol_scalar_max"),
            "must use vol_scalar_max from config"
        );
        assert!(
            src.contains("vol_ratio"),
            "must compute vol_ratio"
        );
        assert!(
            src.contains("1.0 / vol_ratio"),
            "vol_scalar is inverse of vol_ratio"
        );
    }

    #[test]
    fn sizing_codegen_contains_dynamic_sizing_gate() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.enable_dynamic_sizing != 0u"),
            "must gate dynamic sizing on config flag"
        );
    }

    #[test]
    fn sizing_codegen_contains_dynamic_leverage() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.enable_dynamic_leverage != 0u"),
            "must gate dynamic leverage on config flag"
        );
        assert!(
            src.contains("cfg.leverage_high"),
            "must use leverage_high from config"
        );
        assert!(
            src.contains("cfg.leverage_medium"),
            "must use leverage_medium from config"
        );
        assert!(
            src.contains("cfg.leverage_low"),
            "must use leverage_low from config"
        );
        assert!(
            src.contains("cfg.leverage_max_cap"),
            "must use leverage_max_cap from config"
        );
    }

    #[test]
    fn sizing_codegen_contains_base_leverage_fallback() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.leverage"),
            "must fall back to base leverage when dynamic leverage disabled"
        );
    }

    #[test]
    fn sizing_codegen_contains_notional_and_size() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("margin * lev"),
            "notional = margin * leverage"
        );
        assert!(
            src.contains("notional / price"),
            "size = notional / price"
        );
    }

    #[test]
    fn sizing_codegen_handles_zero_price() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("price > 0.0"),
            "must guard against zero/negative price"
        );
    }

    #[test]
    fn sizing_codegen_uses_allocation_pct() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.allocation_pct"),
            "must use allocation_pct from config"
        );
        assert!(
            src.contains("equity * (double)cfg.allocation_pct"),
            "base margin = equity * allocation_pct"
        );
    }

    #[test]
    fn sizing_codegen_uses_fmax_fmin() {
        let src = compute_entry_size_codegen();
        assert!(src.contains("fmax("), "must use fmax for CUDA");
        assert!(src.contains("fmin("), "must use fmin for CUDA");
        assert!(
            !src.contains("std::max"),
            "must not use std::max (use fmax for CUDA)"
        );
        assert!(
            !src.contains("std::min"),
            "must not use std::min (use fmin for CUDA)"
        );
    }

    #[test]
    fn sizing_codegen_has_source_comment() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("Derived from bt-core/src/engine.rs sizing logic"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn sizing_codegen_applies_multipliers_to_margin() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("margin *= conf_mult * adx_mult * vol_scalar"),
            "dynamic sizing multiplies margin by all three factors"
        );
    }

    #[test]
    fn sizing_codegen_is_nonempty() {
        let src = compute_entry_size_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }
}
