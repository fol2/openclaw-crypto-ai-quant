//! CUDA code templates for decision logic functions.
//!
//! Each template mirrors the corresponding Rust function in bt-signals and bt-core.
//! Decision logic covers: gates, signals, exits (SL/TSL/TP/smart), sizing, and cooldowns.
//!
//! Templates are stubs (returning empty strings) until their respective tickets implement them:
//! - AQC-1210: check_gates_codegen()
//! - AQC-1211: generate_signal_codegen()
//! - AQC-1220: compute_sl_price_codegen()
//! - AQC-1221: compute_trailing_codegen()
//! - AQC-1222: check_tp_codegen()
//! - AQC-1223: check_smart_exits_codegen()
//! - AQC-1224: check_all_exits_codegen()
//! - AQC-1230: compute_entry_size_codegen()
//! - AQC-1231: is_pesc_blocked_codegen()

/// File header for the generated decision CUDA source.
pub const DECISION_HEADER: &str = "\
// =============================================================================
// AUTO-GENERATED from bt-signals + bt-core kernel source -- DO NOT EDIT
// Generated by bt-gpu/build.rs decision codegen
// =============================================================================
//
// These device functions mirror the Rust decision logic in:
//   bt-signals/src/gates.rs      -- gate evaluation
//   bt-signals/src/entry.rs      -- signal generation
//   bt-core/src/exits/*.rs       -- stop loss, trailing, take profit, smart exits
//   bt-core/src/engine.rs        -- sizing, cooldowns
//
// Source of truth: Rust kernel code. GPU code is derived, not independent.
// =============================================================================

#pragma once
";

// The SOURCE_HASHES line will be injected by the drift detector (AQC-1200)

/// Gates: 8 gates + TMC/AVE + DRE (AQC-1210)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-signals/src/gates.rs::check_gates`.
///
/// Evaluates 8 individual gates (ranging, anomaly, extension, volume,
/// ADX rising, ADX threshold with TMC/AVE, macro alignment, BTC alignment),
/// plus slow-drift ranging override and DRE (Dynamic RSI Elasticity).
///
/// Returns a `GateResultD` struct with `all_gates_pass`, directional alignment
/// flags, DRE RSI limits, and the `effective_min_adx` used.
///
/// All indicator/price math uses `double` precision to match the f64 Rust
/// source and satisfy T2 precision requirements (AQC-734).
pub fn check_gates_codegen() -> String {
    r#"// Derived from bt-signals/src/gates.rs
// Gate evaluation: 8 gates + TMC/AVE + DRE + slow-drift override.
// All indicator/price math in double precision (AQC-734).
// All tunables read from cfg (no hardcoded gate thresholds).

struct GateResultD {
    bool all_gates_pass;
    bool is_ranging;
    bool is_anomaly;
    bool is_extended;
    bool vol_confirm;
    bool is_trending_up;
    bool adx_above_min;
    bool bullish_alignment;
    bool bearish_alignment;
    double effective_min_adx;
    double rsi_long_limit;
    double rsi_short_limit;
};

__device__ GateResultD check_gates_codegen(
    const GpuComboConfig& cfg,
    double rsi,
    double adx,
    double adx_slope,
    double bb_width_ratio,
    double ema_fast,
    double ema_slow,
    double ema_macro,
    double close,
    double prev_close,
    double volume,
    double vol_sma,
    unsigned int vol_trend,
    double atr,
    double avg_atr,
    double stoch_rsi_k,
    double ema_slow_slope_pct,
    unsigned int btc_bullish,      // 0=bearish, 1=bullish, 2=unknown/no-data
    unsigned int is_btc_symbol     // 1 if symbol is BTC
) {
    GateResultD result;
    result.all_gates_pass = false;
    result.is_ranging = false;
    result.is_anomaly = false;
    result.is_extended = false;
    result.vol_confirm = true;
    result.is_trending_up = true;
    result.adx_above_min = false;
    result.bullish_alignment = (ema_fast > ema_slow);
    result.bearish_alignment = (ema_fast < ema_slow);
    result.effective_min_adx = (double)cfg.min_adx;
    result.rsi_long_limit = 0.0;
    result.rsi_short_limit = 0.0;

    // ── Gate 1: Ranging filter (vote system) ─────────────────────────────
    // Python lines 3344-3363; Rust gates.rs Gate 1.
    // Three votes: ADX below threshold, BB width ratio below threshold,
    // RSI in neutral zone.  Ranging if votes >= min_signals.
    if (cfg.enable_ranging_filter != 0u) {
        unsigned int min_signals = cfg.ranging_min_signals;
        if (min_signals < 1u) { min_signals = 1u; }
        unsigned int votes = 0u;

        // Vote 1: ADX below ranging threshold
        if (adx < (double)cfg.ranging_adx_lt) { votes += 1u; }

        // Vote 2: BB width ratio below ranging threshold
        if (bb_width_ratio < (double)cfg.ranging_bb_width_ratio_lt) { votes += 1u; }

        // Vote 3: RSI in neutral zone
        if (rsi > (double)cfg.ranging_rsi_low && rsi < (double)cfg.ranging_rsi_high) { votes += 1u; }

        result.is_ranging = (votes >= min_signals);
    }

    // ── Gate 2: Anomaly filter ───────────────────────────────────────────
    // Python lines 3365-3371; Rust gates.rs Gate 2.
    // Blocks entry when price_change_pct > threshold OR ema_dev_pct > threshold.
    if (cfg.enable_anomaly_filter != 0u) {
        double price_change_pct = 0.0;
        if (prev_close > 0.0) {
            price_change_pct = fabs(close - prev_close) / prev_close;
        }
        double ema_dev_pct = 0.0;
        if (ema_fast > 0.0) {
            ema_dev_pct = fabs(close - ema_fast) / ema_fast;
        }
        result.is_anomaly = (price_change_pct > (double)cfg.anomaly_price_change_pct)
                         || (ema_dev_pct > (double)cfg.anomaly_ema_dev_pct);
    }

    // ── Gate 3: Extension filter (distance from EMA_fast) ────────────────
    // Python lines 3533-3537; Rust gates.rs Gate 3.
    if (cfg.enable_extension_filter != 0u) {
        if (ema_fast > 0.0) {
            double dist = fabs(close - ema_fast) / ema_fast;
            result.is_extended = (dist > (double)cfg.max_dist_ema_fast);
        }
    }

    // ── Gate 4: Volume confirmation ──────────────────────────────────────
    // Python lines 3432-3440; Rust gates.rs Gate 4.
    // When vol_confirm_include_prev: relaxed (vol > vol_sma OR vol_trend).
    // Otherwise strict: (vol > vol_sma) AND vol_trend.
    if (cfg.require_volume_confirmation != 0u) {
        bool vol_above_sma = (volume > vol_sma);
        bool vol_trend_ok = (vol_trend != 0u);
        if (cfg.vol_confirm_include_prev != 0u) {
            result.vol_confirm = vol_above_sma || vol_trend_ok;
        } else {
            result.vol_confirm = vol_above_sma && vol_trend_ok;
        }
    }

    // ── Gate 5: ADX rising (or saturated) ────────────────────────────────
    // Python lines 3426-3430; Rust gates.rs Gate 5.
    if (cfg.require_adx_rising != 0u) {
        double saturation = (double)cfg.adx_rising_saturation;
        result.is_trending_up = (adx_slope > 0.0) || (adx > saturation);
    }

    // ── Gate 6: ADX threshold (effective_min_adx with TMC + AVE) ─────────
    // Python lines 3383-3424; Rust gates.rs Gate 6.
    double effective_min_adx = (double)cfg.min_adx;

    // TMC: Trend Momentum Confirmation (v4.6)
    // If ADX slope > 0.5, cap effective_min_adx at 25.0.
    if (adx_slope > 0.5) {
        effective_min_adx = fmin(effective_min_adx, 25.0);
    }

    // AVE: Adaptive Volatility Entry (v4.7)
    // If ATR / avg_ATR > threshold, multiply effective_min_adx by ave_adx_mult.
    if (cfg.ave_enabled != 0u && avg_atr > 0.0) {
        double atr_ratio = atr / avg_atr;
        if (atr_ratio > (double)cfg.ave_atr_ratio_gt) {
            double mult = ((double)cfg.ave_adx_mult > 0.0)
                ? (double)cfg.ave_adx_mult
                : 1.0;
            effective_min_adx *= mult;
        }
    }

    result.adx_above_min = (adx > effective_min_adx);
    result.effective_min_adx = effective_min_adx;

    // ── Gate 7: Macro alignment (EMA cross + optional macro EMA) ─────────
    // Python lines 3448-3452; Rust gates.rs Gate 7.
    if (cfg.require_macro_alignment != 0u) {
        result.bullish_alignment = result.bullish_alignment && (ema_slow > ema_macro);
        result.bearish_alignment = result.bearish_alignment && (ema_slow < ema_macro);
    }

    // ── Gate 8: BTC alignment (optional) ─────────────────────────────────
    // Python lines 3454-3461; Rust gates.rs Gate 8.
    // btc_bullish: 0=bearish, 1=bullish, 2=unknown/no-data.
    // If is_btc_symbol or btc_bullish unknown or alignment matches, gate passes.
    // High ADX overrides BTC alignment requirement.
    // (btc_ok is not part of all_gates_pass; it is checked per-direction by the
    //  signal generator.  We store the results for the caller.)

    // ── Slow-drift ranging override ──────────────────────────────────────
    // Python lines 3524-3526; Rust gates.rs slow-drift override.
    // If slow drift enabled and EMA_slow slope exceeds threshold, clear ranging.
    if (cfg.enable_slow_drift_entries != 0u
        && result.is_ranging
        && fabs(ema_slow_slope_pct) >= (double)cfg.slow_drift_ranging_slope_override) {
        result.is_ranging = false;
    }

    // ── DRE (Dynamic RSI Elasticity) — v4.1 ─────────────────────────────
    // Python lines 3551-3560; Rust gates.rs DRE.
    // Linear interpolation of RSI limits between weak and strong based on ADX.
    {
        double adx_min_dre = (double)cfg.dre_min_adx;
        double adx_max_dre = (double)cfg.dre_max_adx;
        if (adx_max_dre <= adx_min_dre) {
            adx_max_dre = adx_min_dre + 1.0;
        }
        double weight = (adx - adx_min_dre) / (adx_max_dre - adx_min_dre);
        weight = fmax(fmin(weight, 1.0), 0.0);  // clamp [0, 1]

        double rsi_long_weak  = (double)cfg.dre_long_rsi_limit_low;
        double rsi_long_strong = (double)cfg.dre_long_rsi_limit_high;
        result.rsi_long_limit = rsi_long_weak + weight * (rsi_long_strong - rsi_long_weak);

        double rsi_short_weak  = (double)cfg.dre_short_rsi_limit_low;
        double rsi_short_strong = (double)cfg.dre_short_rsi_limit_high;
        result.rsi_short_limit = rsi_short_weak + weight * (rsi_short_strong - rsi_short_weak);
    }

    // ── Combined check: all gates required for standard trend entry ──────
    // Rust gates.rs: adx_above_min && !ranging && !anomaly && !extended
    //                && vol_confirm && is_trending_up
    result.all_gates_pass = result.adx_above_min
        && !result.is_ranging
        && !result.is_anomaly
        && !result.is_extended
        && result.vol_confirm
        && result.is_trending_up;

    return result;
}
"#
    .to_string()
}

/// Signals: Mode 1/2/3 + MACD helpers (AQC-1211)
pub fn generate_signal_codegen() -> String { String::new() /* stub */ }

/// Stop loss: ASE/DASE/SLB/breakeven (AQC-1220)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/exits/stop_loss.rs::compute_sl_price`.
///
/// Uses `double` precision for all price arithmetic to match the f64 Rust
/// source and satisfy T2 precision requirements (single arithmetic:
/// price +/- atr * mult).
pub fn compute_sl_price_codegen() -> String {
    r#"// Derived from bt-core/src/exits/stop_loss.rs
// Computes the dynamic stop-loss price for a position each bar.
//
// Modifiers applied to sl_atr_mult:
//   1. ASE  — ADX slope < 0 AND underwater -> tighten 20% (x0.80)
//   2. FTB  — Disabled in backtester (no funding data)
//   3. DASE — ADX > 40 AND profitable > 0.5 ATR -> widen 15% (x1.15)
//   4. SLB  — ADX > 45 -> widen 10% (x1.10)
//   5. Breakeven — profit >= be_start -> move SL to entry +/- be_buffer
__device__ double compute_sl_price_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double atr,
    double current_price,
    double adx,
    double adx_slope
) {
    // ATR fallback: legacy positions with no ATR recorded
    double eff_atr = (atr > 0.0) ? atr : (entry_price * 0.005);

    double sl_mult = (double)cfg.sl_atr_mult;

    // ── 1. ASE (ADX Slope-Adjusted Stop) ─────────────────────────────────
    // If trend is weakening (ADX slope < 0) and position is underwater,
    // tighten the stop by 20%.
    bool is_underwater;
    if (pos_type == 1) {  // POS_LONG
        is_underwater = (current_price < entry_price);
    } else {              // POS_SHORT
        is_underwater = (current_price > entry_price);
    }
    if (adx_slope < 0.0 && is_underwater) {
        sl_mult *= 0.8;
    }

    // ── 2. FTB (Funding Tailwind Buffer) ─────────────────────────────────
    // Disabled in backtester — no funding rate data available.

    // ── 3. DASE (Dynamic ADX Stop Expansion) ─────────────────────────────
    // If ADX > 40 and position is profitable by > 0.5 ATR, widen by 15%.
    if (adx > 40.0) {
        double profit_in_atr;
        if (pos_type == 1) {  // POS_LONG
            profit_in_atr = (current_price - entry_price) / eff_atr;
        } else {              // POS_SHORT
            profit_in_atr = (entry_price - current_price) / eff_atr;
        }
        if (profit_in_atr > 0.5) {
            sl_mult *= 1.15;
        }
    }

    // ── 4. SLB (Saturation Loyalty Buffer) ───────────────────────────────
    // If ADX > 45 (saturated/strong trend), widen overall SL by 10%.
    if (adx > 45.0) {
        sl_mult *= 1.10;
    }

    // ── Compute raw SL price ─────────────────────────────────────────────
    double sl_price;
    if (pos_type == 1) {  // POS_LONG
        sl_price = entry_price - (eff_atr * sl_mult);
    } else {              // POS_SHORT
        sl_price = entry_price + (eff_atr * sl_mult);
    }

    // ── 5. Breakeven Stop ────────────────────────────────────────────────
    // If profit exceeds breakeven_start_atr ATRs, move SL to
    // entry +/- breakeven_buffer_atr ATRs (protecting at least entry).
    if (cfg.enable_breakeven_stop != 0u && cfg.breakeven_start_atr > 0.0f) {
        double be_start = eff_atr * (double)cfg.breakeven_start_atr;
        double be_buffer = eff_atr * (double)cfg.breakeven_buffer_atr;

        if (pos_type == 1) {  // POS_LONG
            if ((current_price - entry_price) >= be_start) {
                // Only raise SL, never lower it from the breakeven level.
                sl_price = fmax(sl_price, entry_price + be_buffer);
            }
        } else {              // POS_SHORT
            if ((entry_price - current_price) >= be_start) {
                // Only lower SL, never raise it from the breakeven level.
                sl_price = fmin(sl_price, entry_price - be_buffer);
            }
        }
    }

    return sl_price;
}
"#
    .to_string()
}

/// Trailing stop: VBTS/TATP/TSPV/ratchet (AQC-1221)
///
/// Translates `bt-core/src/exits/trailing.rs::compute_trailing()` into a CUDA
/// `__device__` function.  All price arithmetic uses `double` to match AQC-734
/// f64 migration.  Every tunable constant is read from `cfg.` — no hardcoded
/// magic numbers remain except the TATP multiplier (1.0, i.e. "don't tighten").
pub fn compute_trailing_codegen() -> String {
    r#"// Derived from bt-core/src/exits/trailing.rs
// Trailing stop: per-confidence offsets, VBTS, RSI Trend-Guard, TATP, TSPV,
//                weak-trend tightening, ratchet.
// All price math in double precision (AQC-734).
// All tunables read from cfg (no hardcoded trailing params).

__device__ double compute_trailing_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double current_price,
    double atr,
    double current_trailing_sl,
    int confidence,
    double rsi,
    double adx,
    double adx_slope,
    double atr_slope,
    double bb_width_ratio,
    double profit_atr
) {
    // ── ATR fallback (mirrors Rust: if entry_atr <= 0 use 0.5% of entry) ──
    double eff_atr = (atr > 0.0) ? atr : (entry_price * 0.005);

    // ── Per-confidence overrides for trailing start / distance ─────────────
    double trailing_start = (double)cfg.trailing_start_atr;
    double trailing_dist  = (double)cfg.trailing_distance_atr;

    if (confidence == 0) {  // Confidence::Low == 0
        if (cfg.trailing_start_atr_low_conf > 0.0f) {
            trailing_start = (double)cfg.trailing_start_atr_low_conf;
        }
        if (cfg.trailing_distance_atr_low_conf > 0.0f) {
            trailing_dist = (double)cfg.trailing_distance_atr_low_conf;
        }
    }

    // ── RSI Trend-Guard floor (v5.016) ────────────────────────────────────
    // Minimum effective trailing distance.  Raised when RSI is favourable
    // (trending in the direction of the position).
    double min_trailing_dist = (double)cfg.trailing_rsi_floor_default;
    if (pos_type == POS_LONG && rsi > 60.0) {
        min_trailing_dist = (double)cfg.trailing_rsi_floor_trending;
    }
    if (pos_type == POS_SHORT && rsi < 40.0) {
        min_trailing_dist = (double)cfg.trailing_rsi_floor_trending;
    }

    // ── Effective trailing distance ───────────────────────────────────────
    double effective_dist = trailing_dist;

    // VBTS (Vol-Buffered Trailing Stop, v5.015): widen when BB expanding.
    if (cfg.enable_vol_buffered_trailing != 0u
        && bb_width_ratio > (double)cfg.trailing_vbts_bb_threshold) {
        effective_dist *= (double)cfg.trailing_vbts_mult;
    }

    // High-profit tightening (> cfg threshold ATR) with TATP / TSPV overrides.
    if (profit_atr > (double)cfg.trailing_high_profit_atr) {
        if (adx > 35.0 && adx_slope > 0.0) {
            // TATP: trend accelerating — don't tighten (1.0x).
            effective_dist = trailing_dist * 1.0;
        } else if (atr_slope > 0.0) {
            // TSPV: volatility expanding — partial tighten.
            effective_dist = trailing_dist * (double)cfg.trailing_tighten_tspv;
        } else {
            // Default high-profit tightening.
            effective_dist = trailing_dist * (double)cfg.trailing_tighten_default;
        }
    } else if (adx < 25.0) {
        // Weak-trend tightening.
        effective_dist = trailing_dist * (double)cfg.trailing_weak_trend_mult;
    }

    // Clamp to RSI Trend-Guard floor.
    effective_dist = fmax(effective_dist, min_trailing_dist);

    // ── Activation gate ───────────────────────────────────────────────────
    if (profit_atr < trailing_start) {
        // Not enough profit to activate trailing stop yet.
        // Preserve any existing trailing SL from a previous bar.
        return current_trailing_sl;
    }

    // ── Compute candidate trailing stop price ─────────────────────────────
    double candidate;
    if (pos_type == POS_LONG) {
        candidate = current_price - (eff_atr * effective_dist);
    } else {
        candidate = current_price + (eff_atr * effective_dist);
    }

    // ── Ratchet: only allow the trailing stop to improve ──────────────────
    // A non-positive current_trailing_sl means "no trailing stop yet" (first bar).
    if (current_trailing_sl > 0.0) {
        if (pos_type == POS_LONG) {
            candidate = fmax(candidate, current_trailing_sl);
        } else {
            candidate = fmin(candidate, current_trailing_sl);
        }
    }

    return candidate;
}
"#
    .to_string()
}

/// Take profit: partial TP + full TP ladder (AQC-1222)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/exits/take_profit.rs::check_tp`.
///
/// Returns a `TpResult` struct: `{ int action; double fraction; int exit_code; }`
///   - action 0 = Hold, action 1 = Reduce (partial TP), action 2 = Close (full TP)
///   - fraction: the reduce fraction (only meaningful when action == 1)
///   - exit_code: 0 = no exit, 10 = partial TP, 11 = full TP
///
/// Uses `double` precision for all price arithmetic to match the f64 Rust
/// source and satisfy T2 precision requirements.
///
/// The `tp_mult` parameter is resolved by the caller (confidence-dependent
/// multipliers via `tp_mult_strong`/`tp_mult_weak`, or dynamic gate TP).
pub fn check_tp_codegen() -> String {
    r#"// Derived from bt-core/src/exits/take_profit.rs
// Take profit: full TP + partial TP ladder.
// All price math in double precision (AQC-734).
//
// Partial TP ladder:
//   1. If enable_partial_tp AND tp1_taken == 0 AND price hits partial TP level
//      -> Reduce by tp_partial_pct, caller sets trailing_sl = entry (breakeven)
//   2. If tp1_taken == 1 AND tp_partial_atr_mult > 0 AND price hits full TP
//      -> Close remainder at full TP
//   3. If tp1_taken == 1 AND tp_partial_atr_mult == 0 -> Hold (trailing manages)
//   4. If partial TP disabled or tp_partial_pct >= 1.0 -> full Close
//
// Confidence-dependent TP multipliers (tp_mult_strong for high ADX,
// tp_mult_weak for low ADX) and dynamic gate TP multiplier are resolved
// by the caller via get_tp_mult() before calling this function.

struct TpResult {
    int action;       // 0 = hold, 1 = reduce (partial), 2 = close (full)
    double fraction;  // reduce fraction (meaningful only when action == 1)
    int exit_code;    // 0 = no exit, 10 = partial TP, 11 = full TP
};

__device__ TpResult check_tp_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double entry_atr,
    double current_price,
    double size,
    unsigned int tp1_taken,
    double tp_mult
) {
    TpResult result;
    result.action = 0;
    result.fraction = 0.0;
    result.exit_code = 0;

    // ── ATR fallback (mirrors Rust: if entry_atr <= 0 use 0.5% of entry) ──
    double atr = (entry_atr > 0.0) ? entry_atr : (entry_price * 0.005);

    // ── Full TP price (always based on tp_mult) ────────────────────────────
    double tp_price;
    if (pos_type == POS_LONG) {
        tp_price = entry_price + (atr * tp_mult);
    } else {
        tp_price = entry_price - (atr * tp_mult);
    }

    // ── Partial TP path ────────────────────────────────────────────────────
    if (cfg.enable_partial_tp != 0u) {
        if (tp1_taken == 0u) {
            // Determine partial TP level: use dedicated mult if set,
            // otherwise same as full TP.
            double partial_mult = (cfg.tp_partial_atr_mult > 0.0)
                ? (double)cfg.tp_partial_atr_mult
                : tp_mult;
            double partial_tp_price;
            if (pos_type == POS_LONG) {
                partial_tp_price = entry_price + (atr * partial_mult);
            } else {
                partial_tp_price = entry_price - (atr * partial_mult);
            }
            bool partial_hit;
            if (pos_type == POS_LONG) {
                partial_hit = (current_price >= partial_tp_price);
            } else {
                partial_hit = (current_price <= partial_tp_price);
            }

            if (partial_hit) {
                double pct = fmax(fmin((double)cfg.tp_partial_pct, 1.0), 0.0);

                if (pct > 0.0 && pct < 1.0) {
                    double remaining_notional = size * (1.0 - pct) * current_price;
                    if (remaining_notional < (double)cfg.tp_partial_min_notional_usd) {
                        // Remaining too small — hold instead of partial.
                        return result;  // action=0, hold
                    }

                    // Partial reduce.
                    result.action = 1;
                    result.fraction = pct;
                    result.exit_code = 10;  // partial TP
                    return result;
                }
                // pct == 0 or pct >= 1.0 falls through to full close check.
            } else {
                // Partial TP not hit yet.
                // When tp_partial_atr_mult == 0, partial == full,
                // so full can't be hit either.
                if (cfg.tp_partial_atr_mult <= 0.0f) {
                    return result;  // action=0, hold
                }
                // When tp_partial_atr_mult > 0, fall through to check full TP
                // (handles edge case where partial_mult > tp_mult).
            }
        } else {
            // tp1 already taken.
            if (cfg.tp_partial_atr_mult > 0.0f) {
                // Separate partial level: check if full TP hit for remainder.
                bool tp_hit;
                if (pos_type == POS_LONG) {
                    tp_hit = (current_price >= tp_price);
                } else {
                    tp_hit = (current_price <= tp_price);
                }
                if (tp_hit) {
                    result.action = 2;
                    result.fraction = 1.0;
                    result.exit_code = 11;  // full TP
                    return result;
                }
            }
            // Same level (tp_partial_atr_mult == 0) or full TP not hit:
            // trailing manages.
            return result;  // action=0, hold
        }
    }

    // ── Full TP check (partial TP disabled, or pct edge case) ──────────────
    bool tp_hit;
    if (pos_type == POS_LONG) {
        tp_hit = (current_price >= tp_price);
    } else {
        tp_hit = (current_price <= tp_price);
    }

    if (!tp_hit) {
        return result;  // action=0, hold
    }

    result.action = 2;
    result.fraction = 1.0;
    result.exit_code = 11;  // full TP
    return result;
}
"#
    .to_string()
}

/// Smart exits: all 8 sub-checks (AQC-1223)
pub fn check_smart_exits_codegen() -> String { String::new() /* stub */ }

/// Exit orchestrator: priority dispatch (AQC-1224)
pub fn check_all_exits_codegen() -> String { String::new() /* stub */ }

/// Entry sizing: dynamic sizing/leverage/vol scalar (AQC-1230)
///
/// Generates a CUDA `__device__` function that mirrors
/// `risk-core/src/lib.rs::compute_entry_sizing`.
///
/// Uses `double` precision for all monetary/size calculations to match the f64
/// Rust source and satisfy T2 precision requirements.  Returns a struct with
/// `size`, `margin`, and `leverage` — a local `SizingResultD` definition is
/// emitted to avoid colliding with the hand-written `float` struct in
/// `sweep_engine.cu`.
pub fn compute_entry_size_codegen() -> String {
    r#"// Derived from bt-core/src/engine.rs sizing logic
// (SSOT: risk-core/src/lib.rs::compute_entry_sizing)
//
// Dynamic entry sizing: allocation % * confidence mult * ADX mult * vol scalar.
// Dynamic leverage selects per-confidence leverage with optional max cap.
// All monetary/size arithmetic in double precision (AQC-734).

struct SizingResultD {
    double size;
    double margin;
    double leverage;
};

__device__ SizingResultD compute_entry_size_codegen(
    double equity,
    double price,
    unsigned int confidence,
    double atr,
    double adx,
    const GpuComboConfig& cfg
) {
    // ── Base margin allocation ───────────────────────────────────────────
    double margin = equity * (double)cfg.allocation_pct;

    // ── Dynamic sizing (confidence * ADX * volatility) ──────────────────
    if (cfg.enable_dynamic_sizing != 0u) {
        // Confidence multiplier
        double conf_mult = (double)cfg.confidence_mult_medium;
        if (confidence == CONF_HIGH) { conf_mult = (double)cfg.confidence_mult_high; }
        if (confidence == CONF_LOW)  { conf_mult = (double)cfg.confidence_mult_low; }

        // ADX multiplier — linearly scales [min_mult, 1.0] over [0, full_adx]
        double adx_ratio = adx / (double)cfg.adx_sizing_full_adx;
        double adx_mult = fmax(fmin(adx_ratio, 1.0), (double)cfg.adx_sizing_min_mult);

        // Volatility scalar — inverse of vol_ratio, clamped to [min, max]
        double vol_scalar = 1.0;
        if ((double)cfg.vol_baseline_pct > 0.0 && price > 0.0) {
            double vol_ratio = (atr / price) / (double)cfg.vol_baseline_pct;
            if (vol_ratio > 0.0) {
                vol_scalar = fmax(fmin(1.0 / vol_ratio, (double)cfg.vol_scalar_max),
                                  (double)cfg.vol_scalar_min);
            }
        }

        margin *= conf_mult * adx_mult * vol_scalar;
    }

    // ── Leverage ─────────────────────────────────────────────────────────
    double lev = (double)cfg.leverage;
    if (cfg.enable_dynamic_leverage != 0u) {
        if (confidence == CONF_HIGH)        { lev = (double)cfg.leverage_high; }
        else if (confidence == CONF_MEDIUM) { lev = (double)cfg.leverage_medium; }
        else                                { lev = (double)cfg.leverage_low; }
        if ((double)cfg.leverage_max_cap > 0.0) { lev = fmin(lev, (double)cfg.leverage_max_cap); }
    }

    // ── Notional & position size ─────────────────────────────────────────
    double notional = margin * lev;
    double size = 0.0;
    if (price > 0.0) { size = notional / price; }

    SizingResultD result;
    result.size = size;
    result.margin = margin;
    result.leverage = lev;
    return result;
}
"#
    .to_string()
}

/// PESC cooldown: reentry cooldown + ADX interpolation (AQC-1231)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/engine.rs::is_pesc_blocked`.
///
/// ADX-adaptive cooldown: ADX 25..40 linearly interpolates between
/// max_cd (weak trend = longer cooldown) and min_cd (strong trend = shorter).
/// All ADX arithmetic uses `double` to match the f64 Rust source.
/// Time arithmetic uses `unsigned int` seconds (GPU convention).
pub fn is_pesc_blocked_codegen() -> String {
    r#"// Derived from bt-core/src/engine.rs PESC cooldown logic
// Post-Exit Same-Direction Cooldown: prevents re-entry in the same direction
// too soon after an exit, with ADX-adaptive interpolation of cooldown duration.
//
// Gate chain:
//   1. reentry_cooldown_minutes == 0 -> disabled
//   2. No prior close recorded      -> not blocked
//   3. Signal flip exit reason       -> not blocked (direction changed)
//   4. Different direction           -> not blocked
//   5. ADX-interpolated cooldown     -> blocked if elapsed < cooldown

__device__ bool is_pesc_blocked_codegen(
    const GpuComboConfig& cfg,
    int bars_since_exit,
    double adx,
    unsigned int close_ts,
    unsigned int close_reason,
    unsigned int close_type,
    unsigned int desired_type,
    unsigned int current_sec
) {
    // Gate 1: PESC disabled when reentry_cooldown_minutes == 0
    if (cfg.reentry_cooldown_minutes == 0u) { return false; }

    // Gate 2: no prior close recorded for this symbol
    if (close_ts == 0u) { return false; }

    // Gate 3: no cooldown after signal flips (PESC_SIGNAL_FLIP == 2)
    if (close_reason == 2u) { return false; }

    // Gate 4: only block same-direction re-entry
    if (close_type != desired_type) { return false; }

    // ADX-adaptive cooldown interpolation
    double min_cd = (double)(cfg.reentry_cooldown_min_mins);
    double max_cd = (double)(cfg.reentry_cooldown_max_mins);

    double cooldown_mins;
    if (adx >= 40.0) {
        // Strong trend: use minimum cooldown
        cooldown_mins = min_cd;
    } else if (adx <= 25.0) {
        // Weak trend: use maximum cooldown
        cooldown_mins = max_cd;
    } else {
        // Linear interpolation: ADX 25->40 maps max_cd->min_cd
        double t = (adx - 25.0) / 15.0;
        cooldown_mins = max_cd + t * (min_cd - max_cd);
    }

    unsigned int cooldown_sec = (unsigned int)(cooldown_mins * 60.0);
    unsigned int elapsed = current_sec - close_ts;
    return elapsed < cooldown_sec;
}
"#
    .to_string()
}

// ═══════════════════════════════════════════════════════════════════════════
// Tests
// ═══════════════════════════════════════════════════════════════════════════

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sl_codegen_has_correct_function_signature() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("__device__ double compute_sl_price_codegen("),
            "must declare a __device__ double function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(
            src.contains("int pos_type"),
            "must take pos_type as int"
        );
        assert!(
            src.contains("double entry_price"),
            "must take entry_price as double"
        );
        assert!(
            src.contains("double atr"),
            "must take atr as double"
        );
        assert!(
            src.contains("double current_price"),
            "must take current_price as double"
        );
        assert!(
            src.contains("double adx"),
            "must take adx as double"
        );
        assert!(
            src.contains("double adx_slope"),
            "must take adx_slope as double"
        );
    }

    #[test]
    fn sl_codegen_uses_double_precision() {
        let src = compute_sl_price_codegen();
        // Return type is double
        assert!(src.contains("__device__ double"));
        // Internal arithmetic uses double variables
        assert!(src.contains("double sl_mult"));
        assert!(src.contains("double sl_price"));
        assert!(src.contains("double eff_atr"));
        assert!(src.contains("double be_start"));
        assert!(src.contains("double be_buffer"));
        // Must NOT use float for price-critical variables
        assert!(
            !src.contains("float sl_price"),
            "sl_price must be double, not float"
        );
        assert!(
            !src.contains("float sl_mult"),
            "sl_mult must be double, not float"
        );
    }

    #[test]
    fn sl_codegen_contains_ase_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("ASE"), "must have ASE comment marker");
        assert!(
            src.contains("adx_slope < 0.0"),
            "ASE checks for negative ADX slope"
        );
        assert!(
            src.contains("is_underwater"),
            "ASE checks underwater condition"
        );
        assert!(src.contains("*= 0.8"), "ASE tightens by 20% (x0.80)");
    }

    #[test]
    fn sl_codegen_contains_dase_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("DASE"), "must have DASE comment marker");
        assert!(
            src.contains("adx > 40.0"),
            "DASE triggers when ADX > 40"
        );
        assert!(
            src.contains("profit_in_atr"),
            "DASE computes profit in ATR units"
        );
        assert!(
            src.contains("profit_in_atr > 0.5"),
            "DASE requires > 0.5 ATR profit"
        );
        assert!(src.contains("*= 1.15"), "DASE widens by 15% (x1.15)");
    }

    #[test]
    fn sl_codegen_contains_slb_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("SLB"), "must have SLB comment marker");
        assert!(
            src.contains("adx > 45.0"),
            "SLB triggers when ADX > 45"
        );
        assert!(src.contains("*= 1.10"), "SLB widens by 10% (x1.10)");
    }

    #[test]
    fn sl_codegen_contains_breakeven_logic() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("Breakeven"),
            "must have Breakeven comment marker"
        );
        assert!(
            src.contains("cfg.enable_breakeven_stop"),
            "breakeven checks enable flag from config"
        );
        assert!(
            src.contains("cfg.breakeven_start_atr"),
            "breakeven uses start ATR threshold from config"
        );
        assert!(
            src.contains("cfg.breakeven_buffer_atr"),
            "breakeven uses buffer ATR from config"
        );
        assert!(
            src.contains("fmax(sl_price, entry_price + be_buffer)"),
            "long breakeven raises SL via fmax"
        );
        assert!(
            src.contains("fmin(sl_price, entry_price - be_buffer)"),
            "short breakeven lowers SL via fmin"
        );
    }

    #[test]
    fn sl_codegen_uses_correct_config_fields() {
        let src = compute_sl_price_codegen();
        // All config field accesses must use GpuComboConfig field names
        assert!(src.contains("cfg.sl_atr_mult"), "must use cfg.sl_atr_mult");
        assert!(
            src.contains("cfg.enable_breakeven_stop"),
            "must use cfg.enable_breakeven_stop"
        );
        assert!(
            src.contains("cfg.breakeven_start_atr"),
            "must use cfg.breakeven_start_atr"
        );
        assert!(
            src.contains("cfg.breakeven_buffer_atr"),
            "must use cfg.breakeven_buffer_atr"
        );
    }

    #[test]
    fn sl_codegen_uses_fmax_fmin_not_std_max() {
        let src = compute_sl_price_codegen();
        // Must use CUDA fmax/fmin, not std::max/std::min
        assert!(src.contains("fmax("), "must use fmax for CUDA");
        assert!(src.contains("fmin("), "must use fmin for CUDA");
        assert!(
            !src.contains("std::max"),
            "must not use std::max (use fmax for CUDA)"
        );
        assert!(
            !src.contains("std::min"),
            "must not use std::min (use fmin for CUDA)"
        );
    }

    #[test]
    fn sl_codegen_has_long_short_direction() {
        let src = compute_sl_price_codegen();
        // Long: SL below entry (entry - atr * mult)
        assert!(
            src.contains("entry_price - (eff_atr * sl_mult)"),
            "long SL = entry - atr * mult"
        );
        // Short: SL above entry (entry + atr * mult)
        assert!(
            src.contains("entry_price + (eff_atr * sl_mult)"),
            "short SL = entry + atr * mult"
        );
    }

    #[test]
    fn sl_codegen_has_atr_fallback() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("entry_price * 0.005"),
            "must have ATR fallback for legacy positions"
        );
    }

    #[test]
    fn sl_codegen_has_source_comment() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/stop_loss.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn sl_codegen_pos_type_uses_integer_constants() {
        let src = compute_sl_price_codegen();
        // Must use integer comparison, not enum
        assert!(
            src.contains("pos_type == 1"),
            "long check must use pos_type == 1 (POS_LONG)"
        );
    }

    // -- check_gates_codegen tests (AQC-1210) ----------------------------------

    #[test]
    fn gates_codegen_has_correct_function_signature() {
        let src = check_gates_codegen();
        assert!(
            src.contains("__device__ GateResultD check_gates_codegen("),
            "must declare a __device__ GateResultD function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(
            src.contains("double rsi"),
            "must take rsi as double"
        );
        assert!(
            src.contains("double adx"),
            "must take adx as double"
        );
        assert!(
            src.contains("double adx_slope"),
            "must take adx_slope as double"
        );
        assert!(
            src.contains("double bb_width_ratio"),
            "must take bb_width_ratio as double"
        );
        assert!(
            src.contains("double ema_fast"),
            "must take ema_fast as double"
        );
        assert!(
            src.contains("double ema_slow"),
            "must take ema_slow as double"
        );
        assert!(
            src.contains("double ema_macro"),
            "must take ema_macro as double"
        );
        assert!(
            src.contains("double close"),
            "must take close as double"
        );
        assert!(
            src.contains("double prev_close"),
            "must take prev_close as double"
        );
        assert!(
            src.contains("double volume"),
            "must take volume as double"
        );
        assert!(
            src.contains("double vol_sma"),
            "must take vol_sma as double"
        );
        assert!(
            src.contains("double atr"),
            "must take atr as double"
        );
        assert!(
            src.contains("double avg_atr"),
            "must take avg_atr as double"
        );
        assert!(
            src.contains("double stoch_rsi_k"),
            "must take stoch_rsi_k as double"
        );
        assert!(
            src.contains("double ema_slow_slope_pct"),
            "must take ema_slow_slope_pct as double"
        );
    }

    #[test]
    fn gates_codegen_has_source_comment() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Derived from bt-signals/src/gates.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn gates_codegen_has_gate_result_struct() {
        let src = check_gates_codegen();
        assert!(
            src.contains("struct GateResultD"),
            "must define GateResultD struct"
        );
        assert!(
            src.contains("bool all_gates_pass"),
            "GateResultD must have all_gates_pass field"
        );
        assert!(
            src.contains("bool is_ranging"),
            "GateResultD must have is_ranging field"
        );
        assert!(
            src.contains("bool is_anomaly"),
            "GateResultD must have is_anomaly field"
        );
        assert!(
            src.contains("bool is_extended"),
            "GateResultD must have is_extended field"
        );
        assert!(
            src.contains("bool vol_confirm"),
            "GateResultD must have vol_confirm field"
        );
        assert!(
            src.contains("bool is_trending_up"),
            "GateResultD must have is_trending_up field"
        );
        assert!(
            src.contains("bool adx_above_min"),
            "GateResultD must have adx_above_min field"
        );
        assert!(
            src.contains("bool bullish_alignment"),
            "GateResultD must have bullish_alignment field"
        );
        assert!(
            src.contains("bool bearish_alignment"),
            "GateResultD must have bearish_alignment field"
        );
        assert!(
            src.contains("double effective_min_adx"),
            "GateResultD must have effective_min_adx as double"
        );
        assert!(
            src.contains("double rsi_long_limit"),
            "GateResultD must have rsi_long_limit as double"
        );
        assert!(
            src.contains("double rsi_short_limit"),
            "GateResultD must have rsi_short_limit as double"
        );
    }

    #[test]
    fn gates_codegen_uses_double_precision() {
        let src = check_gates_codegen();
        // Internal arithmetic uses double variables
        assert!(src.contains("double price_change_pct"), "price_change_pct must be double");
        assert!(src.contains("double ema_dev_pct"), "ema_dev_pct must be double");
        assert!(src.contains("double dist"), "dist (extension) must be double");
        assert!(src.contains("double effective_min_adx"), "effective_min_adx must be double");
        assert!(src.contains("double saturation"), "saturation must be double");
        assert!(src.contains("double atr_ratio"), "atr_ratio must be double");
        assert!(src.contains("double weight"), "DRE weight must be double");
        assert!(src.contains("double rsi_long_weak"), "DRE rsi_long_weak must be double");
        assert!(src.contains("double rsi_short_weak"), "DRE rsi_short_weak must be double");
        // Must NOT use float for indicator-critical variables
        assert!(
            !src.contains("float price_change_pct"),
            "price_change_pct must be double, not float"
        );
        assert!(
            !src.contains("float effective_min_adx"),
            "effective_min_adx must be double, not float"
        );
    }

    #[test]
    fn gates_codegen_contains_ranging_filter() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 1") || src.contains("Ranging filter"),
            "must have ranging filter comment marker"
        );
        assert!(
            src.contains("cfg.enable_ranging_filter"),
            "must check enable_ranging_filter config flag"
        );
        assert!(
            src.contains("cfg.ranging_adx_lt"),
            "must use ranging_adx_lt from config"
        );
        assert!(
            src.contains("cfg.ranging_bb_width_ratio_lt"),
            "must use ranging_bb_width_ratio_lt from config"
        );
        assert!(
            src.contains("cfg.ranging_rsi_low"),
            "must use ranging_rsi_low from config"
        );
        assert!(
            src.contains("cfg.ranging_rsi_high"),
            "must use ranging_rsi_high from config"
        );
        assert!(
            src.contains("cfg.ranging_min_signals"),
            "must use ranging_min_signals from config"
        );
        assert!(
            src.contains("votes"),
            "ranging filter must use vote counting"
        );
    }

    #[test]
    fn gates_codegen_contains_anomaly_filter() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 2") || src.contains("Anomaly filter"),
            "must have anomaly filter comment marker"
        );
        assert!(
            src.contains("cfg.enable_anomaly_filter"),
            "must check enable_anomaly_filter config flag"
        );
        assert!(
            src.contains("cfg.anomaly_price_change_pct"),
            "must use anomaly_price_change_pct from config"
        );
        assert!(
            src.contains("cfg.anomaly_ema_dev_pct"),
            "must use anomaly_ema_dev_pct from config"
        );
        assert!(
            src.contains("price_change_pct"),
            "must compute price_change_pct"
        );
        assert!(
            src.contains("ema_dev_pct"),
            "must compute ema_dev_pct"
        );
    }

    #[test]
    fn gates_codegen_contains_extension_filter() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 3") || src.contains("Extension filter"),
            "must have extension filter comment marker"
        );
        assert!(
            src.contains("cfg.enable_extension_filter"),
            "must check enable_extension_filter config flag"
        );
        assert!(
            src.contains("cfg.max_dist_ema_fast"),
            "must use max_dist_ema_fast from config"
        );
    }

    #[test]
    fn gates_codegen_contains_volume_confirmation() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 4") || src.contains("Volume confirmation"),
            "must have volume confirmation comment marker"
        );
        assert!(
            src.contains("cfg.require_volume_confirmation"),
            "must check require_volume_confirmation config flag"
        );
        assert!(
            src.contains("cfg.vol_confirm_include_prev"),
            "must check vol_confirm_include_prev config flag"
        );
        assert!(
            src.contains("vol_trend"),
            "volume confirmation must check vol_trend"
        );
    }

    #[test]
    fn gates_codegen_contains_adx_rising() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 5") || src.contains("ADX rising"),
            "must have ADX rising comment marker"
        );
        assert!(
            src.contains("cfg.require_adx_rising"),
            "must check require_adx_rising config flag"
        );
        assert!(
            src.contains("cfg.adx_rising_saturation"),
            "must use adx_rising_saturation from config"
        );
        assert!(
            src.contains("adx_slope > 0.0"),
            "ADX rising checks for positive ADX slope"
        );
    }

    #[test]
    fn gates_codegen_contains_tmc_logic() {
        let src = check_gates_codegen();
        assert!(
            src.contains("TMC") || src.contains("Trend Momentum"),
            "must have TMC comment marker"
        );
        assert!(
            src.contains("adx_slope > 0.5"),
            "TMC checks ADX slope > 0.5"
        );
        assert!(
            src.contains("fmin(effective_min_adx, 25.0)"),
            "TMC caps effective_min_adx at 25.0"
        );
    }

    #[test]
    fn gates_codegen_contains_ave_logic() {
        let src = check_gates_codegen();
        assert!(
            src.contains("AVE") || src.contains("Adaptive Volatility"),
            "must have AVE comment marker"
        );
        assert!(
            src.contains("cfg.ave_enabled"),
            "must check ave_enabled config flag"
        );
        assert!(
            src.contains("cfg.ave_atr_ratio_gt"),
            "must use ave_atr_ratio_gt from config"
        );
        assert!(
            src.contains("cfg.ave_adx_mult"),
            "must use ave_adx_mult from config"
        );
        assert!(
            src.contains("atr_ratio"),
            "AVE must compute atr_ratio"
        );
        assert!(
            src.contains("effective_min_adx *="),
            "AVE must multiply effective_min_adx"
        );
    }

    #[test]
    fn gates_codegen_contains_adx_threshold() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 6") || src.contains("ADX threshold"),
            "must have ADX threshold comment marker"
        );
        assert!(
            src.contains("cfg.min_adx"),
            "must use min_adx from config"
        );
        assert!(
            src.contains("adx > effective_min_adx"),
            "must check adx against effective_min_adx"
        );
    }

    #[test]
    fn gates_codegen_contains_macro_alignment() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 7") || src.contains("Macro alignment"),
            "must have macro alignment comment marker"
        );
        assert!(
            src.contains("cfg.require_macro_alignment"),
            "must check require_macro_alignment config flag"
        );
        assert!(
            src.contains("ema_slow > ema_macro"),
            "bullish macro alignment checks ema_slow > ema_macro"
        );
        assert!(
            src.contains("ema_slow < ema_macro"),
            "bearish macro alignment checks ema_slow < ema_macro"
        );
    }

    #[test]
    fn gates_codegen_contains_slow_drift_override() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Slow-drift") || src.contains("slow_drift"),
            "must have slow-drift override reference"
        );
        assert!(
            src.contains("cfg.enable_slow_drift_entries"),
            "must check enable_slow_drift_entries config flag"
        );
        assert!(
            src.contains("cfg.slow_drift_ranging_slope_override"),
            "must use slow_drift_ranging_slope_override from config"
        );
        assert!(
            src.contains("ema_slow_slope_pct"),
            "slow-drift checks ema_slow_slope_pct"
        );
    }

    #[test]
    fn gates_codegen_contains_dre_logic() {
        let src = check_gates_codegen();
        assert!(
            src.contains("DRE") || src.contains("Dynamic RSI Elasticity"),
            "must have DRE comment marker"
        );
        assert!(
            src.contains("cfg.dre_min_adx"),
            "must use dre_min_adx from config"
        );
        assert!(
            src.contains("cfg.dre_max_adx"),
            "must use dre_max_adx from config"
        );
        assert!(
            src.contains("cfg.dre_long_rsi_limit_low"),
            "must use dre_long_rsi_limit_low from config"
        );
        assert!(
            src.contains("cfg.dre_long_rsi_limit_high"),
            "must use dre_long_rsi_limit_high from config"
        );
        assert!(
            src.contains("cfg.dre_short_rsi_limit_low"),
            "must use dre_short_rsi_limit_low from config"
        );
        assert!(
            src.contains("cfg.dre_short_rsi_limit_high"),
            "must use dre_short_rsi_limit_high from config"
        );
        assert!(
            src.contains("weight"),
            "DRE must compute interpolation weight"
        );
        assert!(
            src.contains("rsi_long_limit"),
            "DRE must compute rsi_long_limit"
        );
        assert!(
            src.contains("rsi_short_limit"),
            "DRE must compute rsi_short_limit"
        );
    }

    #[test]
    fn gates_codegen_contains_combined_check() {
        let src = check_gates_codegen();
        assert!(
            src.contains("result.adx_above_min"),
            "combined check must include adx_above_min"
        );
        assert!(
            src.contains("!result.is_ranging"),
            "combined check must require not ranging"
        );
        assert!(
            src.contains("!result.is_anomaly"),
            "combined check must require not anomaly"
        );
        assert!(
            src.contains("!result.is_extended"),
            "combined check must require not extended"
        );
        assert!(
            src.contains("result.vol_confirm"),
            "combined check must require vol_confirm"
        );
        assert!(
            src.contains("result.is_trending_up"),
            "combined check must require is_trending_up"
        );
    }

    #[test]
    fn gates_codegen_uses_fabs_not_std() {
        let src = check_gates_codegen();
        assert!(
            src.contains("fabs("),
            "must use fabs for CUDA double absolute value"
        );
        assert!(
            !src.contains("std::abs"),
            "must not use std::abs (use fabs for CUDA)"
        );
        assert!(
            !src.contains("std::max"),
            "must not use std::max (use fmax for CUDA)"
        );
        assert!(
            !src.contains("std::min"),
            "must not use std::min (use fmin for CUDA)"
        );
    }

    #[test]
    fn gates_codegen_uses_fmax_fmin() {
        let src = check_gates_codegen();
        assert!(src.contains("fmax("), "must use fmax for CUDA double math");
        assert!(src.contains("fmin("), "must use fmin for CUDA double math");
    }

    #[test]
    fn gates_codegen_uses_correct_config_fields() {
        let src = check_gates_codegen();
        // Gate toggle flags
        assert!(src.contains("cfg.enable_ranging_filter"), "must use enable_ranging_filter");
        assert!(src.contains("cfg.enable_anomaly_filter"), "must use enable_anomaly_filter");
        assert!(src.contains("cfg.enable_extension_filter"), "must use enable_extension_filter");
        assert!(src.contains("cfg.require_adx_rising"), "must use require_adx_rising");
        assert!(src.contains("cfg.require_volume_confirmation"), "must use require_volume_confirmation");
        assert!(src.contains("cfg.require_macro_alignment"), "must use require_macro_alignment");
        assert!(src.contains("cfg.enable_slow_drift_entries"), "must use enable_slow_drift_entries");
        // Threshold fields
        assert!(src.contains("cfg.min_adx"), "must use min_adx");
        assert!(src.contains("cfg.max_dist_ema_fast"), "must use max_dist_ema_fast");
        assert!(src.contains("cfg.adx_rising_saturation"), "must use adx_rising_saturation");
        assert!(src.contains("cfg.ave_enabled"), "must use ave_enabled");
        assert!(src.contains("cfg.ave_atr_ratio_gt"), "must use ave_atr_ratio_gt");
        assert!(src.contains("cfg.ave_adx_mult"), "must use ave_adx_mult");
    }

    #[test]
    fn gates_codegen_is_nonempty() {
        let src = check_gates_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- compute_trailing_codegen tests (AQC-1221) ----------------------------

    #[test]
    fn trailing_codegen_contains_function_signature() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("__device__ double compute_trailing_codegen("),
            "must emit __device__ double function signature"
        );
    }

    #[test]
    fn trailing_codegen_contains_source_comment() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/trailing.rs"),
            "must have provenance comment"
        );
    }

    #[test]
    fn trailing_codegen_uses_double_precision() {
        let src = compute_trailing_codegen();
        assert!(src.contains("double trailing_start"), "trailing_start must be double");
        assert!(src.contains("double trailing_dist"), "trailing_dist must be double");
        assert!(src.contains("double effective_dist"), "effective_dist must be double");
        assert!(src.contains("double candidate"), "candidate must be double");
        assert!(src.contains("double eff_atr"), "eff_atr must be double");
        assert!(src.contains("double min_trailing_dist"), "min_trailing_dist must be double");
    }

    #[test]
    fn trailing_codegen_reads_config_not_hardcoded() {
        let src = compute_trailing_codegen();
        assert!(src.contains("cfg.trailing_start_atr"), "trailing_start from config");
        assert!(src.contains("cfg.trailing_distance_atr"), "trailing_distance from config");
        assert!(src.contains("cfg.trailing_start_atr_low_conf"), "low_conf start from config");
        assert!(src.contains("cfg.trailing_distance_atr_low_conf"), "low_conf dist from config");
        assert!(src.contains("cfg.trailing_rsi_floor_default"), "RSI floor default from config");
        assert!(src.contains("cfg.trailing_rsi_floor_trending"), "RSI floor trending from config");
        assert!(src.contains("cfg.enable_vol_buffered_trailing"), "VBTS enable from config");
        assert!(src.contains("cfg.trailing_vbts_bb_threshold"), "VBTS BB threshold from config");
        assert!(src.contains("cfg.trailing_vbts_mult"), "VBTS mult from config");
        assert!(src.contains("cfg.trailing_high_profit_atr"), "high profit threshold from config");
        assert!(src.contains("cfg.trailing_tighten_tspv"), "TSPV tighten from config");
        assert!(src.contains("cfg.trailing_tighten_default"), "default tighten from config");
        assert!(src.contains("cfg.trailing_weak_trend_mult"), "weak trend mult from config");
    }

    #[test]
    fn trailing_codegen_contains_vbts_logic() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("VBTS") || src.contains("Vol-Buffered"),
            "must contain VBTS reference"
        );
        assert!(src.contains("bb_width_ratio"), "VBTS must check bb_width_ratio");
    }

    #[test]
    fn trailing_codegen_contains_ratchet_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("Ratchet") || src.contains("ratchet"), "must contain ratchet");
        assert!(src.contains("fmax(candidate"), "LONG ratchet uses fmax");
        assert!(src.contains("fmin(candidate"), "SHORT ratchet uses fmin");
    }

    #[test]
    fn trailing_codegen_contains_rsi_trend_guard() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("RSI Trend-Guard") || src.contains("rsi_floor"),
            "must reference RSI Trend-Guard"
        );
        assert!(src.contains("rsi > 60.0"), "LONG RSI favourability check");
        assert!(src.contains("rsi < 40.0"), "SHORT RSI favourability check");
    }

    #[test]
    fn trailing_codegen_contains_tatp_tspv_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("TATP"), "must reference TATP");
        assert!(src.contains("TSPV"), "must reference TSPV");
        assert!(src.contains("adx_slope"), "TATP checks adx_slope");
        assert!(src.contains("atr_slope"), "TSPV checks atr_slope");
    }

    #[test]
    fn trailing_codegen_contains_weak_trend_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("adx < 25.0"), "weak-trend check on adx < 25");
        assert!(src.contains("trailing_weak_trend_mult"), "weak-trend uses config mult");
    }

    #[test]
    fn trailing_codegen_contains_activation_gate() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("profit_atr < trailing_start"),
            "activation gate: profit must exceed trailing_start"
        );
        assert!(
            src.contains("return current_trailing_sl"),
            "when not active, preserve existing trailing SL"
        );
    }

    #[test]
    fn trailing_codegen_handles_low_confidence() {
        let src = compute_trailing_codegen();
        assert!(src.contains("confidence == 0"), "Low confidence mapped to 0");
    }

    #[test]
    fn trailing_codegen_handles_no_existing_trailing_sl() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("current_trailing_sl > 0.0"),
            "must check for no existing trailing SL (first computation)"
        );
    }

    #[test]
    fn trailing_codegen_uses_fmax_fmin() {
        let src = compute_trailing_codegen();
        assert!(src.contains("fmax("), "must use fmax for CUDA double math");
        assert!(src.contains("fmin("), "must use fmin for CUDA double math");
    }

    #[test]
    fn trailing_codegen_is_nonempty() {
        let src = compute_trailing_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- check_tp_codegen tests (AQC-1222) ------------------------------------

    #[test]
    fn tp_codegen_has_correct_function_signature() {
        let src = check_tp_codegen();
        assert!(
            src.contains("__device__ TpResult check_tp_codegen("),
            "must declare a __device__ TpResult function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(
            src.contains("int pos_type"),
            "must take pos_type as int"
        );
        assert!(
            src.contains("double entry_price"),
            "must take entry_price as double"
        );
        assert!(
            src.contains("double entry_atr"),
            "must take entry_atr as double"
        );
        assert!(
            src.contains("double current_price"),
            "must take current_price as double"
        );
        assert!(
            src.contains("double size"),
            "must take size as double"
        );
        assert!(
            src.contains("unsigned int tp1_taken"),
            "must take tp1_taken as unsigned int"
        );
        assert!(
            src.contains("double tp_mult"),
            "must take tp_mult as double"
        );
    }

    #[test]
    fn tp_codegen_has_source_comment() {
        let src = check_tp_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/take_profit.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn tp_codegen_uses_double_precision() {
        let src = check_tp_codegen();
        // Return struct fields
        assert!(src.contains("double fraction"), "fraction must be double");
        // Internal arithmetic uses double variables
        assert!(src.contains("double atr"), "atr must be double");
        assert!(src.contains("double tp_price"), "tp_price must be double");
        assert!(src.contains("double partial_mult"), "partial_mult must be double");
        assert!(src.contains("double partial_tp_price"), "partial_tp_price must be double");
        assert!(src.contains("double pct"), "pct must be double");
        assert!(src.contains("double remaining_notional"), "remaining_notional must be double");
        // Must NOT use float for price-critical variables
        assert!(
            !src.contains("float tp_price"),
            "tp_price must be double, not float"
        );
        assert!(
            !src.contains("float partial_tp_price"),
            "partial_tp_price must be double, not float"
        );
    }

    #[test]
    fn tp_codegen_contains_partial_tp_logic() {
        let src = check_tp_codegen();
        assert!(
            src.contains("Partial TP") || src.contains("partial TP"),
            "must have partial TP comment marker"
        );
        assert!(
            src.contains("cfg.enable_partial_tp"),
            "must check enable_partial_tp config flag"
        );
        assert!(
            src.contains("tp1_taken == 0u"),
            "must check tp1_taken flag for first partial"
        );
        assert!(
            src.contains("partial_hit"),
            "must compute partial_hit condition"
        );
        assert!(
            src.contains("result.action = 1"),
            "partial TP must set action = 1 (reduce)"
        );
        assert!(
            src.contains("result.fraction = pct"),
            "partial TP must set fraction to pct"
        );
        assert!(
            src.contains("result.exit_code = 10"),
            "partial TP must set exit_code = 10"
        );
    }

    #[test]
    fn tp_codegen_contains_full_tp_logic() {
        let src = check_tp_codegen();
        assert!(
            src.contains("Full TP") || src.contains("full TP"),
            "must have full TP comment marker"
        );
        assert!(
            src.contains("result.action = 2"),
            "full TP must set action = 2 (close)"
        );
        assert!(
            src.contains("result.exit_code = 11"),
            "full TP must set exit_code = 11"
        );
        assert!(
            src.contains("tp_hit"),
            "must compute tp_hit condition for full TP"
        );
    }

    #[test]
    fn tp_codegen_uses_correct_config_fields() {
        let src = check_tp_codegen();
        assert!(
            src.contains("cfg.enable_partial_tp"),
            "must use cfg.enable_partial_tp"
        );
        assert!(
            src.contains("cfg.tp_partial_pct"),
            "must use cfg.tp_partial_pct"
        );
        assert!(
            src.contains("cfg.tp_partial_atr_mult"),
            "must use cfg.tp_partial_atr_mult"
        );
        assert!(
            src.contains("cfg.tp_partial_min_notional_usd"),
            "must use cfg.tp_partial_min_notional_usd"
        );
    }

    #[test]
    fn tp_codegen_has_atr_fallback() {
        let src = check_tp_codegen();
        assert!(
            src.contains("entry_price * 0.005"),
            "must have ATR fallback for legacy positions"
        );
    }

    #[test]
    fn tp_codegen_has_notional_check() {
        let src = check_tp_codegen();
        assert!(
            src.contains("remaining_notional"),
            "must compute remaining notional for partial TP min check"
        );
        assert!(
            src.contains("tp_partial_min_notional_usd"),
            "must check minimum notional threshold"
        );
    }

    #[test]
    fn tp_codegen_handles_tp1_taken() {
        let src = check_tp_codegen();
        assert!(
            src.contains("tp1_taken == 0u"),
            "must check tp1_taken for first partial TP"
        );
        assert!(
            src.contains("tp1 already taken"),
            "must have comment for tp1 already taken path"
        );
    }

    #[test]
    fn tp_codegen_handles_separate_partial_level() {
        let src = check_tp_codegen();
        // When tp_partial_atr_mult > 0, partial TP fires at a different level
        assert!(
            src.contains("cfg.tp_partial_atr_mult > 0.0"),
            "must check for separate partial mult"
        );
        // When tp_partial_atr_mult == 0, partial == full
        assert!(
            src.contains("cfg.tp_partial_atr_mult <= 0.0"),
            "must handle zero partial mult (legacy)"
        );
    }

    #[test]
    fn tp_codegen_has_long_short_direction() {
        let src = check_tp_codegen();
        // Long: TP above entry (entry + atr * mult)
        assert!(
            src.contains("entry_price + (atr * tp_mult)"),
            "long full TP = entry + atr * mult"
        );
        // Short: TP below entry (entry - atr * mult)
        assert!(
            src.contains("entry_price - (atr * tp_mult)"),
            "short full TP = entry - atr * mult"
        );
    }

    #[test]
    fn tp_codegen_uses_fmax_fmin() {
        let src = check_tp_codegen();
        // Used for clamping tp_partial_pct
        assert!(src.contains("fmax("), "must use fmax for CUDA double math");
        assert!(src.contains("fmin("), "must use fmin for CUDA double math");
    }

    #[test]
    fn tp_codegen_has_tp_result_struct() {
        let src = check_tp_codegen();
        assert!(
            src.contains("struct TpResult"),
            "must define TpResult struct"
        );
        assert!(
            src.contains("int action"),
            "TpResult must have action field"
        );
        assert!(
            src.contains("double fraction"),
            "TpResult must have fraction field"
        );
        assert!(
            src.contains("int exit_code"),
            "TpResult must have exit_code field"
        );
    }

    #[test]
    fn tp_codegen_is_nonempty() {
        let src = check_tp_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- compute_entry_size_codegen tests (AQC-1230) --------------------------

    #[test]
    fn sizing_codegen_has_correct_function_signature() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("__device__ SizingResultD compute_entry_size_codegen("),
            "must declare a __device__ SizingResultD function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(
            src.contains("double equity"),
            "must take equity as double"
        );
        assert!(
            src.contains("double price"),
            "must take price as double"
        );
        assert!(
            src.contains("unsigned int confidence"),
            "must take confidence as unsigned int"
        );
        assert!(
            src.contains("double atr"),
            "must take atr as double"
        );
        assert!(
            src.contains("double adx"),
            "must take adx as double"
        );
    }

    #[test]
    fn sizing_codegen_emits_result_struct() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("struct SizingResultD"),
            "must define SizingResultD struct"
        );
        assert!(
            src.contains("double size;"),
            "SizingResultD must have double size field"
        );
        assert!(
            src.contains("double margin;"),
            "SizingResultD must have double margin field"
        );
        assert!(
            src.contains("double leverage;"),
            "SizingResultD must have double leverage field"
        );
    }

    #[test]
    fn sizing_codegen_uses_double_precision() {
        let src = compute_entry_size_codegen();
        assert!(src.contains("double margin ="), "margin must be double");
        assert!(src.contains("double conf_mult"), "conf_mult must be double");
        assert!(src.contains("double adx_mult"), "adx_mult must be double");
        assert!(src.contains("double vol_scalar"), "vol_scalar must be double");
        assert!(src.contains("double lev"), "lev must be double");
        assert!(src.contains("double notional"), "notional must be double");
        assert!(src.contains("double size"), "size must be double");
        // Must NOT use float for monetary variables
        assert!(
            !src.contains("float margin"),
            "margin must be double, not float"
        );
        assert!(
            !src.contains("float notional"),
            "notional must be double, not float"
        );
    }

    #[test]
    fn sizing_codegen_contains_confidence_multiplier() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.confidence_mult_high"),
            "must use confidence_mult_high from config"
        );
        assert!(
            src.contains("cfg.confidence_mult_medium"),
            "must use confidence_mult_medium from config"
        );
        assert!(
            src.contains("cfg.confidence_mult_low"),
            "must use confidence_mult_low from config"
        );
        assert!(src.contains("CONF_HIGH"), "must check CONF_HIGH");
        assert!(src.contains("CONF_LOW"), "must check CONF_LOW");
    }

    #[test]
    fn sizing_codegen_contains_adx_multiplier() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.adx_sizing_full_adx"),
            "must use adx_sizing_full_adx from config"
        );
        assert!(
            src.contains("cfg.adx_sizing_min_mult"),
            "must use adx_sizing_min_mult from config"
        );
        assert!(
            src.contains("adx_mult"),
            "must compute adx_mult"
        );
    }

    #[test]
    fn sizing_codegen_contains_vol_scalar() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.vol_baseline_pct"),
            "must use vol_baseline_pct from config"
        );
        assert!(
            src.contains("cfg.vol_scalar_min"),
            "must use vol_scalar_min from config"
        );
        assert!(
            src.contains("cfg.vol_scalar_max"),
            "must use vol_scalar_max from config"
        );
        assert!(
            src.contains("vol_ratio"),
            "must compute vol_ratio"
        );
        assert!(
            src.contains("1.0 / vol_ratio"),
            "vol_scalar is inverse of vol_ratio"
        );
    }

    #[test]
    fn sizing_codegen_contains_dynamic_sizing_gate() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.enable_dynamic_sizing != 0u"),
            "must gate dynamic sizing on config flag"
        );
    }

    #[test]
    fn sizing_codegen_contains_dynamic_leverage() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.enable_dynamic_leverage != 0u"),
            "must gate dynamic leverage on config flag"
        );
        assert!(
            src.contains("cfg.leverage_high"),
            "must use leverage_high from config"
        );
        assert!(
            src.contains("cfg.leverage_medium"),
            "must use leverage_medium from config"
        );
        assert!(
            src.contains("cfg.leverage_low"),
            "must use leverage_low from config"
        );
        assert!(
            src.contains("cfg.leverage_max_cap"),
            "must use leverage_max_cap from config"
        );
    }

    #[test]
    fn sizing_codegen_contains_base_leverage_fallback() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.leverage"),
            "must fall back to base leverage when dynamic leverage disabled"
        );
    }

    #[test]
    fn sizing_codegen_contains_notional_and_size() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("margin * lev"),
            "notional = margin * leverage"
        );
        assert!(
            src.contains("notional / price"),
            "size = notional / price"
        );
    }

    #[test]
    fn sizing_codegen_handles_zero_price() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("price > 0.0"),
            "must guard against zero/negative price"
        );
    }

    #[test]
    fn sizing_codegen_uses_allocation_pct() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.allocation_pct"),
            "must use allocation_pct from config"
        );
        assert!(
            src.contains("equity * (double)cfg.allocation_pct"),
            "base margin = equity * allocation_pct"
        );
    }

    #[test]
    fn sizing_codegen_uses_fmax_fmin() {
        let src = compute_entry_size_codegen();
        assert!(src.contains("fmax("), "must use fmax for CUDA");
        assert!(src.contains("fmin("), "must use fmin for CUDA");
        assert!(
            !src.contains("std::max"),
            "must not use std::max (use fmax for CUDA)"
        );
        assert!(
            !src.contains("std::min"),
            "must not use std::min (use fmin for CUDA)"
        );
    }

    #[test]
    fn sizing_codegen_has_source_comment() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("Derived from bt-core/src/engine.rs sizing logic"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn sizing_codegen_applies_multipliers_to_margin() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("margin *= conf_mult * adx_mult * vol_scalar"),
            "dynamic sizing multiplies margin by all three factors"
        );
    }

    #[test]
    fn sizing_codegen_is_nonempty() {
        let src = compute_entry_size_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- is_pesc_blocked_codegen tests (AQC-1231) --------------------------------

    #[test]
    fn pesc_codegen_has_correct_function_signature() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("__device__ bool is_pesc_blocked_codegen("),
            "must declare a __device__ bool function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(
            src.contains("double adx"),
            "must take adx as double"
        );
        assert!(
            src.contains("unsigned int current_sec"),
            "must take current_sec as unsigned int"
        );
        assert!(
            src.contains("unsigned int desired_type"),
            "must take desired_type as unsigned int"
        );
    }

    #[test]
    fn pesc_codegen_has_source_comment() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("Derived from bt-core/src/engine.rs PESC cooldown logic"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn pesc_codegen_has_disable_gate() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("cfg.reentry_cooldown_minutes == 0u"),
            "must check reentry_cooldown_minutes == 0 to disable PESC"
        );
    }

    #[test]
    fn pesc_codegen_has_no_prior_close_gate() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("close_ts == 0u"),
            "must check for no prior close recorded"
        );
    }

    #[test]
    fn pesc_codegen_has_signal_flip_gate() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("close_reason == 2u"),
            "must bypass cooldown for signal flip exits (PESC_SIGNAL_FLIP == 2)"
        );
    }

    #[test]
    fn pesc_codegen_has_direction_gate() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("close_type != desired_type"),
            "must only block same-direction re-entry"
        );
    }

    #[test]
    fn pesc_codegen_has_adx_interpolation() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("adx >= 40.0"),
            "strong trend threshold must be ADX >= 40"
        );
        assert!(
            src.contains("cooldown_mins = min_cd"),
            "strong trend uses min cooldown"
        );
        assert!(
            src.contains("adx <= 25.0"),
            "weak trend threshold must be ADX <= 25"
        );
        assert!(
            src.contains("cooldown_mins = max_cd"),
            "weak trend uses max cooldown"
        );
        assert!(
            src.contains("(adx - 25.0) / 15.0"),
            "must interpolate ADX in [25, 40] range with 15.0 denominator"
        );
        assert!(
            src.contains("max_cd + t * (min_cd - max_cd)"),
            "interpolation formula: max_cd + t * (min_cd - max_cd)"
        );
    }

    #[test]
    fn pesc_codegen_uses_double_for_adx_arithmetic() {
        let src = is_pesc_blocked_codegen();
        assert!(src.contains("double min_cd"), "min_cd must be double");
        assert!(src.contains("double max_cd"), "max_cd must be double");
        assert!(src.contains("double cooldown_mins"), "cooldown_mins must be double");
        assert!(src.contains("double t"), "interpolation factor t must be double");
    }

    #[test]
    fn pesc_codegen_uses_correct_config_fields() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("cfg.reentry_cooldown_minutes"),
            "must use cfg.reentry_cooldown_minutes"
        );
        assert!(
            src.contains("cfg.reentry_cooldown_min_mins"),
            "must use cfg.reentry_cooldown_min_mins"
        );
        assert!(
            src.contains("cfg.reentry_cooldown_max_mins"),
            "must use cfg.reentry_cooldown_max_mins"
        );
    }

    #[test]
    fn pesc_codegen_computes_elapsed_and_compares() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("cooldown_mins * 60.0"),
            "must convert cooldown from minutes to seconds"
        );
        assert!(
            src.contains("current_sec - close_ts"),
            "must compute elapsed seconds"
        );
        assert!(
            src.contains("elapsed < cooldown_sec"),
            "must return true (blocked) when elapsed < cooldown"
        );
    }

    #[test]
    fn pesc_codegen_is_nonempty() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    #[test]
    fn pesc_codegen_returns_bool() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("__device__ bool"),
            "return type must be bool"
        );
        assert!(
            src.contains("return false"),
            "must have early-return false paths for gate bypasses"
        );
        assert!(
            src.contains("return elapsed < cooldown_sec"),
            "final return must compare elapsed vs cooldown"
        );
    }
}
