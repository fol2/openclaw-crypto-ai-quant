//! CUDA code templates for decision logic functions.
//!
//! Each template mirrors the corresponding Rust function in bt-signals and bt-core.
//! Decision logic covers: gates, signals, exits (SL/TSL/TP/smart), sizing, and cooldowns.
//!
//! Templates are stubs (returning empty strings) until their respective tickets implement them:
//! - AQC-1210: check_gates_codegen()
//! - AQC-1211: generate_signal_codegen()
//! - AQC-1220: compute_sl_price_codegen()
//! - AQC-1221: compute_trailing_codegen()
//! - AQC-1222: check_tp_codegen()
//! - AQC-1223: check_smart_exits_codegen()
//! - AQC-1224: check_all_exits_codegen()
//! - AQC-1230: compute_entry_size_codegen()
//! - AQC-1231: is_pesc_blocked_codegen()

/// File header for the generated decision CUDA source.
pub const DECISION_HEADER: &str = "\
// =============================================================================
// AUTO-GENERATED from bt-signals + bt-core kernel source -- DO NOT EDIT
// Generated by bt-gpu/build.rs decision codegen
// =============================================================================
//
// These device functions mirror the Rust decision logic in:
//   bt-signals/src/gates.rs      -- gate evaluation
//   bt-signals/src/entry.rs      -- signal generation
//   bt-core/src/exits/*.rs       -- stop loss, trailing, take profit, smart exits
//   bt-core/src/engine.rs        -- sizing, cooldowns
//
// Source of truth: Rust kernel code. GPU code is derived, not independent.
// =============================================================================

#pragma once
";

// The SOURCE_HASHES line will be injected by the drift detector (AQC-1200)

/// Gates: 8 gates + TMC/AVE + DRE (AQC-1210)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-signals/src/gates.rs::check_gates`.
///
/// Evaluates 8 individual gates (ranging, anomaly, extension, volume,
/// ADX rising, ADX threshold with TMC/AVE, macro alignment, BTC alignment),
/// plus slow-drift ranging override and DRE (Dynamic RSI Elasticity).
///
/// Returns a `GateResultD` struct with `all_gates_pass`, directional alignment
/// flags, DRE RSI limits, and the `effective_min_adx` used.
///
/// All indicator/price math uses `double` precision to match the f64 Rust
/// source and satisfy T2 precision requirements (AQC-734).
pub fn check_gates_codegen() -> String {
    r#"// Derived from bt-signals/src/gates.rs
// Gate evaluation: 8 gates + TMC/AVE + DRE + slow-drift override.
// All indicator/price math in double precision (AQC-734).
// All tunables read from cfg (no hardcoded gate thresholds).

struct GateResultD {
    bool all_gates_pass;
    bool is_ranging;
    bool is_anomaly;
    bool is_extended;
    bool vol_confirm;
    bool is_trending_up;
    bool adx_above_min;
    bool bullish_alignment;
    bool bearish_alignment;
    double effective_min_adx;
    double rsi_long_limit;
    double rsi_short_limit;
};

__device__ GateResultD check_gates_codegen(
    const GpuComboConfig& cfg,
    double rsi,
    double adx,
    double adx_slope,
    double bb_width_ratio,
    double ema_fast,
    double ema_slow,
    double ema_macro,
    double close,
    double prev_close,
    double volume,
    double vol_sma,
    unsigned int vol_trend,
    double atr,
    double avg_atr,
    double stoch_rsi_k,
    double ema_slow_slope_pct,
    unsigned int btc_bullish,      // 0=bearish, 1=bullish, 2=unknown/no-data
    unsigned int is_btc_symbol     // 1 if symbol is BTC
) {
    GateResultD result;
    result.all_gates_pass = false;
    result.is_ranging = false;
    result.is_anomaly = false;
    result.is_extended = false;
    result.vol_confirm = true;
    result.is_trending_up = true;
    result.adx_above_min = false;
    result.bullish_alignment = (ema_fast > ema_slow);
    result.bearish_alignment = (ema_fast < ema_slow);
    result.effective_min_adx = (double)cfg.min_adx;
    result.rsi_long_limit = 0.0;
    result.rsi_short_limit = 0.0;

    // ── Gate 1: Ranging filter (vote system) ─────────────────────────────
    // Python lines 3344-3363; Rust gates.rs Gate 1.
    // Three votes: ADX below threshold, BB width ratio below threshold,
    // RSI in neutral zone.  Ranging if votes >= min_signals.
    if (cfg.enable_ranging_filter != 0u) {
        unsigned int min_signals = cfg.ranging_min_signals;
        if (min_signals < 1u) { min_signals = 1u; }
        unsigned int votes = 0u;

        // Vote 1: ADX below ranging threshold
        if (adx < (double)cfg.ranging_adx_lt) { votes += 1u; }

        // Vote 2: BB width ratio below ranging threshold
        if (bb_width_ratio < (double)cfg.ranging_bb_width_ratio_lt) { votes += 1u; }

        // Vote 3: RSI in neutral zone
        if (rsi > (double)cfg.ranging_rsi_low && rsi < (double)cfg.ranging_rsi_high) { votes += 1u; }

        result.is_ranging = (votes >= min_signals);
    }

    // ── Gate 2: Anomaly filter ───────────────────────────────────────────
    // Python lines 3365-3371; Rust gates.rs Gate 2.
    // Blocks entry when price_change_pct > threshold OR ema_dev_pct > threshold.
    if (cfg.enable_anomaly_filter != 0u) {
        double price_change_pct = 0.0;
        if (prev_close > 0.0) {
            price_change_pct = fabs(close - prev_close) / prev_close;
        }
        double ema_dev_pct = 0.0;
        if (ema_fast > 0.0) {
            ema_dev_pct = fabs(close - ema_fast) / ema_fast;
        }
        result.is_anomaly = (price_change_pct > (double)cfg.anomaly_price_change_pct)
                         || (ema_dev_pct > (double)cfg.anomaly_ema_dev_pct);
    }

    // ── Gate 3: Extension filter (distance from EMA_fast) ────────────────
    // Python lines 3533-3537; Rust gates.rs Gate 3.
    if (cfg.enable_extension_filter != 0u) {
        if (ema_fast > 0.0) {
            double dist = fabs(close - ema_fast) / ema_fast;
            result.is_extended = (dist > (double)cfg.max_dist_ema_fast);
        }
    }

    // ── Gate 4: Volume confirmation ──────────────────────────────────────
    // Python lines 3432-3440; Rust gates.rs Gate 4.
    // When vol_confirm_include_prev: relaxed (vol > vol_sma OR vol_trend).
    // Otherwise strict: (vol > vol_sma) AND vol_trend.
    if (cfg.require_volume_confirmation != 0u) {
        bool vol_above_sma = (volume > vol_sma);
        bool vol_trend_ok = (vol_trend != 0u);
        if (cfg.vol_confirm_include_prev != 0u) {
            result.vol_confirm = vol_above_sma || vol_trend_ok;
        } else {
            result.vol_confirm = vol_above_sma && vol_trend_ok;
        }
    }

    // ── Gate 5: ADX rising (or saturated) ────────────────────────────────
    // Python lines 3426-3430; Rust gates.rs Gate 5.
    if (cfg.require_adx_rising != 0u) {
        double saturation = (double)cfg.adx_rising_saturation;
        result.is_trending_up = (adx_slope > 0.0) || (adx > saturation);
    }

    // ── Gate 6: ADX threshold (effective_min_adx with TMC + AVE) ─────────
    // Python lines 3383-3424; Rust gates.rs Gate 6.
    double effective_min_adx = (double)cfg.min_adx;

    // TMC: Trend Momentum Confirmation (v4.6)
    // If ADX slope > 0.5, cap effective_min_adx at 25.0.
    if (adx_slope > 0.5) {
        effective_min_adx = fmin(effective_min_adx, 25.0);
    }

    // AVE: Adaptive Volatility Entry (v4.7)
    // If ATR / avg_ATR > threshold, multiply effective_min_adx by ave_adx_mult.
    if (cfg.ave_enabled != 0u && avg_atr > 0.0) {
        double atr_ratio = atr / avg_atr;
        if (atr_ratio > (double)cfg.ave_atr_ratio_gt) {
            double mult = ((double)cfg.ave_adx_mult > 0.0)
                ? (double)cfg.ave_adx_mult
                : 1.0;
            effective_min_adx *= mult;
        }
    }

    result.adx_above_min = (adx > effective_min_adx);
    result.effective_min_adx = effective_min_adx;

    // ── Gate 7: Macro alignment (EMA cross + optional macro EMA) ─────────
    // Python lines 3448-3452; Rust gates.rs Gate 7.
    if (cfg.require_macro_alignment != 0u) {
        result.bullish_alignment = result.bullish_alignment && (ema_slow > ema_macro);
        result.bearish_alignment = result.bearish_alignment && (ema_slow < ema_macro);
    }

    // ── Gate 8: BTC alignment (optional) ─────────────────────────────────
    // Python lines 3454-3461; Rust gates.rs Gate 8.
    // btc_bullish: 0=bearish, 1=bullish, 2=unknown/no-data.
    // If is_btc_symbol or btc_bullish unknown or alignment matches, gate passes.
    // High ADX overrides BTC alignment requirement.
    // (btc_ok is not part of all_gates_pass; it is checked per-direction by the
    //  signal generator.  We store the results for the caller.)

    // ── Slow-drift ranging override ──────────────────────────────────────
    // Python lines 3524-3526; Rust gates.rs slow-drift override.
    // If slow drift enabled and EMA_slow slope exceeds threshold, clear ranging.
    if (cfg.enable_slow_drift_entries != 0u
        && result.is_ranging
        && fabs(ema_slow_slope_pct) >= (double)cfg.slow_drift_ranging_slope_override) {
        result.is_ranging = false;
    }

    // ── DRE (Dynamic RSI Elasticity) — v4.1 ─────────────────────────────
    // Python lines 3551-3560; Rust gates.rs DRE.
    // Linear interpolation of RSI limits between weak and strong based on ADX.
    {
        double adx_min_dre = (double)cfg.dre_min_adx;
        double adx_max_dre = (double)cfg.dre_max_adx;
        if (adx_max_dre <= adx_min_dre) {
            adx_max_dre = adx_min_dre + 1.0;
        }
        double weight = (adx - adx_min_dre) / (adx_max_dre - adx_min_dre);
        weight = fmax(fmin(weight, 1.0), 0.0);  // clamp [0, 1]

        double rsi_long_weak  = (double)cfg.dre_long_rsi_limit_low;
        double rsi_long_strong = (double)cfg.dre_long_rsi_limit_high;
        result.rsi_long_limit = rsi_long_weak + weight * (rsi_long_strong - rsi_long_weak);

        double rsi_short_weak  = (double)cfg.dre_short_rsi_limit_low;
        double rsi_short_strong = (double)cfg.dre_short_rsi_limit_high;
        result.rsi_short_limit = rsi_short_weak + weight * (rsi_short_strong - rsi_short_weak);
    }

    // ── Combined check: all gates required for standard trend entry ──────
    // Rust gates.rs: adx_above_min && !ranging && !anomaly && !extended
    //                && vol_confirm && is_trending_up
    result.all_gates_pass = result.adx_above_min
        && !result.is_ranging
        && !result.is_anomaly
        && !result.is_extended
        && result.vol_confirm
        && result.is_trending_up;

    return result;
}
"#
    .to_string()
}

/// Signals: Mode 1/2/3 + MACD helpers (AQC-1211)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-signals/src/entry.rs::generate_signal`.
///
/// Three entry modes in priority order:
///   1. Standard trend entry (all gates pass, DRE RSI, MACD, StochRSI, BTC, volume confidence)
///   2. Pullback continuation (EMA cross, subset gates, MACD sign, RSI range)
///   3. Slow drift (EMA slope grind, subset gates, MACD sign, RSI range)
///
/// Returns a `SignalResult` struct: `{ int signal; int confidence; double effective_min_adx; }`
///   - signal: 0=neutral, 1=buy, 2=sell
///   - confidence: 0=low, 1=medium, 2=high
///   - effective_min_adx: the ADX threshold used by the mode that fired (for entry tracking)
///
/// Uses `double` precision for all indicator/price arithmetic to match the f64 Rust
/// source and satisfy T2 precision requirements (AQC-734).
pub fn generate_signal_codegen() -> String {
    r#"// Derived from bt-signals/src/entry.rs
// Signal generation: Mode 1 (standard trend), Mode 2 (pullback continuation),
// Mode 3 (slow drift).  All indicator math in double precision (AQC-734).
// All config values accessed via cfg. prefix with (double) cast.

struct SignalResult {
    int signal;             // 0=neutral, 1=buy, 2=sell
    int confidence;         // 0=low, 1=medium, 2=high
    double effective_min_adx;  // ADX threshold used by the firing mode
};

// MACD histogram helpers (mirrors bt-signals/src/entry.rs check_macd_long/short)
__device__ bool check_macd_long_codegen(unsigned int mode, double macd_hist, double prev_macd_hist) {
    if (mode == 0u) {  // MACD_ACCEL
        return macd_hist > prev_macd_hist;
    } else if (mode == 1u) {  // MACD_SIGN
        return macd_hist > 0.0;
    }
    // MACD_NONE (mode == 2)
    return true;
}

__device__ bool check_macd_short_codegen(unsigned int mode, double macd_hist, double prev_macd_hist) {
    if (mode == 0u) {  // MACD_ACCEL
        return macd_hist < prev_macd_hist;
    } else if (mode == 1u) {  // MACD_SIGN
        return macd_hist < 0.0;
    }
    // MACD_NONE (mode == 2)
    return true;
}

__device__ SignalResult generate_signal_codegen(
    const GpuComboConfig& cfg,
    double close,
    double ema_fast,
    double ema_slow,
    double adx,
    double effective_min_adx,
    double rsi,
    double macd_hist,
    double prev_macd_hist,
    double volume,
    double vol_sma,
    double atr,
    double avg_atr,
    double stoch_k,
    double prev_close,
    double prev_ema_fast,
    double ema_slow_slope_pct,
    bool all_gates_pass,
    bool bullish_alignment,
    bool bearish_alignment,
    bool is_anomaly,
    bool is_extended,
    bool is_ranging,
    bool vol_confirm,
    unsigned int btc_bull,
    bool is_btc_symbol
) {
    SignalResult neutral;
    neutral.signal = 0;       // SIG_NEUTRAL
    neutral.confidence = 0;   // CONF_LOW
    neutral.effective_min_adx = 0.0;

    // ── BTC alignment (mirrors bt-signals/src/gates.rs btc_ok_long/short) ──
    bool btc_ok_long = true;
    bool btc_ok_short = true;
    if (cfg.require_btc_alignment != 0u
        && !is_btc_symbol
        && !(adx > (double)cfg.btc_adx_override)) {
        if (btc_bull == 1u) {         // BTC_BULL_BULLISH
            btc_ok_long = true;
            btc_ok_short = false;
        } else if (btc_bull == 0u) {  // BTC_BULL_BEARISH
            btc_ok_long = false;
            btc_ok_short = true;
        } else {
            // Unknown BTC state does not block entries (CPU parity).
            btc_ok_long = true;
            btc_ok_short = true;
        }
    }

    // =================================================================
    // Mode 1: Standard trend entry  (entry.rs lines 43-49)
    // =================================================================
    if (all_gates_pass) {
        int signal = 0;     // SIG_NEUTRAL
        int confidence = 1; // CONF_MEDIUM

        // ── Direction from alignment + close vs EMA_fast ──
        if (bullish_alignment && close > ema_fast && btc_ok_long) {
            signal = 1;  // SIG_BUY
        } else if (bearish_alignment && close < ema_fast && btc_ok_short) {
            signal = 2;  // SIG_SELL
        }

        // CPU parity: failing Mode 1 must fall through to Mode 2/3,
        // not return neutral early.
        if (signal != 0) {
            // ── DRE (Dynamic RSI Elasticity) ──
            double adx_min = (double)cfg.dre_min_adx;
            double adx_max = (double)cfg.dre_max_adx;
            if (adx_max <= adx_min) { adx_max = adx_min + 1.0; }
            double weight = fmax(fmin((adx - adx_min) / (adx_max - adx_min), 1.0), 0.0);
            double rsi_long_limit = (double)cfg.dre_long_rsi_limit_low
                + weight * ((double)cfg.dre_long_rsi_limit_high - (double)cfg.dre_long_rsi_limit_low);
            double rsi_short_limit = (double)cfg.dre_short_rsi_limit_low
                + weight * ((double)cfg.dre_short_rsi_limit_high - (double)cfg.dre_short_rsi_limit_low);

            bool mode1_ok = true;

            // ── RSI gate ──
            if (signal == 1 && rsi <= rsi_long_limit) { mode1_ok = false; }
            if (signal == 2 && rsi >= rsi_short_limit) { mode1_ok = false; }

            // ── MACD histogram gate ──
            if (mode1_ok) {
                bool macd_ok;
                if (signal == 1) {
                    macd_ok = check_macd_long_codegen(cfg.macd_mode, macd_hist, prev_macd_hist);
                } else {
                    macd_ok = check_macd_short_codegen(cfg.macd_mode, macd_hist, prev_macd_hist);
                }
                if (!macd_ok) { mode1_ok = false; }
            }

            // ── StochRSI filter ──
            if (mode1_ok && cfg.use_stoch_rsi_filter != 0u) {
                if (signal == 1 && stoch_k > (double)cfg.stoch_rsi_block_long_gt) { mode1_ok = false; }
                if (signal == 2 && stoch_k < (double)cfg.stoch_rsi_block_short_lt) { mode1_ok = false; }
            }

            if (mode1_ok) {
                // ── Volume-based confidence upgrade to High ──
                if (vol_sma > 0.0 && volume > vol_sma * (double)cfg.high_conf_volume_mult) {
                    confidence = 2;  // CONF_HIGH
                }

                SignalResult result;
                result.signal = signal;
                result.confidence = confidence;
                result.effective_min_adx = effective_min_adx;
                return result;
            }
        }
    }

    // =================================================================
    // Mode 2: Pullback continuation  (entry.rs lines 54-66)
    // =================================================================
    if (cfg.enable_pullback_entries != 0u) {
        bool pullback_gates_ok =
            !is_anomaly
            && !is_extended
            && !is_ranging
            && vol_confirm
            && adx >= (double)cfg.pullback_min_adx;

        if (pullback_gates_ok) {
            // Cross detection: EMA_fast cross-up / cross-down
            bool cross_up = (prev_close <= prev_ema_fast) && (close > ema_fast);
            bool cross_dn = (prev_close >= prev_ema_fast) && (close < ema_fast);

            int pullback_conf = (int)cfg.pullback_confidence;

            // ── Long pullback continuation ──
            if (cross_up && bullish_alignment && btc_ok_long) {
                bool macd_ok = (cfg.pullback_require_macd_sign == 0u) || (macd_hist > 0.0);
                if (macd_ok && rsi >= (double)cfg.pullback_rsi_long_min) {
                    SignalResult result;
                    result.signal = 1;  // SIG_BUY
                    result.confidence = pullback_conf;
                    result.effective_min_adx = (double)cfg.pullback_min_adx;
                    return result;
                }
            }
            // ── Short pullback continuation (elif in Python) ──
            else if (cross_dn && bearish_alignment && btc_ok_short) {
                bool macd_ok = (cfg.pullback_require_macd_sign == 0u) || (macd_hist < 0.0);
                if (macd_ok && rsi <= (double)cfg.pullback_rsi_short_max) {
                    SignalResult result;
                    result.signal = 2;  // SIG_SELL
                    result.confidence = pullback_conf;
                    result.effective_min_adx = (double)cfg.pullback_min_adx;
                    return result;
                }
            }
        }
    }

    // =================================================================
    // Mode 3: Slow drift  (entry.rs lines 71-85)
    // =================================================================
    if (cfg.enable_slow_drift_entries != 0u) {
        bool slow_gates_ok =
            !is_anomaly
            && !is_extended
            && !is_ranging
            && vol_confirm
            && adx >= (double)cfg.slow_drift_min_adx;

        if (slow_gates_ok) {
            double min_slope = (double)cfg.slow_drift_min_slope_pct;

            // ── Long drift: slope >= +threshold, price above EMA_slow ──
            if (bullish_alignment
                && close > ema_slow
                && btc_ok_long
                && ema_slow_slope_pct >= min_slope) {
                bool macd_ok = (cfg.slow_drift_require_macd_sign == 0u) || (macd_hist > 0.0);
                if (macd_ok && rsi >= (double)cfg.slow_drift_rsi_long_min) {
                    SignalResult result;
                    result.signal = 1;  // SIG_BUY
                    result.confidence = 0;  // CONF_LOW (always Low for slow drift)
                    result.effective_min_adx = (double)cfg.slow_drift_min_adx;
                    return result;
                }
            }
            // ── Short drift: slope <= -threshold, price below EMA_slow (elif) ──
            else if (bearish_alignment
                     && close < ema_slow
                     && btc_ok_short
                     && ema_slow_slope_pct <= -min_slope) {
                bool macd_ok = (cfg.slow_drift_require_macd_sign == 0u) || (macd_hist < 0.0);
                if (macd_ok && rsi <= (double)cfg.slow_drift_rsi_short_max) {
                    SignalResult result;
                    result.signal = 2;  // SIG_SELL
                    result.confidence = 0;  // CONF_LOW (always Low for slow drift)
                    result.effective_min_adx = (double)cfg.slow_drift_min_adx;
                    return result;
                }
            }
        }
    }

    return neutral;
}
"#
    .to_string()
}

/// Stop loss: ASE/DASE/SLB/breakeven (AQC-1220)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/exits/stop_loss.rs::compute_sl_price`.
///
/// Uses `double` precision for all price arithmetic to match the f64 Rust
/// source and satisfy T2 precision requirements (single arithmetic:
/// price +/- atr * mult).
pub fn compute_sl_price_codegen() -> String {
    r#"// Derived from bt-core/src/exits/stop_loss.rs
// Computes the dynamic stop-loss price for a position each bar.
//
// Modifiers applied to sl_atr_mult:
//   1. ASE  — ADX slope < 0 AND underwater -> tighten 20% (x0.80)
//   2. FTB  — Disabled in backtester (no funding data)
//   3. DASE — ADX > 40 AND profitable > 0.5 ATR -> widen 15% (x1.15)
//   4. SLB  — ADX > 45 -> widen 10% (x1.10)
//   5. Breakeven — profit >= be_start -> move SL to entry +/- be_buffer
__device__ double compute_sl_price_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double atr,
    double current_price,
    double adx,
    double adx_slope
) {
    // ATR fallback: legacy positions with no ATR recorded
    double eff_atr = (atr > 0.0) ? atr : (entry_price * 0.005);

    double sl_mult = (double)cfg.sl_atr_mult;

    // ── 1. ASE (ADX Slope-Adjusted Stop) ─────────────────────────────────
    // If trend is weakening (ADX slope < 0) and position is underwater,
    // tighten the stop by 20%.
    bool is_underwater;
    if (pos_type == 1) {  // POS_LONG
        is_underwater = (current_price < entry_price);
    } else {              // POS_SHORT
        is_underwater = (current_price > entry_price);
    }
    if (adx_slope < 0.0 && is_underwater) {
        sl_mult *= 0.8;
    }

    // ── 2. FTB (Funding Tailwind Buffer) ─────────────────────────────────
    // Disabled in backtester — no funding rate data available.

    // ── 3. DASE (Dynamic ADX Stop Expansion) ─────────────────────────────
    // If ADX > 40 and position is profitable by > 0.5 ATR, widen by 15%.
    if (adx > 40.0) {
        double profit_in_atr;
        if (pos_type == 1) {  // POS_LONG
            profit_in_atr = (current_price - entry_price) / eff_atr;
        } else {              // POS_SHORT
            profit_in_atr = (entry_price - current_price) / eff_atr;
        }
        if (profit_in_atr > 0.5) {
            sl_mult *= 1.15;
        }
    }

    // ── 4. SLB (Saturation Loyalty Buffer) ───────────────────────────────
    // If ADX > 45 (saturated/strong trend), widen overall SL by 10%.
    if (adx > 45.0) {
        sl_mult *= 1.10;
    }

    // ── Compute raw SL price ─────────────────────────────────────────────
    double sl_price;
    if (pos_type == 1) {  // POS_LONG
        sl_price = entry_price - (eff_atr * sl_mult);
    } else {              // POS_SHORT
        sl_price = entry_price + (eff_atr * sl_mult);
    }

    // ── 5. Breakeven Stop ────────────────────────────────────────────────
    // If profit exceeds breakeven_start_atr ATRs, move SL to
    // entry +/- breakeven_buffer_atr ATRs (protecting at least entry).
    if (cfg.enable_breakeven_stop != 0u && cfg.breakeven_start_atr > 0.0f) {
        double be_start = eff_atr * (double)cfg.breakeven_start_atr;
        double be_buffer = eff_atr * (double)cfg.breakeven_buffer_atr;

        if (pos_type == 1) {  // POS_LONG
            if ((current_price - entry_price) >= be_start) {
                // Only raise SL, never lower it from the breakeven level.
                sl_price = fmax(sl_price, entry_price + be_buffer);
            }
        } else {              // POS_SHORT
            if ((entry_price - current_price) >= be_start) {
                // Only lower SL, never raise it from the breakeven level.
                sl_price = fmin(sl_price, entry_price - be_buffer);
            }
        }
    }

    return sl_price;
}
"#
    .to_string()
}

/// Trailing stop: VBTS/TATP/TSPV/ratchet (AQC-1221)
///
/// Translates `bt-core/src/exits/trailing.rs::compute_trailing()` into a CUDA
/// `__device__` function.  All price arithmetic uses `double` to match AQC-734
/// f64 migration.  Every tunable constant is read from `cfg.` — no hardcoded
/// magic numbers remain except the TATP multiplier (1.0, i.e. "don't tighten").
pub fn compute_trailing_codegen() -> String {
    r#"// Derived from bt-core/src/exits/trailing.rs
// Trailing stop: per-confidence offsets, VBTS, RSI Trend-Guard, TATP, TSPV,
//                weak-trend tightening, ratchet.
// All price math in double precision (AQC-734).
// All tunables read from cfg (no hardcoded trailing params).

__device__ double compute_trailing_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double current_price,
    double atr,
    double current_trailing_sl,
    int confidence,
    double rsi,
    double adx,
    double adx_slope,
    double atr_slope,
    double bb_width_ratio,
    double profit_atr
) {
    // ── ATR fallback (mirrors Rust: if entry_atr <= 0 use 0.5% of entry) ──
    double eff_atr = (atr > 0.0) ? atr : (entry_price * 0.005);

    // ── Per-confidence overrides for trailing start / distance ─────────────
    double trailing_start = (double)cfg.trailing_start_atr;
    double trailing_dist  = (double)cfg.trailing_distance_atr;

    if (confidence == 0) {  // Confidence::Low == 0
        if (cfg.trailing_start_atr_low_conf > 0.0f) {
            trailing_start = (double)cfg.trailing_start_atr_low_conf;
        }
        if (cfg.trailing_distance_atr_low_conf > 0.0f) {
            trailing_dist = (double)cfg.trailing_distance_atr_low_conf;
        }
    }

    // ── RSI Trend-Guard floor (v5.016) ────────────────────────────────────
    // Minimum effective trailing distance.  Raised when RSI is favourable
    // (trending in the direction of the position).
    double min_trailing_dist = (double)cfg.trailing_rsi_floor_default;
    if (pos_type == POS_LONG && rsi > 60.0) {
        min_trailing_dist = (double)cfg.trailing_rsi_floor_trending;
    }
    if (pos_type == POS_SHORT && rsi < 40.0) {
        min_trailing_dist = (double)cfg.trailing_rsi_floor_trending;
    }

    // ── Effective trailing distance ───────────────────────────────────────
    double effective_dist = trailing_dist;

    // VBTS (Vol-Buffered Trailing Stop, v5.015): widen when BB expanding.
    if (cfg.enable_vol_buffered_trailing != 0u
        && bb_width_ratio > (double)cfg.trailing_vbts_bb_threshold) {
        effective_dist *= (double)cfg.trailing_vbts_mult;
    }

    // High-profit tightening (> cfg threshold ATR) with TATP / TSPV overrides.
    if (profit_atr > (double)cfg.trailing_high_profit_atr) {
        if (adx > 35.0 && adx_slope > 0.0) {
            // TATP: trend accelerating — don't tighten (1.0x).
            effective_dist = trailing_dist * 1.0;
        } else if (atr_slope > 0.0) {
            // TSPV: volatility expanding — partial tighten.
            effective_dist = trailing_dist * (double)cfg.trailing_tighten_tspv;
        } else {
            // Default high-profit tightening.
            effective_dist = trailing_dist * (double)cfg.trailing_tighten_default;
        }
    } else if (adx < 25.0) {
        // Weak-trend tightening.
        effective_dist = trailing_dist * (double)cfg.trailing_weak_trend_mult;
    }

    // Clamp to RSI Trend-Guard floor.
    effective_dist = fmax(effective_dist, min_trailing_dist);

    // ── Activation gate ───────────────────────────────────────────────────
    if (profit_atr < trailing_start) {
        // Not enough profit to activate trailing stop yet.
        // Preserve any existing trailing SL from a previous bar.
        return current_trailing_sl;
    }

    // ── Compute candidate trailing stop price ─────────────────────────────
    double candidate;
    if (pos_type == POS_LONG) {
        candidate = current_price - (eff_atr * effective_dist);
    } else {
        candidate = current_price + (eff_atr * effective_dist);
    }

    // ── Ratchet: only allow the trailing stop to improve ──────────────────
    // A non-positive current_trailing_sl means "no trailing stop yet" (first bar).
    if (current_trailing_sl > 0.0) {
        if (pos_type == POS_LONG) {
            candidate = fmax(candidate, current_trailing_sl);
        } else {
            candidate = fmin(candidate, current_trailing_sl);
        }
    }

    return candidate;
}
"#
    .to_string()
}

/// Take profit: partial TP + full TP ladder (AQC-1222)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/exits/take_profit.rs::check_tp`.
///
/// Returns a `TpResult` struct: `{ int action; double fraction; int exit_code; }`
///   - action 0 = Hold, action 1 = Reduce (partial TP), action 2 = Close (full TP)
///   - fraction: the reduce fraction (only meaningful when action == 1)
///   - exit_code: 0 = no exit, 10 = partial TP, 11 = full TP
///
/// Uses `double` precision for all price arithmetic to match the f64 Rust
/// source and satisfy T2 precision requirements.
///
/// The `tp_mult` parameter is resolved by the caller (confidence-dependent
/// multipliers via `tp_mult_strong`/`tp_mult_weak`, or dynamic gate TP).
pub fn check_tp_codegen() -> String {
    r#"// Derived from bt-core/src/exits/take_profit.rs
// Take profit: full TP + partial TP ladder.
// All price math in double precision (AQC-734).
//
// Partial TP ladder:
//   1. If enable_partial_tp AND tp1_taken == 0 AND price hits partial TP level
//      -> Reduce by tp_partial_pct, caller sets trailing_sl = entry (breakeven)
//   2. If tp1_taken == 1 AND tp_partial_atr_mult > 0 AND price hits full TP
//      -> Close remainder at full TP
//   3. If tp1_taken == 1 AND tp_partial_atr_mult == 0 -> Hold (trailing manages)
//   4. If partial TP disabled or tp_partial_pct >= 1.0 -> full Close
//
// Confidence-dependent TP multipliers (tp_mult_strong for high ADX,
// tp_mult_weak for low ADX) and dynamic gate TP multiplier are resolved
// by the caller via get_tp_mult() before calling this function.

struct TpResult {
    int action;       // 0 = hold, 1 = reduce (partial), 2 = close (full)
    double fraction;  // reduce fraction (meaningful only when action == 1)
    int exit_code;    // 0 = no exit, 10 = partial TP, 11 = full TP
};

__device__ TpResult check_tp_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double entry_atr,
    double current_price,
    double size,
    unsigned int tp1_taken,
    double tp_mult
) {
    TpResult result;
    result.action = 0;
    result.fraction = 0.0;
    result.exit_code = 0;

    // ── ATR fallback (mirrors Rust: if entry_atr <= 0 use 0.5% of entry) ──
    double atr = (entry_atr > 0.0) ? entry_atr : (entry_price * 0.005);

    // ── Full TP price (always based on tp_mult) ────────────────────────────
    double tp_price;
    if (pos_type == POS_LONG) {
        tp_price = entry_price + (atr * tp_mult);
    } else {
        tp_price = entry_price - (atr * tp_mult);
    }

    // ── Partial TP path ────────────────────────────────────────────────────
    if (cfg.enable_partial_tp != 0u) {
        if (tp1_taken == 0u) {
            // Determine partial TP level: use dedicated mult if set,
            // otherwise same as full TP.
            double partial_mult = (cfg.tp_partial_atr_mult > 0.0)
                ? (double)cfg.tp_partial_atr_mult
                : tp_mult;
            double partial_tp_price;
            if (pos_type == POS_LONG) {
                partial_tp_price = entry_price + (atr * partial_mult);
            } else {
                partial_tp_price = entry_price - (atr * partial_mult);
            }
            bool partial_hit;
            if (pos_type == POS_LONG) {
                partial_hit = (current_price >= partial_tp_price);
            } else {
                partial_hit = (current_price <= partial_tp_price);
            }

            if (partial_hit) {
                double pct = fmax(fmin((double)cfg.tp_partial_pct, 1.0), 0.0);

                if (pct > 0.0 && pct < 1.0) {
                    double remaining_notional = size * (1.0 - pct) * current_price;
                    if (remaining_notional < (double)cfg.tp_partial_min_notional_usd) {
                        // Remaining too small — hold instead of partial.
                        return result;  // action=0, hold
                    }

                    // Partial reduce.
                    result.action = 1;
                    result.fraction = pct;
                    result.exit_code = 10;  // partial TP
                    return result;
                }
                // pct == 0 or pct >= 1.0 falls through to full close check.
            } else {
                // Partial TP not hit yet.
                // When tp_partial_atr_mult == 0, partial == full,
                // so full can't be hit either.
                if (cfg.tp_partial_atr_mult <= 0.0f) {
                    return result;  // action=0, hold
                }
                // When tp_partial_atr_mult > 0, fall through to check full TP
                // (handles edge case where partial_mult > tp_mult).
            }
        } else {
            // tp1 already taken.
            if (cfg.tp_partial_atr_mult > 0.0f) {
                // Separate partial level: check if full TP hit for remainder.
                bool tp_hit;
                if (pos_type == POS_LONG) {
                    tp_hit = (current_price >= tp_price);
                } else {
                    tp_hit = (current_price <= tp_price);
                }
                if (tp_hit) {
                    result.action = 2;
                    result.fraction = 1.0;
                    result.exit_code = 11;  // full TP
                    return result;
                }
            }
            // Same level (tp_partial_atr_mult == 0) or full TP not hit:
            // trailing manages.
            return result;  // action=0, hold
        }
    }

    // ── Full TP check (partial TP disabled, or pct edge case) ──────────────
    bool tp_hit;
    if (pos_type == POS_LONG) {
        tp_hit = (current_price >= tp_price);
    } else {
        tp_hit = (current_price <= tp_price);
    }

    if (!tp_hit) {
        return result;  // action=0, hold
    }

    result.action = 2;
    result.fraction = 1.0;
    result.exit_code = 11;  // full TP
    return result;
}
"#
    .to_string()
}

/// Smart exits: all 8 sub-checks (AQC-1223)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/exits/smart_exits.rs::check`.
///
/// The 8 sub-checks (evaluated in priority order, first wins):
///   1. Trend Breakdown (EMA Cross) with TBB (Tight-Band Buffer)
///   2. Trend Exhaustion (ADX below threshold)
///   3. EMA Macro Breakdown (require_macro_alignment gate)
///   4. Stagnation Exit (low-vol + underwater, skip PAXG — PAXG excluded by caller)
///   5. Funding Headwind Exit (no-op in backtester v1: funding_rate always 0)
///   6. TSME (Trend Saturation Momentum Exit)
///   7. MMDE (MACD Persistent Divergence Exit)
///   8. RSI Overextension Exit (profit-switched thresholds)
///
/// Returns a `SmartExitResult` struct: `{ bool should_exit; int exit_code; }`
///   - exit_code: 0=none, 1=Trend Breakdown, 2=Trend Exhaustion,
///     3=EMA Macro Breakdown, 4=Stagnation, 5=Funding Headwind (never fires),
///     6=TSME, 7=MMDE, 8=RSI Overextension
///
/// Uses `double` precision for all indicator/price arithmetic to match
/// the f64 Rust source and satisfy T2 precision requirements (AQC-734).
pub fn check_smart_exits_codegen() -> String {
    r#"// Derived from bt-core/src/exits/smart_exits.rs
// Smart exits: 8 independent sub-checks evaluated in priority order.
// First triggered sub-check wins and sets exit_code.
//
// Sub-checks:
//   1. Trend Breakdown (EMA Cross) + TBB buffer
//   2. Trend Exhaustion (ADX < threshold)
//   3. EMA Macro Breakdown (require_macro_alignment gate)
//   4. Stagnation Exit (low-vol + underwater)
//   5. Funding Headwind Exit (no-op: funding_rate = 0 in backtester v1)
//   6. TSME (Trend Saturation Momentum Exit)
//   7. MMDE (MACD Persistent Divergence Exit)
//   8. RSI Overextension Exit (profit-switched thresholds)
//
// All indicator/price math in double precision (AQC-734).

struct SmartExitResult {
    bool should_exit;
    int exit_code;     // 0=none, 1-8 for each sub-check
};

__device__ SmartExitResult check_smart_exits_codegen(
    const GpuComboConfig& cfg,
    int pos_type,
    double entry_price,
    double entry_atr,
    double current_price,
    double ema_fast,
    double ema_slow,
    double ema_macro,
    double adx,
    double adx_slope,
    double atr,
    double avg_atr,
    double rsi,
    double macd_hist,
    double prev_macd_hist,
    double prev2_macd_hist,
    double prev3_macd_hist,
    double profit_atr,
    int confidence,
    double entry_adx_threshold
) {
    SmartExitResult result;
    result.should_exit = false;
    result.exit_code = 0;

    // ── ATR fallback (mirrors Rust: if entry_atr <= 0 use 0.5% of entry) ──
    double eff_atr = (entry_atr > 0.0) ? entry_atr : (entry_price * 0.005);

    // ── ADX exhaustion threshold: use entry's ADX threshold so entry and
    // exit can never contradict; fall back to config value. ────────────────
    double adx_exhaustion_lt = (double)cfg.smart_exit_adx_exhaustion_lt;
    if (confidence == CONF_LOW
        && (double)cfg.smart_exit_adx_exhaustion_lt_low_conf > 0.0) {
        adx_exhaustion_lt = (double)cfg.smart_exit_adx_exhaustion_lt_low_conf;
    }
    if (entry_adx_threshold > 0.0) {
        adx_exhaustion_lt = entry_adx_threshold;
    }
    adx_exhaustion_lt = fmax(adx_exhaustion_lt, 0.0);

    // ══════════════════════════════════════════════════════════════════════
    // 1. Trend Breakdown (EMA Cross) with TBB buffer
    // ══════════════════════════════════════════════════════════════════════
    double ema_dev = 0.0;
    if (ema_slow > 0.0) {
        double diff = ema_fast - ema_slow;
        if (diff < 0.0) { diff = -diff; }
        ema_dev = diff / ema_slow;
    }
    bool is_weak_cross = (ema_dev < 0.001 && adx > 25.0);

    bool ema_cross_exit;
    if (pos_type == POS_LONG) {
        ema_cross_exit = (ema_fast < ema_slow && !is_weak_cross);
    } else {
        ema_cross_exit = (ema_fast > ema_slow && !is_weak_cross);
    }

    if (ema_cross_exit) {
        result.should_exit = true;
        result.exit_code = 1;
        return result;
    }

    // ══════════════════════════════════════════════════════════════════════
    // 2. Trend Exhaustion (ADX below threshold)
    // ══════════════════════════════════════════════════════════════════════
    if (adx_exhaustion_lt > 0.0 && adx < adx_exhaustion_lt) {
        result.should_exit = true;
        result.exit_code = 2;
        return result;
    }

    // ══════════════════════════════════════════════════════════════════════
    // 3. EMA Macro Breakdown (only if require_macro_alignment enabled)
    // ══════════════════════════════════════════════════════════════════════
    if (cfg.require_macro_alignment != 0u && ema_macro > 0.0) {
        if (pos_type == POS_LONG && current_price < ema_macro) {
            result.should_exit = true;
            result.exit_code = 3;
            return result;
        }
        if (pos_type == POS_SHORT && current_price > ema_macro) {
            result.should_exit = true;
            result.exit_code = 3;
            return result;
        }
    }

    // ══════════════════════════════════════════════════════════════════════
    // 4. Stagnation Exit (low-volatility + underwater)
    //    Note: PAXG exclusion is handled by the caller (symbol check).
    // ══════════════════════════════════════════════════════════════════════
    if (atr < (eff_atr * 0.70)) {
        bool is_underwater;
        if (pos_type == POS_LONG) {
            is_underwater = (current_price < entry_price);
        } else {
            is_underwater = (current_price > entry_price);
        }
        if (is_underwater) {
            result.should_exit = true;
            result.exit_code = 4;
            return result;
        }
    }

    // ══════════════════════════════════════════════════════════════════════
    // 5. Funding Headwind Exit
    //    No-op in backtester v1: funding_rate is always 0.0.
    //    Implemented as a placeholder for structural parity with Rust SSOT.
    //    exit_code = 5 (never fires)
    // ══════════════════════════════════════════════════════════════════════

    // ══════════════════════════════════════════════════════════════════════
    // 6. TSME (Trend Saturation Momentum Exit)
    //    ADX > 50, profit >= tsme_min_profit_atr, optional ADX_slope < 0,
    //    MACD momentum contracting (2 consecutive contractions).
    // ══════════════════════════════════════════════════════════════════════
    if (adx > 50.0) {
        double tsme_min_profit = (double)cfg.tsme_min_profit_atr;
        bool gate_profit_ok = (profit_atr >= tsme_min_profit);
        bool gate_slope_ok = true;
        if (cfg.tsme_require_adx_slope_negative != 0u) {
            gate_slope_ok = (adx_slope < 0.0);
        }

        if (gate_profit_ok && gate_slope_ok) {
            bool is_exhausted;
            if (pos_type == POS_LONG) {
                is_exhausted = (macd_hist < prev_macd_hist
                                && prev_macd_hist < prev2_macd_hist);
            } else {
                is_exhausted = (macd_hist > prev_macd_hist
                                && prev_macd_hist > prev2_macd_hist);
            }

            if (is_exhausted) {
                result.should_exit = true;
                result.exit_code = 6;
                return result;
            }
        }
    }

    // ══════════════════════════════════════════════════════════════════════
    // 7. MMDE (MACD Persistent Divergence Exit)
    //    profit > 1.5 ATR AND ADX > 35 AND 3 consecutive MACD histogram
    //    moves against position (4 bars total).
    // ══════════════════════════════════════════════════════════════════════
    if (profit_atr > 1.5 && adx > 35.0) {
        bool is_diverging;
        if (pos_type == POS_LONG) {
            is_diverging = (macd_hist < prev_macd_hist
                            && prev_macd_hist < prev2_macd_hist
                            && prev2_macd_hist < prev3_macd_hist);
        } else {
            is_diverging = (macd_hist > prev_macd_hist
                            && prev_macd_hist > prev2_macd_hist
                            && prev2_macd_hist > prev3_macd_hist);
        }

        if (is_diverging) {
            result.should_exit = true;
            result.exit_code = 7;
            return result;
        }
    }

    // ══════════════════════════════════════════════════════════════════════
    // 8. RSI Overextension Exit (profit-switched thresholds)
    //    Configurable RSI thresholds with profit-regime switch and
    //    low-confidence overrides.
    // ══════════════════════════════════════════════════════════════════════
    if (cfg.enable_rsi_overextension_exit != 0u) {
        double sw = fmax((double)cfg.rsi_exit_profit_atr_switch, 0.0);

        double rsi_ub;
        double rsi_lb;

        if (profit_atr < sw) {
            // Low-profit regime: wider thresholds (less aggressive exit).
            rsi_ub = (double)cfg.rsi_exit_ub_lo_profit;
            rsi_lb = (double)cfg.rsi_exit_lb_lo_profit;
            if (confidence == CONF_LOW) {
                if ((double)cfg.rsi_exit_ub_lo_profit_low_conf > 0.0) {
                    rsi_ub = (double)cfg.rsi_exit_ub_lo_profit_low_conf;
                }
                if ((double)cfg.rsi_exit_lb_lo_profit_low_conf > 0.0) {
                    rsi_lb = (double)cfg.rsi_exit_lb_lo_profit_low_conf;
                }
            }
        } else {
            // High-profit regime: tighter thresholds (protect profits).
            rsi_ub = (double)cfg.rsi_exit_ub_hi_profit;
            rsi_lb = (double)cfg.rsi_exit_lb_hi_profit;
            if (confidence == CONF_LOW) {
                if ((double)cfg.rsi_exit_ub_hi_profit_low_conf > 0.0) {
                    rsi_ub = (double)cfg.rsi_exit_ub_hi_profit_low_conf;
                }
                if ((double)cfg.rsi_exit_lb_hi_profit_low_conf > 0.0) {
                    rsi_lb = (double)cfg.rsi_exit_lb_hi_profit_low_conf;
                }
            }
        }

        if (pos_type == POS_LONG && rsi > rsi_ub) {
            result.should_exit = true;
            result.exit_code = 8;
            return result;
        }
        if (pos_type == POS_SHORT && rsi < rsi_lb) {
            result.should_exit = true;
            result.exit_code = 8;
            return result;
        }
    }

    return result;
}
"#
    .to_string()
}

/// Exit orchestrator: priority dispatch (AQC-1224)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/exits/mod.rs::check_all_exits`.
///
/// Calls each exit sub-system in priority order and returns the first
/// triggered exit via an `AllExitResult` struct:
///   1. Stop Loss     -> exit_code 100
///   2. Trailing Stop  -> exit_code 101
///   3. Take Profit   -> exit_code 102
///   4. Smart Exits   -> exit_code 1-8 (from sub-check)
///
/// Uses `double` precision for all price/monetary calculations to match the
/// f64 Rust source and satisfy T2 precision requirements (AQC-734).
/// PESC cooldown is NOT checked here — it is an entry-side concern.
pub fn check_all_exits_codegen() -> String {
    r#"// Derived from bt-core/src/engine.rs exit orchestration
// Exit orchestrator: calls individual exit checks in priority order.
// First triggered exit wins. Priority:
//   1. Stop Loss       (exit_code = 100)
//   2. Trailing Stop   (exit_code = 101)
//   3. Take Profit     (exit_code = 102)
//   4. Smart Exits     (exit_code = 1-8)
//
// All price math in double precision (AQC-734).

struct AllExitResult {
    bool should_exit;
    int exit_code;
    double exit_price;
};

__device__ AllExitResult check_all_exits_codegen(
    int pos_type,
    double entry_price,
    double entry_atr,
    double current_price,
    double high_price,
    double low_price,
    double best_price,
    double atr,
    double ema_fast,
    double ema_slow,
    double ema_macro,
    double adx,
    double adx_slope,
    double rsi,
    double macd_hist,
    double prev_macd_hist,
    double prev2_macd_hist,
    double prev3_macd_hist,
    double profit_atr,
    int confidence,
    double entry_adx_threshold,
    double equity,
    int bars_held,
    const GpuComboConfig& cfg
) {
    AllExitResult result;
    result.should_exit = false;
    result.exit_code = 0;
    result.exit_price = 0.0;

    // ── 1. Stop Loss ────────────────────────────────────────────────────
    double sl_price = compute_sl_price_codegen(
        cfg, pos_type, entry_price, atr, current_price, adx, adx_slope
    );
    if (pos_type == 1) {  // POS_LONG
        if (current_price <= sl_price) {
            result.should_exit = true;
            result.exit_code = 100;
            result.exit_price = current_price;
            return result;
        }
    } else {              // POS_SHORT
        if (current_price >= sl_price) {
            result.should_exit = true;
            result.exit_code = 100;
            result.exit_price = current_price;
            return result;
        }
    }

    // ── 2. Trailing Stop ────────────────────────────────────────────────
    // compute_trailing_codegen returns the trailing stop price (double).
    // We pass current_trailing_sl = 0.0 (first-bar semantics; the sweep
    // kernel maintains the running trailing SL across bars, but the
    // orchestrator evaluates each bar independently with best_price).
    double trail_price = compute_trailing_codegen(
        cfg, pos_type, entry_price, current_price, atr,
        0.0,  // current_trailing_sl — recomputed from best_price each bar
        confidence, rsi, adx, adx_slope,
        0.0,  // atr_slope — not tracked per-bar in sweep kernel
        0.0,  // bb_width_ratio — not tracked per-bar in sweep kernel
        profit_atr
    );
    if (trail_price > 0.0) {
        bool trail_triggered = false;
        if (pos_type == 1) {  // POS_LONG
            trail_triggered = (current_price <= trail_price);
        } else {              // POS_SHORT
            trail_triggered = (current_price >= trail_price);
        }
        if (trail_triggered) {
            result.should_exit = true;
            result.exit_code = 101;
            result.exit_price = current_price;
            return result;
        }
    }

    // ── 3. Take Profit ──────────────────────────────────────────────────
    // check_tp_codegen returns TpResult { action, fraction, exit_code }.
    // action 2 = close (full TP), action 1 = reduce (partial TP).
    // For the sweep orchestrator, both partial and full TP trigger exit.
    TpResult tp = check_tp_codegen(
        cfg, pos_type, entry_price, entry_atr, current_price,
        equity,       // size (position equity for partial sizing)
        0u,           // tp1_taken (sweep kernel tracks this externally)
        (double)cfg.tp_atr_mult  // tp_mult
    );
    if (tp.action > 0) {
        result.should_exit = true;
        result.exit_code = 102;
        result.exit_price = current_price;
        return result;
    }

    // ── 4. Smart Exits ──────────────────────────────────────────────────
    SmartExitResult smart = check_smart_exits_codegen(
        cfg, pos_type, entry_price, entry_atr, current_price,
        ema_fast, ema_slow, ema_macro,
        adx, adx_slope, atr,
        atr,          // avg_atr — approximated by current ATR in sweep
        rsi, macd_hist, prev_macd_hist,
        prev2_macd_hist, prev3_macd_hist,
        profit_atr, confidence, entry_adx_threshold
    );
    if (smart.should_exit) {
        result.should_exit = true;
        result.exit_code = smart.exit_code;
        result.exit_price = current_price;
        return result;
    }

    // ── No exit triggered ───────────────────────────────────────────────
    return result;
}
"#
    .to_string()
}

/// Entry sizing: dynamic sizing/leverage/vol scalar (AQC-1230)
///
/// Generates a CUDA `__device__` function that mirrors
/// `risk-core/src/lib.rs::compute_entry_sizing`.
///
/// Uses `double` precision for all monetary/size calculations to match the f64
/// Rust source and satisfy T2 precision requirements.  Returns a struct with
/// `size`, `margin`, and `leverage` — a local `SizingResultD` definition is
/// emitted to avoid colliding with the hand-written `float` struct in
/// `sweep_engine.cu`.
pub fn compute_entry_size_codegen() -> String {
    r#"// Derived from bt-core/src/engine.rs sizing logic
// (SSOT: risk-core/src/lib.rs::compute_entry_sizing)
//
// Dynamic entry sizing: allocation % * confidence mult * ADX mult * vol scalar.
// Dynamic leverage selects per-confidence leverage with optional max cap.
// All monetary/size arithmetic in double precision (AQC-734).

struct SizingResultD {
    double size;
    double margin;
    double leverage;
};

__device__ SizingResultD compute_entry_size_codegen(
    double equity,
    double price,
    unsigned int confidence,
    double atr,
    double adx,
    const GpuComboConfig& cfg
) {
    // ── Base margin allocation ───────────────────────────────────────────
    double margin = equity * (double)cfg.allocation_pct;

    // ── Dynamic sizing (confidence * ADX * volatility) ──────────────────
    if (cfg.enable_dynamic_sizing != 0u) {
        // Confidence multiplier
        double conf_mult = (double)cfg.confidence_mult_medium;
        if (confidence == CONF_HIGH) { conf_mult = (double)cfg.confidence_mult_high; }
        if (confidence == CONF_LOW)  { conf_mult = (double)cfg.confidence_mult_low; }

        // ADX multiplier — linearly scales [min_mult, 1.0] over [0, full_adx]
        double adx_ratio = adx / (double)cfg.adx_sizing_full_adx;
        double adx_mult = fmax(fmin(adx_ratio, 1.0), (double)cfg.adx_sizing_min_mult);

        // Volatility scalar — inverse of vol_ratio, clamped to [min, max]
        double vol_scalar = 1.0;
        if ((double)cfg.vol_baseline_pct > 0.0 && price > 0.0) {
            double vol_ratio = (atr / price) / (double)cfg.vol_baseline_pct;
            if (vol_ratio > 0.0) {
                vol_scalar = fmax(fmin(1.0 / vol_ratio, (double)cfg.vol_scalar_max),
                                  (double)cfg.vol_scalar_min);
            }
        }

        margin *= conf_mult * adx_mult * vol_scalar;
    }

    // ── Leverage ─────────────────────────────────────────────────────────
    double lev = (double)cfg.leverage;
    if (cfg.enable_dynamic_leverage != 0u) {
        if (confidence == CONF_HIGH)        { lev = (double)cfg.leverage_high; }
        else if (confidence == CONF_MEDIUM) { lev = (double)cfg.leverage_medium; }
        else                                { lev = (double)cfg.leverage_low; }
        if ((double)cfg.leverage_max_cap > 0.0) { lev = fmin(lev, (double)cfg.leverage_max_cap); }
    }

    // ── Notional & position size ─────────────────────────────────────────
    double notional = margin * lev;
    double size = 0.0;
    if (price > 0.0) { size = notional / price; }

    SizingResultD result;
    result.size = size;
    result.margin = margin;
    result.leverage = lev;
    return result;
}
"#
    .to_string()
}

/// PESC cooldown: reentry cooldown + ADX interpolation (AQC-1231)
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/engine.rs::is_pesc_blocked`.
///
/// ADX-adaptive cooldown: ADX 25..40 linearly interpolates between
/// max_cd (weak trend = longer cooldown) and min_cd (strong trend = shorter).
/// All ADX arithmetic uses `double` to match the f64 Rust source.
/// Time arithmetic uses `unsigned int` seconds (GPU convention).
pub fn is_pesc_blocked_codegen() -> String {
    r#"// Derived from bt-core/src/engine.rs PESC cooldown logic
// Post-Exit Same-Direction Cooldown: prevents re-entry in the same direction
// too soon after an exit, with ADX-adaptive interpolation of cooldown duration.
//
// Gate chain:
//   1. reentry_cooldown_minutes == 0 -> disabled
//   2. No prior close recorded      -> not blocked
//   3. Signal flip exit reason       -> not blocked (direction changed)
//   4. Different direction           -> not blocked
//   5. ADX-interpolated cooldown     -> blocked if elapsed < cooldown

__device__ bool is_pesc_blocked_codegen(
    const GpuComboConfig& cfg,
    int bars_since_exit,
    double adx,
    unsigned int close_ts,
    unsigned int close_reason,
    unsigned int close_type,
    unsigned int desired_type,
    unsigned int current_sec
) {
    // Gate 1: PESC disabled when reentry_cooldown_minutes == 0
    if (cfg.reentry_cooldown_minutes == 0u) { return false; }

    // Gate 2: no prior close recorded for this symbol
    if (close_ts == 0u) { return false; }

    // Gate 3: no cooldown after signal flips
    if (close_reason == PESC_SIGNAL_FLIP) { return false; }

    // Gate 4: only block same-direction re-entry
    if (close_type != desired_type) { return false; }

    // ADX-adaptive cooldown interpolation
    double min_cd = (double)(cfg.reentry_cooldown_min_mins);
    double max_cd = (double)(cfg.reentry_cooldown_max_mins);

    double cooldown_mins;
    if (adx >= 40.0) {
        // Strong trend: use minimum cooldown
        cooldown_mins = min_cd;
    } else if (adx <= 25.0) {
        // Weak trend: use maximum cooldown
        cooldown_mins = max_cd;
    } else {
        // Linear interpolation: ADX 25->40 maps max_cd->min_cd
        double t = (adx - 25.0) / 15.0;
        cooldown_mins = max_cd + t * (min_cd - max_cd);
    }

    unsigned int cooldown_sec = (unsigned int)(cooldown_mins * 60.0);
    unsigned int elapsed = current_sec - close_ts;
    return elapsed < cooldown_sec;
}
"#
    .to_string()
}

// -- Cooldown functions --

/// Entry cooldown: blocks new entries for a configurable period after closing
/// a position on the same symbol. Prevents whipsaw re-entries.
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/engine.rs` entry cooldown logic.
/// All time arithmetic uses `unsigned int` seconds (GPU convention).
pub fn check_entry_cooldown_codegen() -> String {
    r#"// Derived from bt-core/src/engine.rs cooldown logic
// Entry cooldown: after closing a position, block new entries for
// `cooldown_minutes` to prevent whipsaw re-entries.
//
// Returns true (blocked) when elapsed time since last close < cooldown.
// If last_close_time_sec == 0, no previous close exists — not blocked.

__device__ bool check_entry_cooldown_codegen(
    unsigned int last_close_time_sec,
    unsigned int current_time_sec,
    unsigned int cooldown_minutes,
    const GpuComboConfig& cfg
) {
    // No previous close recorded — no cooldown to enforce
    if (last_close_time_sec == 0u) { return false; }

    unsigned int elapsed_sec = current_time_sec - last_close_time_sec;
    unsigned int cooldown_sec = cooldown_minutes * 60u;

    return elapsed_sec < cooldown_sec;  // true = blocked
}
"#
    .to_string()
}

/// Exit cooldown (minimum hold time): blocks exits (except stop-loss) until
/// the position has been held for at least `min_hold_minutes`.
///
/// Generates a CUDA `__device__` function that mirrors
/// `bt-core/src/engine.rs` exit cooldown / minimum hold logic.
/// All time arithmetic uses `unsigned int` seconds (GPU convention).
pub fn check_exit_cooldown_codegen() -> String {
    r#"// Derived from bt-core/src/engine.rs cooldown logic
// Exit cooldown (minimum hold time): after opening a position, enforce a
// minimum hold period before allowing any exit except stop-loss.
//
// Returns true (blocked) when held time < min_hold.
// If min_hold_minutes == 0, the feature is disabled — never blocked.

__device__ bool check_exit_cooldown_codegen(
    unsigned int entry_time_sec,
    unsigned int current_time_sec,
    unsigned int min_hold_minutes,
    const GpuComboConfig& cfg
) {
    // Feature disabled when min_hold_minutes == 0
    if (min_hold_minutes == 0u) { return false; }

    unsigned int held_sec = current_time_sec - entry_time_sec;
    unsigned int min_hold_sec = min_hold_minutes * 60u;

    return held_sec < min_hold_sec;  // true = blocked (except SL)
}
"#
    .to_string()
}

// ═══════════════════════════════════════════════════════════════════════════
// Tests
// ═══════════════════════════════════════════════════════════════════════════

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sl_codegen_has_correct_function_signature() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("__device__ double compute_sl_price_codegen("),
            "must declare a __device__ double function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(src.contains("int pos_type"), "must take pos_type as int");
        assert!(
            src.contains("double entry_price"),
            "must take entry_price as double"
        );
        assert!(src.contains("double atr"), "must take atr as double");
        assert!(
            src.contains("double current_price"),
            "must take current_price as double"
        );
        assert!(src.contains("double adx"), "must take adx as double");
        assert!(
            src.contains("double adx_slope"),
            "must take adx_slope as double"
        );
    }

    #[test]
    fn sl_codegen_uses_double_precision() {
        let src = compute_sl_price_codegen();
        // Return type is double
        assert!(src.contains("__device__ double"));
        // Internal arithmetic uses double variables
        assert!(src.contains("double sl_mult"));
        assert!(src.contains("double sl_price"));
        assert!(src.contains("double eff_atr"));
        assert!(src.contains("double be_start"));
        assert!(src.contains("double be_buffer"));
        // Must NOT use float for price-critical variables
        assert!(
            !src.contains("float sl_price"),
            "sl_price must be double, not float"
        );
        assert!(
            !src.contains("float sl_mult"),
            "sl_mult must be double, not float"
        );
    }

    #[test]
    fn sl_codegen_contains_ase_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("ASE"), "must have ASE comment marker");
        assert!(
            src.contains("adx_slope < 0.0"),
            "ASE checks for negative ADX slope"
        );
        assert!(
            src.contains("is_underwater"),
            "ASE checks underwater condition"
        );
        assert!(src.contains("*= 0.8"), "ASE tightens by 20% (x0.80)");
    }

    #[test]
    fn sl_codegen_contains_dase_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("DASE"), "must have DASE comment marker");
        assert!(src.contains("adx > 40.0"), "DASE triggers when ADX > 40");
        assert!(
            src.contains("profit_in_atr"),
            "DASE computes profit in ATR units"
        );
        assert!(
            src.contains("profit_in_atr > 0.5"),
            "DASE requires > 0.5 ATR profit"
        );
        assert!(src.contains("*= 1.15"), "DASE widens by 15% (x1.15)");
    }

    #[test]
    fn sl_codegen_contains_slb_logic() {
        let src = compute_sl_price_codegen();
        assert!(src.contains("SLB"), "must have SLB comment marker");
        assert!(src.contains("adx > 45.0"), "SLB triggers when ADX > 45");
        assert!(src.contains("*= 1.10"), "SLB widens by 10% (x1.10)");
    }

    #[test]
    fn sl_codegen_contains_breakeven_logic() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("Breakeven"),
            "must have Breakeven comment marker"
        );
        assert!(
            src.contains("cfg.enable_breakeven_stop"),
            "breakeven checks enable flag from config"
        );
        assert!(
            src.contains("cfg.breakeven_start_atr"),
            "breakeven uses start ATR threshold from config"
        );
        assert!(
            src.contains("cfg.breakeven_buffer_atr"),
            "breakeven uses buffer ATR from config"
        );
        assert!(
            src.contains("fmax(sl_price, entry_price + be_buffer)"),
            "long breakeven raises SL via fmax"
        );
        assert!(
            src.contains("fmin(sl_price, entry_price - be_buffer)"),
            "short breakeven lowers SL via fmin"
        );
    }

    #[test]
    fn sl_codegen_uses_correct_config_fields() {
        let src = compute_sl_price_codegen();
        // All config field accesses must use GpuComboConfig field names
        assert!(src.contains("cfg.sl_atr_mult"), "must use cfg.sl_atr_mult");
        assert!(
            src.contains("cfg.enable_breakeven_stop"),
            "must use cfg.enable_breakeven_stop"
        );
        assert!(
            src.contains("cfg.breakeven_start_atr"),
            "must use cfg.breakeven_start_atr"
        );
        assert!(
            src.contains("cfg.breakeven_buffer_atr"),
            "must use cfg.breakeven_buffer_atr"
        );
    }

    #[test]
    fn sl_codegen_uses_fmax_fmin_not_std_max() {
        let src = compute_sl_price_codegen();
        // Must use CUDA fmax/fmin, not std::max/std::min
        assert!(src.contains("fmax("), "must use fmax for CUDA");
        assert!(src.contains("fmin("), "must use fmin for CUDA");
        assert!(
            !src.contains("std::max"),
            "must not use std::max (use fmax for CUDA)"
        );
        assert!(
            !src.contains("std::min"),
            "must not use std::min (use fmin for CUDA)"
        );
    }

    #[test]
    fn sl_codegen_has_long_short_direction() {
        let src = compute_sl_price_codegen();
        // Long: SL below entry (entry - atr * mult)
        assert!(
            src.contains("entry_price - (eff_atr * sl_mult)"),
            "long SL = entry - atr * mult"
        );
        // Short: SL above entry (entry + atr * mult)
        assert!(
            src.contains("entry_price + (eff_atr * sl_mult)"),
            "short SL = entry + atr * mult"
        );
    }

    #[test]
    fn sl_codegen_has_atr_fallback() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("entry_price * 0.005"),
            "must have ATR fallback for legacy positions"
        );
    }

    #[test]
    fn sl_codegen_has_source_comment() {
        let src = compute_sl_price_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/stop_loss.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn sl_codegen_pos_type_uses_integer_constants() {
        let src = compute_sl_price_codegen();
        // Must use integer comparison, not enum
        assert!(
            src.contains("pos_type == 1"),
            "long check must use pos_type == 1 (POS_LONG)"
        );
    }

    // -- check_gates_codegen tests (AQC-1210) ----------------------------------

    #[test]
    fn gates_codegen_has_correct_function_signature() {
        let src = check_gates_codegen();
        assert!(
            src.contains("__device__ GateResultD check_gates_codegen("),
            "must declare a __device__ GateResultD function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(src.contains("double rsi"), "must take rsi as double");
        assert!(src.contains("double adx"), "must take adx as double");
        assert!(
            src.contains("double adx_slope"),
            "must take adx_slope as double"
        );
        assert!(
            src.contains("double bb_width_ratio"),
            "must take bb_width_ratio as double"
        );
        assert!(
            src.contains("double ema_fast"),
            "must take ema_fast as double"
        );
        assert!(
            src.contains("double ema_slow"),
            "must take ema_slow as double"
        );
        assert!(
            src.contains("double ema_macro"),
            "must take ema_macro as double"
        );
        assert!(src.contains("double close"), "must take close as double");
        assert!(
            src.contains("double prev_close"),
            "must take prev_close as double"
        );
        assert!(src.contains("double volume"), "must take volume as double");
        assert!(
            src.contains("double vol_sma"),
            "must take vol_sma as double"
        );
        assert!(src.contains("double atr"), "must take atr as double");
        assert!(
            src.contains("double avg_atr"),
            "must take avg_atr as double"
        );
        assert!(
            src.contains("double stoch_rsi_k"),
            "must take stoch_rsi_k as double"
        );
        assert!(
            src.contains("double ema_slow_slope_pct"),
            "must take ema_slow_slope_pct as double"
        );
    }

    #[test]
    fn gates_codegen_has_source_comment() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Derived from bt-signals/src/gates.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn gates_codegen_has_gate_result_struct() {
        let src = check_gates_codegen();
        assert!(
            src.contains("struct GateResultD"),
            "must define GateResultD struct"
        );
        assert!(
            src.contains("bool all_gates_pass"),
            "GateResultD must have all_gates_pass field"
        );
        assert!(
            src.contains("bool is_ranging"),
            "GateResultD must have is_ranging field"
        );
        assert!(
            src.contains("bool is_anomaly"),
            "GateResultD must have is_anomaly field"
        );
        assert!(
            src.contains("bool is_extended"),
            "GateResultD must have is_extended field"
        );
        assert!(
            src.contains("bool vol_confirm"),
            "GateResultD must have vol_confirm field"
        );
        assert!(
            src.contains("bool is_trending_up"),
            "GateResultD must have is_trending_up field"
        );
        assert!(
            src.contains("bool adx_above_min"),
            "GateResultD must have adx_above_min field"
        );
        assert!(
            src.contains("bool bullish_alignment"),
            "GateResultD must have bullish_alignment field"
        );
        assert!(
            src.contains("bool bearish_alignment"),
            "GateResultD must have bearish_alignment field"
        );
        assert!(
            src.contains("double effective_min_adx"),
            "GateResultD must have effective_min_adx as double"
        );
        assert!(
            src.contains("double rsi_long_limit"),
            "GateResultD must have rsi_long_limit as double"
        );
        assert!(
            src.contains("double rsi_short_limit"),
            "GateResultD must have rsi_short_limit as double"
        );
    }

    #[test]
    fn gates_codegen_uses_double_precision() {
        let src = check_gates_codegen();
        // Internal arithmetic uses double variables
        assert!(
            src.contains("double price_change_pct"),
            "price_change_pct must be double"
        );
        assert!(
            src.contains("double ema_dev_pct"),
            "ema_dev_pct must be double"
        );
        assert!(
            src.contains("double dist"),
            "dist (extension) must be double"
        );
        assert!(
            src.contains("double effective_min_adx"),
            "effective_min_adx must be double"
        );
        assert!(
            src.contains("double saturation"),
            "saturation must be double"
        );
        assert!(src.contains("double atr_ratio"), "atr_ratio must be double");
        assert!(src.contains("double weight"), "DRE weight must be double");
        assert!(
            src.contains("double rsi_long_weak"),
            "DRE rsi_long_weak must be double"
        );
        assert!(
            src.contains("double rsi_short_weak"),
            "DRE rsi_short_weak must be double"
        );
        // Must NOT use float for indicator-critical variables
        assert!(
            !src.contains("float price_change_pct"),
            "price_change_pct must be double, not float"
        );
        assert!(
            !src.contains("float effective_min_adx"),
            "effective_min_adx must be double, not float"
        );
    }

    #[test]
    fn gates_codegen_contains_ranging_filter() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 1") || src.contains("Ranging filter"),
            "must have ranging filter comment marker"
        );
        assert!(
            src.contains("cfg.enable_ranging_filter"),
            "must check enable_ranging_filter config flag"
        );
        assert!(
            src.contains("cfg.ranging_adx_lt"),
            "must use ranging_adx_lt from config"
        );
        assert!(
            src.contains("cfg.ranging_bb_width_ratio_lt"),
            "must use ranging_bb_width_ratio_lt from config"
        );
        assert!(
            src.contains("cfg.ranging_rsi_low"),
            "must use ranging_rsi_low from config"
        );
        assert!(
            src.contains("cfg.ranging_rsi_high"),
            "must use ranging_rsi_high from config"
        );
        assert!(
            src.contains("cfg.ranging_min_signals"),
            "must use ranging_min_signals from config"
        );
        assert!(
            src.contains("votes"),
            "ranging filter must use vote counting"
        );
    }

    #[test]
    fn gates_codegen_contains_anomaly_filter() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 2") || src.contains("Anomaly filter"),
            "must have anomaly filter comment marker"
        );
        assert!(
            src.contains("cfg.enable_anomaly_filter"),
            "must check enable_anomaly_filter config flag"
        );
        assert!(
            src.contains("cfg.anomaly_price_change_pct"),
            "must use anomaly_price_change_pct from config"
        );
        assert!(
            src.contains("cfg.anomaly_ema_dev_pct"),
            "must use anomaly_ema_dev_pct from config"
        );
        assert!(
            src.contains("price_change_pct"),
            "must compute price_change_pct"
        );
        assert!(src.contains("ema_dev_pct"), "must compute ema_dev_pct");
    }

    #[test]
    fn gates_codegen_contains_extension_filter() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 3") || src.contains("Extension filter"),
            "must have extension filter comment marker"
        );
        assert!(
            src.contains("cfg.enable_extension_filter"),
            "must check enable_extension_filter config flag"
        );
        assert!(
            src.contains("cfg.max_dist_ema_fast"),
            "must use max_dist_ema_fast from config"
        );
    }

    #[test]
    fn gates_codegen_contains_volume_confirmation() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 4") || src.contains("Volume confirmation"),
            "must have volume confirmation comment marker"
        );
        assert!(
            src.contains("cfg.require_volume_confirmation"),
            "must check require_volume_confirmation config flag"
        );
        assert!(
            src.contains("cfg.vol_confirm_include_prev"),
            "must check vol_confirm_include_prev config flag"
        );
        assert!(
            src.contains("vol_trend"),
            "volume confirmation must check vol_trend"
        );
    }

    #[test]
    fn gates_codegen_contains_adx_rising() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 5") || src.contains("ADX rising"),
            "must have ADX rising comment marker"
        );
        assert!(
            src.contains("cfg.require_adx_rising"),
            "must check require_adx_rising config flag"
        );
        assert!(
            src.contains("cfg.adx_rising_saturation"),
            "must use adx_rising_saturation from config"
        );
        assert!(
            src.contains("adx_slope > 0.0"),
            "ADX rising checks for positive ADX slope"
        );
    }

    #[test]
    fn gates_codegen_contains_tmc_logic() {
        let src = check_gates_codegen();
        assert!(
            src.contains("TMC") || src.contains("Trend Momentum"),
            "must have TMC comment marker"
        );
        assert!(
            src.contains("adx_slope > 0.5"),
            "TMC checks ADX slope > 0.5"
        );
        assert!(
            src.contains("fmin(effective_min_adx, 25.0)"),
            "TMC caps effective_min_adx at 25.0"
        );
    }

    #[test]
    fn gates_codegen_contains_ave_logic() {
        let src = check_gates_codegen();
        assert!(
            src.contains("AVE") || src.contains("Adaptive Volatility"),
            "must have AVE comment marker"
        );
        assert!(
            src.contains("cfg.ave_enabled"),
            "must check ave_enabled config flag"
        );
        assert!(
            src.contains("cfg.ave_atr_ratio_gt"),
            "must use ave_atr_ratio_gt from config"
        );
        assert!(
            src.contains("cfg.ave_adx_mult"),
            "must use ave_adx_mult from config"
        );
        assert!(src.contains("atr_ratio"), "AVE must compute atr_ratio");
        assert!(
            src.contains("effective_min_adx *="),
            "AVE must multiply effective_min_adx"
        );
    }

    #[test]
    fn gates_codegen_contains_adx_threshold() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 6") || src.contains("ADX threshold"),
            "must have ADX threshold comment marker"
        );
        assert!(src.contains("cfg.min_adx"), "must use min_adx from config");
        assert!(
            src.contains("adx > effective_min_adx"),
            "must check adx against effective_min_adx"
        );
    }

    #[test]
    fn gates_codegen_contains_macro_alignment() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Gate 7") || src.contains("Macro alignment"),
            "must have macro alignment comment marker"
        );
        assert!(
            src.contains("cfg.require_macro_alignment"),
            "must check require_macro_alignment config flag"
        );
        assert!(
            src.contains("ema_slow > ema_macro"),
            "bullish macro alignment checks ema_slow > ema_macro"
        );
        assert!(
            src.contains("ema_slow < ema_macro"),
            "bearish macro alignment checks ema_slow < ema_macro"
        );
    }

    #[test]
    fn gates_codegen_contains_slow_drift_override() {
        let src = check_gates_codegen();
        assert!(
            src.contains("Slow-drift") || src.contains("slow_drift"),
            "must have slow-drift override reference"
        );
        assert!(
            src.contains("cfg.enable_slow_drift_entries"),
            "must check enable_slow_drift_entries config flag"
        );
        assert!(
            src.contains("cfg.slow_drift_ranging_slope_override"),
            "must use slow_drift_ranging_slope_override from config"
        );
        assert!(
            src.contains("ema_slow_slope_pct"),
            "slow-drift checks ema_slow_slope_pct"
        );
    }

    #[test]
    fn gates_codegen_contains_dre_logic() {
        let src = check_gates_codegen();
        assert!(
            src.contains("DRE") || src.contains("Dynamic RSI Elasticity"),
            "must have DRE comment marker"
        );
        assert!(
            src.contains("cfg.dre_min_adx"),
            "must use dre_min_adx from config"
        );
        assert!(
            src.contains("cfg.dre_max_adx"),
            "must use dre_max_adx from config"
        );
        assert!(
            src.contains("cfg.dre_long_rsi_limit_low"),
            "must use dre_long_rsi_limit_low from config"
        );
        assert!(
            src.contains("cfg.dre_long_rsi_limit_high"),
            "must use dre_long_rsi_limit_high from config"
        );
        assert!(
            src.contains("cfg.dre_short_rsi_limit_low"),
            "must use dre_short_rsi_limit_low from config"
        );
        assert!(
            src.contains("cfg.dre_short_rsi_limit_high"),
            "must use dre_short_rsi_limit_high from config"
        );
        assert!(
            src.contains("weight"),
            "DRE must compute interpolation weight"
        );
        assert!(
            src.contains("rsi_long_limit"),
            "DRE must compute rsi_long_limit"
        );
        assert!(
            src.contains("rsi_short_limit"),
            "DRE must compute rsi_short_limit"
        );
    }

    #[test]
    fn gates_codegen_contains_combined_check() {
        let src = check_gates_codegen();
        assert!(
            src.contains("result.adx_above_min"),
            "combined check must include adx_above_min"
        );
        assert!(
            src.contains("!result.is_ranging"),
            "combined check must require not ranging"
        );
        assert!(
            src.contains("!result.is_anomaly"),
            "combined check must require not anomaly"
        );
        assert!(
            src.contains("!result.is_extended"),
            "combined check must require not extended"
        );
        assert!(
            src.contains("result.vol_confirm"),
            "combined check must require vol_confirm"
        );
        assert!(
            src.contains("result.is_trending_up"),
            "combined check must require is_trending_up"
        );
    }

    #[test]
    fn gates_codegen_uses_fabs_not_std() {
        let src = check_gates_codegen();
        assert!(
            src.contains("fabs("),
            "must use fabs for CUDA double absolute value"
        );
        assert!(
            !src.contains("std::abs"),
            "must not use std::abs (use fabs for CUDA)"
        );
        assert!(
            !src.contains("std::max"),
            "must not use std::max (use fmax for CUDA)"
        );
        assert!(
            !src.contains("std::min"),
            "must not use std::min (use fmin for CUDA)"
        );
    }

    #[test]
    fn gates_codegen_uses_fmax_fmin() {
        let src = check_gates_codegen();
        assert!(src.contains("fmax("), "must use fmax for CUDA double math");
        assert!(src.contains("fmin("), "must use fmin for CUDA double math");
    }

    #[test]
    fn gates_codegen_uses_correct_config_fields() {
        let src = check_gates_codegen();
        // Gate toggle flags
        assert!(
            src.contains("cfg.enable_ranging_filter"),
            "must use enable_ranging_filter"
        );
        assert!(
            src.contains("cfg.enable_anomaly_filter"),
            "must use enable_anomaly_filter"
        );
        assert!(
            src.contains("cfg.enable_extension_filter"),
            "must use enable_extension_filter"
        );
        assert!(
            src.contains("cfg.require_adx_rising"),
            "must use require_adx_rising"
        );
        assert!(
            src.contains("cfg.require_volume_confirmation"),
            "must use require_volume_confirmation"
        );
        assert!(
            src.contains("cfg.require_macro_alignment"),
            "must use require_macro_alignment"
        );
        assert!(
            src.contains("cfg.enable_slow_drift_entries"),
            "must use enable_slow_drift_entries"
        );
        // Threshold fields
        assert!(src.contains("cfg.min_adx"), "must use min_adx");
        assert!(
            src.contains("cfg.max_dist_ema_fast"),
            "must use max_dist_ema_fast"
        );
        assert!(
            src.contains("cfg.adx_rising_saturation"),
            "must use adx_rising_saturation"
        );
        assert!(src.contains("cfg.ave_enabled"), "must use ave_enabled");
        assert!(
            src.contains("cfg.ave_atr_ratio_gt"),
            "must use ave_atr_ratio_gt"
        );
        assert!(src.contains("cfg.ave_adx_mult"), "must use ave_adx_mult");
    }

    #[test]
    fn gates_codegen_is_nonempty() {
        let src = check_gates_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- generate_signal_codegen tests (AQC-1211) --------------------------------

    #[test]
    fn signal_codegen_has_correct_function_signature() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("__device__ SignalResult generate_signal_codegen("),
            "must declare a __device__ SignalResult function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(src.contains("double close"), "must take close as double");
        assert!(
            src.contains("double ema_fast"),
            "must take ema_fast as double"
        );
        assert!(
            src.contains("double ema_slow"),
            "must take ema_slow as double"
        );
        assert!(src.contains("double adx"), "must take adx as double");
        assert!(src.contains("double rsi"), "must take rsi as double");
        assert!(
            src.contains("double macd_hist"),
            "must take macd_hist as double"
        );
        assert!(
            src.contains("double prev_macd_hist"),
            "must take prev_macd_hist as double"
        );
        assert!(src.contains("double volume"), "must take volume as double");
        assert!(
            src.contains("double vol_sma"),
            "must take vol_sma as double"
        );
        assert!(
            src.contains("double stoch_k"),
            "must take stoch_k as double"
        );
        assert!(
            src.contains("double prev_close"),
            "must take prev_close as double"
        );
        assert!(
            src.contains("double prev_ema_fast"),
            "must take prev_ema_fast as double"
        );
        assert!(
            src.contains("double ema_slow_slope_pct"),
            "must take ema_slow_slope_pct as double"
        );
        assert!(
            src.contains("bool all_gates_pass"),
            "must take all_gates_pass as bool"
        );
        assert!(
            src.contains("bool bullish_alignment"),
            "must take bullish_alignment as bool"
        );
        assert!(
            src.contains("bool bearish_alignment"),
            "must take bearish_alignment as bool"
        );
        assert!(
            src.contains("unsigned int btc_bull"),
            "must take btc_bull as unsigned int"
        );
    }

    #[test]
    fn signal_codegen_has_source_comment() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("Derived from bt-signals/src/entry.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn signal_codegen_has_signal_result_struct() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("struct SignalResult"),
            "must define SignalResult struct"
        );
        assert!(
            src.contains("int signal;"),
            "SignalResult must have signal field"
        );
        assert!(
            src.contains("int confidence;"),
            "SignalResult must have confidence field"
        );
        assert!(
            src.contains("double effective_min_adx;"),
            "SignalResult must have effective_min_adx field"
        );
    }

    #[test]
    fn signal_codegen_contains_mode1_standard_entry() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("Mode 1") || src.contains("Standard trend"),
            "must have Mode 1 standard trend comment"
        );
        assert!(
            src.contains("all_gates_pass"),
            "Mode 1 checks all_gates_pass"
        );
        assert!(
            src.contains("bullish_alignment && close > ema_fast"),
            "Mode 1 long: bullish alignment + close > ema_fast"
        );
        assert!(
            src.contains("bearish_alignment && close < ema_fast"),
            "Mode 1 short: bearish alignment + close < ema_fast"
        );
    }

    #[test]
    fn signal_codegen_contains_dre_logic() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("DRE") || src.contains("Dynamic RSI Elasticity"),
            "must reference DRE logic"
        );
        assert!(
            src.contains("cfg.dre_min_adx"),
            "DRE uses dre_min_adx from config"
        );
        assert!(
            src.contains("cfg.dre_max_adx"),
            "DRE uses dre_max_adx from config"
        );
        assert!(
            src.contains("cfg.dre_long_rsi_limit_low"),
            "DRE uses dre_long_rsi_limit_low"
        );
        assert!(
            src.contains("cfg.dre_long_rsi_limit_high"),
            "DRE uses dre_long_rsi_limit_high"
        );
        assert!(
            src.contains("cfg.dre_short_rsi_limit_low"),
            "DRE uses dre_short_rsi_limit_low"
        );
        assert!(
            src.contains("cfg.dre_short_rsi_limit_high"),
            "DRE uses dre_short_rsi_limit_high"
        );
        assert!(
            src.contains("rsi_long_limit"),
            "DRE computes rsi_long_limit"
        );
        assert!(
            src.contains("rsi_short_limit"),
            "DRE computes rsi_short_limit"
        );
    }

    #[test]
    fn signal_codegen_contains_macd_helpers() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("check_macd_long_codegen"),
            "must have check_macd_long_codegen helper"
        );
        assert!(
            src.contains("check_macd_short_codegen"),
            "must have check_macd_short_codegen helper"
        );
        assert!(
            src.contains("cfg.macd_mode"),
            "MACD gate reads macd_mode from config"
        );
    }

    #[test]
    fn signal_codegen_contains_stoch_rsi_filter() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("cfg.use_stoch_rsi_filter"),
            "must check use_stoch_rsi_filter config flag"
        );
        assert!(
            src.contains("cfg.stoch_rsi_block_long_gt"),
            "StochRSI uses block_long_gt from config"
        );
        assert!(
            src.contains("cfg.stoch_rsi_block_short_lt"),
            "StochRSI uses block_short_lt from config"
        );
    }

    #[test]
    fn signal_codegen_contains_volume_confidence_upgrade() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("cfg.high_conf_volume_mult"),
            "must use high_conf_volume_mult from config"
        );
        assert!(
            src.contains("volume > vol_sma"),
            "volume confidence check compares volume to vol_sma"
        );
    }

    #[test]
    fn signal_codegen_contains_mode2_pullback() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("Mode 2") || src.contains("Pullback"),
            "must have Mode 2 pullback comment"
        );
        assert!(
            src.contains("cfg.enable_pullback_entries"),
            "Mode 2 checks enable_pullback_entries"
        );
        assert!(
            src.contains("cfg.pullback_min_adx"),
            "Mode 2 uses pullback_min_adx"
        );
        assert!(src.contains("cross_up"), "Mode 2 detects EMA cross-up");
        assert!(src.contains("cross_dn"), "Mode 2 detects EMA cross-down");
        assert!(
            src.contains("cfg.pullback_rsi_long_min"),
            "Mode 2 uses pullback_rsi_long_min"
        );
        assert!(
            src.contains("cfg.pullback_rsi_short_max"),
            "Mode 2 uses pullback_rsi_short_max"
        );
        assert!(
            src.contains("cfg.pullback_require_macd_sign"),
            "Mode 2 checks pullback_require_macd_sign"
        );
        assert!(
            src.contains("cfg.pullback_confidence"),
            "Mode 2 uses pullback_confidence"
        );
    }

    #[test]
    fn signal_codegen_contains_mode3_slow_drift() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("Mode 3") || src.contains("Slow drift"),
            "must have Mode 3 slow drift comment"
        );
        assert!(
            src.contains("cfg.enable_slow_drift_entries"),
            "Mode 3 checks enable_slow_drift_entries"
        );
        assert!(
            src.contains("cfg.slow_drift_min_adx"),
            "Mode 3 uses slow_drift_min_adx"
        );
        assert!(
            src.contains("cfg.slow_drift_min_slope_pct"),
            "Mode 3 uses slow_drift_min_slope_pct"
        );
        assert!(
            src.contains("cfg.slow_drift_rsi_long_min"),
            "Mode 3 uses slow_drift_rsi_long_min"
        );
        assert!(
            src.contains("cfg.slow_drift_rsi_short_max"),
            "Mode 3 uses slow_drift_rsi_short_max"
        );
        assert!(
            src.contains("cfg.slow_drift_require_macd_sign"),
            "Mode 3 checks slow_drift_require_macd_sign"
        );
        assert!(
            src.contains("ema_slow_slope_pct"),
            "Mode 3 uses ema_slow_slope_pct"
        );
    }

    #[test]
    fn signal_codegen_contains_btc_alignment() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("cfg.require_btc_alignment"),
            "must check require_btc_alignment"
        );
        assert!(src.contains("btc_ok_long"), "must compute btc_ok_long");
        assert!(src.contains("btc_ok_short"), "must compute btc_ok_short");
        assert!(
            src.contains("cfg.btc_adx_override"),
            "BTC alignment uses btc_adx_override"
        );
    }

    #[test]
    fn signal_codegen_uses_double_precision() {
        let src = generate_signal_codegen();
        assert!(src.contains("double adx_min"), "adx_min must be double");
        assert!(src.contains("double adx_max"), "adx_max must be double");
        assert!(src.contains("double weight"), "weight must be double");
        assert!(
            src.contains("double rsi_long_limit"),
            "rsi_long_limit must be double"
        );
        assert!(
            src.contains("double rsi_short_limit"),
            "rsi_short_limit must be double"
        );
        assert!(src.contains("double min_slope"), "min_slope must be double");
        assert!(
            !src.contains("float rsi_long_limit"),
            "rsi_long_limit must be double, not float"
        );
        assert!(
            !src.contains("float rsi_short_limit"),
            "rsi_short_limit must be double, not float"
        );
    }

    #[test]
    fn signal_codegen_uses_correct_config_fields() {
        let src = generate_signal_codegen();
        assert!(src.contains("cfg.dre_min_adx"), "must use cfg.dre_min_adx");
        assert!(src.contains("cfg.macd_mode"), "must use cfg.macd_mode");
        assert!(
            src.contains("cfg.use_stoch_rsi_filter"),
            "must use cfg.use_stoch_rsi_filter"
        );
        assert!(
            src.contains("cfg.high_conf_volume_mult"),
            "must use cfg.high_conf_volume_mult"
        );
        assert!(
            src.contains("cfg.require_btc_alignment"),
            "must use cfg.require_btc_alignment"
        );
        assert!(
            src.contains("cfg.enable_pullback_entries"),
            "must use cfg.enable_pullback_entries"
        );
        assert!(
            src.contains("cfg.pullback_min_adx"),
            "must use cfg.pullback_min_adx"
        );
        assert!(
            src.contains("cfg.pullback_confidence"),
            "must use cfg.pullback_confidence"
        );
        assert!(
            src.contains("cfg.enable_slow_drift_entries"),
            "must use cfg.enable_slow_drift_entries"
        );
        assert!(
            src.contains("cfg.slow_drift_min_adx"),
            "must use cfg.slow_drift_min_adx"
        );
    }

    #[test]
    fn signal_codegen_mode_priority_order() {
        let src = generate_signal_codegen();
        let mode1_pos = src
            .rfind("// Mode 1: Standard")
            .expect("Mode 1 section header must exist");
        let mode2_pos = src
            .rfind("// Mode 2: Pullback")
            .expect("Mode 2 section header must exist");
        let mode3_pos = src
            .rfind("// Mode 3: Slow drift")
            .expect("Mode 3 section header must exist");
        assert!(mode1_pos < mode2_pos, "Mode 1 must appear before Mode 2");
        assert!(mode2_pos < mode3_pos, "Mode 2 must appear before Mode 3");
    }

    #[test]
    fn signal_codegen_slow_drift_always_low_confidence() {
        let src = generate_signal_codegen();
        let marker = "// Mode 3: Slow drift";
        let slow_drift_start = src.rfind(marker).expect("Mode 3 section header must exist");
        let slow_drift_section = &src[slow_drift_start..];
        assert!(
            slow_drift_section.contains("confidence = 0"),
            "slow drift must always return CONF_LOW (0)"
        );
        assert!(
            !slow_drift_section.contains("confidence = 1")
                && !slow_drift_section.contains("confidence = 2"),
            "slow drift must not set medium or high confidence"
        );
    }

    #[test]
    fn signal_codegen_is_nonempty() {
        let src = generate_signal_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    #[test]
    fn signal_codegen_contains_ave_logic() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("AVE") || src.contains("Adaptive Volatility"),
            "must reference AVE logic"
        );
        assert!(
            src.contains("cfg.ave_atr_ratio_gt"),
            "AVE uses ave_atr_ratio_gt"
        );
        assert!(src.contains("cfg.ave_enabled"), "AVE uses ave_enabled");
    }

    #[test]
    fn signal_codegen_pullback_cross_detection() {
        let src = generate_signal_codegen();
        assert!(
            src.contains("prev_close <= prev_ema_fast") && src.contains("close > ema_fast"),
            "cross_up must check prev_close <= prev_ema_fast AND close > ema_fast"
        );
        assert!(
            src.contains("prev_close >= prev_ema_fast") && src.contains("close < ema_fast"),
            "cross_dn must check prev_close >= prev_ema_fast AND close < ema_fast"
        );
    }

    #[test]
    fn signal_codegen_pullback_gate_subset() {
        let src = generate_signal_codegen();
        let marker2 = "// Mode 2: Pullback";
        let marker3 = "// Mode 3: Slow drift";
        let mode2_start = src
            .rfind(marker2)
            .expect("Mode 2 section header must exist");
        let mode3_start = src
            .rfind(marker3)
            .expect("Mode 3 section header must exist");
        let mode2_section = &src[mode2_start..mode3_start];
        assert!(
            mode2_section.contains("!is_anomaly"),
            "pullback gate checks !is_anomaly"
        );
        assert!(
            mode2_section.contains("!is_extended"),
            "pullback gate checks !is_extended"
        );
        assert!(
            mode2_section.contains("!is_ranging"),
            "pullback gate checks !is_ranging"
        );
        assert!(
            mode2_section.contains("vol_confirm"),
            "pullback gate checks vol_confirm"
        );
        assert!(
            mode2_section.contains("cfg.pullback_min_adx"),
            "pullback gate checks pullback_min_adx"
        );
    }

    #[test]
    fn signal_codegen_slow_drift_gate_subset() {
        let src = generate_signal_codegen();
        let marker = "// Mode 3: Slow drift";
        let mode3_start = src.rfind(marker).expect("Mode 3 section header must exist");
        let mode3_section = &src[mode3_start..];
        assert!(
            mode3_section.contains("!is_anomaly"),
            "slow drift gate checks !is_anomaly"
        );
        assert!(
            mode3_section.contains("!is_extended"),
            "slow drift gate checks !is_extended"
        );
        assert!(
            mode3_section.contains("!is_ranging"),
            "slow drift gate checks !is_ranging"
        );
        assert!(
            mode3_section.contains("vol_confirm"),
            "slow drift gate checks vol_confirm"
        );
        assert!(
            mode3_section.contains("cfg.slow_drift_min_adx"),
            "slow drift gate checks slow_drift_min_adx"
        );
    }

    // -- compute_trailing_codegen tests (AQC-1221) ----------------------------

    #[test]
    fn trailing_codegen_contains_function_signature() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("__device__ double compute_trailing_codegen("),
            "must emit __device__ double function signature"
        );
    }

    #[test]
    fn trailing_codegen_contains_source_comment() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/trailing.rs"),
            "must have provenance comment"
        );
    }

    #[test]
    fn trailing_codegen_uses_double_precision() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("double trailing_start"),
            "trailing_start must be double"
        );
        assert!(
            src.contains("double trailing_dist"),
            "trailing_dist must be double"
        );
        assert!(
            src.contains("double effective_dist"),
            "effective_dist must be double"
        );
        assert!(src.contains("double candidate"), "candidate must be double");
        assert!(src.contains("double eff_atr"), "eff_atr must be double");
        assert!(
            src.contains("double min_trailing_dist"),
            "min_trailing_dist must be double"
        );
    }

    #[test]
    fn trailing_codegen_reads_config_not_hardcoded() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("cfg.trailing_start_atr"),
            "trailing_start from config"
        );
        assert!(
            src.contains("cfg.trailing_distance_atr"),
            "trailing_distance from config"
        );
        assert!(
            src.contains("cfg.trailing_start_atr_low_conf"),
            "low_conf start from config"
        );
        assert!(
            src.contains("cfg.trailing_distance_atr_low_conf"),
            "low_conf dist from config"
        );
        assert!(
            src.contains("cfg.trailing_rsi_floor_default"),
            "RSI floor default from config"
        );
        assert!(
            src.contains("cfg.trailing_rsi_floor_trending"),
            "RSI floor trending from config"
        );
        assert!(
            src.contains("cfg.enable_vol_buffered_trailing"),
            "VBTS enable from config"
        );
        assert!(
            src.contains("cfg.trailing_vbts_bb_threshold"),
            "VBTS BB threshold from config"
        );
        assert!(
            src.contains("cfg.trailing_vbts_mult"),
            "VBTS mult from config"
        );
        assert!(
            src.contains("cfg.trailing_high_profit_atr"),
            "high profit threshold from config"
        );
        assert!(
            src.contains("cfg.trailing_tighten_tspv"),
            "TSPV tighten from config"
        );
        assert!(
            src.contains("cfg.trailing_tighten_default"),
            "default tighten from config"
        );
        assert!(
            src.contains("cfg.trailing_weak_trend_mult"),
            "weak trend mult from config"
        );
    }

    #[test]
    fn trailing_codegen_contains_vbts_logic() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("VBTS") || src.contains("Vol-Buffered"),
            "must contain VBTS reference"
        );
        assert!(
            src.contains("bb_width_ratio"),
            "VBTS must check bb_width_ratio"
        );
    }

    #[test]
    fn trailing_codegen_contains_ratchet_logic() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("Ratchet") || src.contains("ratchet"),
            "must contain ratchet"
        );
        assert!(src.contains("fmax(candidate"), "LONG ratchet uses fmax");
        assert!(src.contains("fmin(candidate"), "SHORT ratchet uses fmin");
    }

    #[test]
    fn trailing_codegen_contains_rsi_trend_guard() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("RSI Trend-Guard") || src.contains("rsi_floor"),
            "must reference RSI Trend-Guard"
        );
        assert!(src.contains("rsi > 60.0"), "LONG RSI favourability check");
        assert!(src.contains("rsi < 40.0"), "SHORT RSI favourability check");
    }

    #[test]
    fn trailing_codegen_contains_tatp_tspv_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("TATP"), "must reference TATP");
        assert!(src.contains("TSPV"), "must reference TSPV");
        assert!(src.contains("adx_slope"), "TATP checks adx_slope");
        assert!(src.contains("atr_slope"), "TSPV checks atr_slope");
    }

    #[test]
    fn trailing_codegen_contains_weak_trend_logic() {
        let src = compute_trailing_codegen();
        assert!(src.contains("adx < 25.0"), "weak-trend check on adx < 25");
        assert!(
            src.contains("trailing_weak_trend_mult"),
            "weak-trend uses config mult"
        );
    }

    #[test]
    fn trailing_codegen_contains_activation_gate() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("profit_atr < trailing_start"),
            "activation gate: profit must exceed trailing_start"
        );
        assert!(
            src.contains("return current_trailing_sl"),
            "when not active, preserve existing trailing SL"
        );
    }

    #[test]
    fn trailing_codegen_handles_low_confidence() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("confidence == 0"),
            "Low confidence mapped to 0"
        );
    }

    #[test]
    fn trailing_codegen_handles_no_existing_trailing_sl() {
        let src = compute_trailing_codegen();
        assert!(
            src.contains("current_trailing_sl > 0.0"),
            "must check for no existing trailing SL (first computation)"
        );
    }

    #[test]
    fn trailing_codegen_uses_fmax_fmin() {
        let src = compute_trailing_codegen();
        assert!(src.contains("fmax("), "must use fmax for CUDA double math");
        assert!(src.contains("fmin("), "must use fmin for CUDA double math");
    }

    #[test]
    fn trailing_codegen_is_nonempty() {
        let src = compute_trailing_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- check_tp_codegen tests (AQC-1222) ------------------------------------

    #[test]
    fn tp_codegen_has_correct_function_signature() {
        let src = check_tp_codegen();
        assert!(
            src.contains("__device__ TpResult check_tp_codegen("),
            "must declare a __device__ TpResult function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(src.contains("int pos_type"), "must take pos_type as int");
        assert!(
            src.contains("double entry_price"),
            "must take entry_price as double"
        );
        assert!(
            src.contains("double entry_atr"),
            "must take entry_atr as double"
        );
        assert!(
            src.contains("double current_price"),
            "must take current_price as double"
        );
        assert!(src.contains("double size"), "must take size as double");
        assert!(
            src.contains("unsigned int tp1_taken"),
            "must take tp1_taken as unsigned int"
        );
        assert!(
            src.contains("double tp_mult"),
            "must take tp_mult as double"
        );
    }

    #[test]
    fn tp_codegen_has_source_comment() {
        let src = check_tp_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/take_profit.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn tp_codegen_uses_double_precision() {
        let src = check_tp_codegen();
        // Return struct fields
        assert!(src.contains("double fraction"), "fraction must be double");
        // Internal arithmetic uses double variables
        assert!(src.contains("double atr"), "atr must be double");
        assert!(src.contains("double tp_price"), "tp_price must be double");
        assert!(
            src.contains("double partial_mult"),
            "partial_mult must be double"
        );
        assert!(
            src.contains("double partial_tp_price"),
            "partial_tp_price must be double"
        );
        assert!(src.contains("double pct"), "pct must be double");
        assert!(
            src.contains("double remaining_notional"),
            "remaining_notional must be double"
        );
        // Must NOT use float for price-critical variables
        assert!(
            !src.contains("float tp_price"),
            "tp_price must be double, not float"
        );
        assert!(
            !src.contains("float partial_tp_price"),
            "partial_tp_price must be double, not float"
        );
    }

    #[test]
    fn tp_codegen_contains_partial_tp_logic() {
        let src = check_tp_codegen();
        assert!(
            src.contains("Partial TP") || src.contains("partial TP"),
            "must have partial TP comment marker"
        );
        assert!(
            src.contains("cfg.enable_partial_tp"),
            "must check enable_partial_tp config flag"
        );
        assert!(
            src.contains("tp1_taken == 0u"),
            "must check tp1_taken flag for first partial"
        );
        assert!(
            src.contains("partial_hit"),
            "must compute partial_hit condition"
        );
        assert!(
            src.contains("result.action = 1"),
            "partial TP must set action = 1 (reduce)"
        );
        assert!(
            src.contains("result.fraction = pct"),
            "partial TP must set fraction to pct"
        );
        assert!(
            src.contains("result.exit_code = 10"),
            "partial TP must set exit_code = 10"
        );
    }

    #[test]
    fn tp_codegen_contains_full_tp_logic() {
        let src = check_tp_codegen();
        assert!(
            src.contains("Full TP") || src.contains("full TP"),
            "must have full TP comment marker"
        );
        assert!(
            src.contains("result.action = 2"),
            "full TP must set action = 2 (close)"
        );
        assert!(
            src.contains("result.exit_code = 11"),
            "full TP must set exit_code = 11"
        );
        assert!(
            src.contains("tp_hit"),
            "must compute tp_hit condition for full TP"
        );
    }

    #[test]
    fn tp_codegen_uses_correct_config_fields() {
        let src = check_tp_codegen();
        assert!(
            src.contains("cfg.enable_partial_tp"),
            "must use cfg.enable_partial_tp"
        );
        assert!(
            src.contains("cfg.tp_partial_pct"),
            "must use cfg.tp_partial_pct"
        );
        assert!(
            src.contains("cfg.tp_partial_atr_mult"),
            "must use cfg.tp_partial_atr_mult"
        );
        assert!(
            src.contains("cfg.tp_partial_min_notional_usd"),
            "must use cfg.tp_partial_min_notional_usd"
        );
    }

    #[test]
    fn tp_codegen_has_atr_fallback() {
        let src = check_tp_codegen();
        assert!(
            src.contains("entry_price * 0.005"),
            "must have ATR fallback for legacy positions"
        );
    }

    #[test]
    fn tp_codegen_has_notional_check() {
        let src = check_tp_codegen();
        assert!(
            src.contains("remaining_notional"),
            "must compute remaining notional for partial TP min check"
        );
        assert!(
            src.contains("tp_partial_min_notional_usd"),
            "must check minimum notional threshold"
        );
    }

    #[test]
    fn tp_codegen_handles_tp1_taken() {
        let src = check_tp_codegen();
        assert!(
            src.contains("tp1_taken == 0u"),
            "must check tp1_taken for first partial TP"
        );
        assert!(
            src.contains("tp1 already taken"),
            "must have comment for tp1 already taken path"
        );
    }

    #[test]
    fn tp_codegen_handles_separate_partial_level() {
        let src = check_tp_codegen();
        // When tp_partial_atr_mult > 0, partial TP fires at a different level
        assert!(
            src.contains("cfg.tp_partial_atr_mult > 0.0"),
            "must check for separate partial mult"
        );
        // When tp_partial_atr_mult == 0, partial == full
        assert!(
            src.contains("cfg.tp_partial_atr_mult <= 0.0"),
            "must handle zero partial mult (legacy)"
        );
    }

    #[test]
    fn tp_codegen_has_long_short_direction() {
        let src = check_tp_codegen();
        // Long: TP above entry (entry + atr * mult)
        assert!(
            src.contains("entry_price + (atr * tp_mult)"),
            "long full TP = entry + atr * mult"
        );
        // Short: TP below entry (entry - atr * mult)
        assert!(
            src.contains("entry_price - (atr * tp_mult)"),
            "short full TP = entry - atr * mult"
        );
    }

    #[test]
    fn tp_codegen_uses_fmax_fmin() {
        let src = check_tp_codegen();
        // Used for clamping tp_partial_pct
        assert!(src.contains("fmax("), "must use fmax for CUDA double math");
        assert!(src.contains("fmin("), "must use fmin for CUDA double math");
    }

    #[test]
    fn tp_codegen_has_tp_result_struct() {
        let src = check_tp_codegen();
        assert!(
            src.contains("struct TpResult"),
            "must define TpResult struct"
        );
        assert!(
            src.contains("int action"),
            "TpResult must have action field"
        );
        assert!(
            src.contains("double fraction"),
            "TpResult must have fraction field"
        );
        assert!(
            src.contains("int exit_code"),
            "TpResult must have exit_code field"
        );
    }

    #[test]
    fn tp_codegen_is_nonempty() {
        let src = check_tp_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- check_smart_exits_codegen tests (AQC-1223) --------------------------------

    #[test]
    fn smart_exits_codegen_has_correct_function_signature() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("__device__ SmartExitResult check_smart_exits_codegen("),
            "must declare a __device__ SmartExitResult function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(src.contains("int pos_type"), "must take pos_type as int");
        assert!(
            src.contains("double entry_price"),
            "must take entry_price as double"
        );
        assert!(
            src.contains("double entry_atr"),
            "must take entry_atr as double"
        );
        assert!(
            src.contains("double current_price"),
            "must take current_price as double"
        );
        assert!(
            src.contains("double ema_fast"),
            "must take ema_fast as double"
        );
        assert!(
            src.contains("double ema_slow"),
            "must take ema_slow as double"
        );
        assert!(
            src.contains("double ema_macro"),
            "must take ema_macro as double"
        );
        assert!(src.contains("double adx"), "must take adx as double");
        assert!(
            src.contains("double adx_slope"),
            "must take adx_slope as double"
        );
        assert!(src.contains("double rsi"), "must take rsi as double");
        assert!(
            src.contains("double macd_hist"),
            "must take macd_hist as double"
        );
        assert!(
            src.contains("double profit_atr"),
            "must take profit_atr as double"
        );
        assert!(
            src.contains("int confidence"),
            "must take confidence as int"
        );
        assert!(
            src.contains("double entry_adx_threshold"),
            "must take entry_adx_threshold as double"
        );
    }

    #[test]
    fn smart_exits_codegen_has_source_comment() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("Derived from bt-core/src/exits/smart_exits.rs"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn smart_exits_codegen_has_smart_exit_result_struct() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("struct SmartExitResult"),
            "must define SmartExitResult struct"
        );
        assert!(
            src.contains("bool should_exit"),
            "SmartExitResult must have should_exit field"
        );
        assert!(
            src.contains("int exit_code"),
            "SmartExitResult must have exit_code field"
        );
    }

    #[test]
    fn smart_exits_codegen_uses_double_precision() {
        let src = check_smart_exits_codegen();
        assert!(src.contains("double eff_atr"), "eff_atr must be double");
        assert!(
            src.contains("double adx_exhaustion_lt"),
            "adx_exhaustion_lt must be double"
        );
        assert!(src.contains("double ema_dev"), "ema_dev must be double");
        assert!(
            src.contains("double tsme_min_profit"),
            "tsme_min_profit must be double"
        );
        assert!(src.contains("double rsi_ub"), "rsi_ub must be double");
        assert!(src.contains("double rsi_lb"), "rsi_lb must be double");
        assert!(src.contains("double sw"), "profit switch sw must be double");
        // Must NOT use float for indicator-critical variables
        assert!(
            !src.contains("float eff_atr"),
            "eff_atr must be double, not float"
        );
        assert!(
            !src.contains("float adx_exhaustion_lt"),
            "adx_exhaustion_lt must be double, not float"
        );
        assert!(
            !src.contains("float rsi_ub"),
            "rsi_ub must be double, not float"
        );
        assert!(
            !src.contains("float rsi_lb"),
            "rsi_lb must be double, not float"
        );
    }

    #[test]
    fn smart_exits_codegen_check1_trend_breakdown() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("Trend Breakdown") || src.contains("EMA Cross"),
            "must have Trend Breakdown / EMA Cross comment"
        );
        assert!(
            src.contains("ema_fast < ema_slow"),
            "long trend breakdown: ema_fast < ema_slow"
        );
        assert!(
            src.contains("ema_fast > ema_slow"),
            "short trend breakdown: ema_fast > ema_slow"
        );
        assert!(
            src.contains("is_weak_cross"),
            "must check TBB (Tight-Band Buffer) weak cross"
        );
        assert!(
            src.contains("ema_dev < 0.001"),
            "TBB: weak cross threshold is 0.1% deviation"
        );
        assert!(
            src.contains("adx > 25.0"),
            "TBB: weak cross requires ADX > 25"
        );
        assert!(
            src.contains("exit_code = 1"),
            "Trend Breakdown must set exit_code = 1"
        );
    }

    #[test]
    fn smart_exits_codegen_check2_trend_exhaustion() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("Trend Exhaustion") || src.contains("ADX below threshold"),
            "must have Trend Exhaustion comment"
        );
        assert!(
            src.contains("adx < adx_exhaustion_lt"),
            "exhaustion check: ADX < threshold"
        );
        assert!(
            src.contains("adx_exhaustion_lt > 0.0"),
            "exhaustion gated on threshold > 0"
        );
        assert!(
            src.contains("exit_code = 2"),
            "Trend Exhaustion must set exit_code = 2"
        );
    }

    #[test]
    fn smart_exits_codegen_check3_ema_macro_breakdown() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("EMA Macro Breakdown"),
            "must have EMA Macro Breakdown comment"
        );
        assert!(
            src.contains("cfg.require_macro_alignment"),
            "macro breakdown gated on require_macro_alignment config flag"
        );
        assert!(
            src.contains("ema_macro > 0.0"),
            "macro breakdown requires valid ema_macro"
        );
        assert!(
            src.contains("current_price < ema_macro"),
            "long macro breakdown: price < ema_macro"
        );
        assert!(
            src.contains("current_price > ema_macro"),
            "short macro breakout: price > ema_macro"
        );
        assert!(
            src.contains("exit_code = 3"),
            "EMA Macro Breakdown must set exit_code = 3"
        );
    }

    #[test]
    fn smart_exits_codegen_check4_stagnation_exit() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("Stagnation Exit") || src.contains("low-volatility"),
            "must have Stagnation Exit comment"
        );
        assert!(
            src.contains("atr < (eff_atr * 0.70)"),
            "stagnation triggers when current ATR < 70% of entry ATR"
        );
        assert!(
            src.contains("is_underwater"),
            "stagnation requires underwater position"
        );
        assert!(
            src.contains("exit_code = 4"),
            "Stagnation Exit must set exit_code = 4"
        );
    }

    #[test]
    fn smart_exits_codegen_check5_funding_headwind_noop() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("Funding Headwind"),
            "must have Funding Headwind comment"
        );
        assert!(
            src.contains("no-op") || src.contains("No-op"),
            "funding headwind must be documented as no-op in backtester v1"
        );
        // No actual logic should fire exit_code = 5
    }

    #[test]
    fn smart_exits_codegen_check6_tsme() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("TSME") || src.contains("Trend Saturation"),
            "must have TSME comment"
        );
        assert!(src.contains("adx > 50.0"), "TSME triggers when ADX > 50");
        assert!(
            src.contains("cfg.tsme_min_profit_atr"),
            "TSME uses tsme_min_profit_atr from config"
        );
        assert!(
            src.contains("cfg.tsme_require_adx_slope_negative"),
            "TSME checks tsme_require_adx_slope_negative config flag"
        );
        assert!(
            src.contains("macd_hist < prev_macd_hist"),
            "TSME checks MACD momentum contraction (long)"
        );
        assert!(
            src.contains("prev_macd_hist < prev2_macd_hist"),
            "TSME checks 2 consecutive contractions"
        );
        assert!(src.contains("exit_code = 6"), "TSME must set exit_code = 6");
    }

    #[test]
    fn smart_exits_codegen_check7_mmde() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("MMDE") || src.contains("MACD Persistent Divergence"),
            "must have MMDE comment"
        );
        assert!(
            src.contains("profit_atr > 1.5"),
            "MMDE requires profit > 1.5 ATR"
        );
        assert!(src.contains("adx > 35.0"), "MMDE requires ADX > 35");
        assert!(
            src.contains("prev2_macd_hist < prev3_macd_hist"),
            "MMDE checks 3 consecutive MACD divergences (4 bars total, long)"
        );
        assert!(
            src.contains("prev2_macd_hist > prev3_macd_hist"),
            "MMDE checks 3 consecutive MACD divergences (4 bars total, short)"
        );
        assert!(src.contains("exit_code = 7"), "MMDE must set exit_code = 7");
    }

    #[test]
    fn smart_exits_codegen_check8_rsi_overextension() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("RSI Overextension"),
            "must have RSI Overextension comment"
        );
        assert!(
            src.contains("cfg.enable_rsi_overextension_exit"),
            "RSI overextension gated on enable flag"
        );
        assert!(
            src.contains("cfg.rsi_exit_profit_atr_switch"),
            "RSI uses profit_atr_switch from config"
        );
        assert!(
            src.contains("cfg.rsi_exit_ub_lo_profit"),
            "RSI uses lo-profit upper bound from config"
        );
        assert!(
            src.contains("cfg.rsi_exit_lb_lo_profit"),
            "RSI uses lo-profit lower bound from config"
        );
        assert!(
            src.contains("cfg.rsi_exit_ub_hi_profit"),
            "RSI uses hi-profit upper bound from config"
        );
        assert!(
            src.contains("cfg.rsi_exit_lb_hi_profit"),
            "RSI uses hi-profit lower bound from config"
        );
        assert!(
            src.contains("cfg.rsi_exit_ub_lo_profit_low_conf"),
            "RSI uses lo-profit low-conf UB from config"
        );
        assert!(
            src.contains("cfg.rsi_exit_lb_lo_profit_low_conf"),
            "RSI uses lo-profit low-conf LB from config"
        );
        assert!(
            src.contains("cfg.rsi_exit_ub_hi_profit_low_conf"),
            "RSI uses hi-profit low-conf UB from config"
        );
        assert!(
            src.contains("cfg.rsi_exit_lb_hi_profit_low_conf"),
            "RSI uses hi-profit low-conf LB from config"
        );
        assert!(
            src.contains("rsi > rsi_ub"),
            "long RSI overextension: rsi > upper bound"
        );
        assert!(
            src.contains("rsi < rsi_lb"),
            "short RSI overextension: rsi < lower bound"
        );
        assert!(
            src.contains("exit_code = 8"),
            "RSI Overextension must set exit_code = 8"
        );
    }

    #[test]
    fn smart_exits_codegen_uses_correct_config_fields() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("cfg.smart_exit_adx_exhaustion_lt"),
            "must use cfg.smart_exit_adx_exhaustion_lt"
        );
        assert!(
            src.contains("cfg.smart_exit_adx_exhaustion_lt_low_conf"),
            "must use cfg.smart_exit_adx_exhaustion_lt_low_conf"
        );
        assert!(
            src.contains("cfg.require_macro_alignment"),
            "must use cfg.require_macro_alignment"
        );
        assert!(
            src.contains("cfg.tsme_min_profit_atr"),
            "must use cfg.tsme_min_profit_atr"
        );
        assert!(
            src.contains("cfg.tsme_require_adx_slope_negative"),
            "must use cfg.tsme_require_adx_slope_negative"
        );
        assert!(
            src.contains("cfg.enable_rsi_overextension_exit"),
            "must use cfg.enable_rsi_overextension_exit"
        );
        assert!(
            src.contains("cfg.rsi_exit_profit_atr_switch"),
            "must use cfg.rsi_exit_profit_atr_switch"
        );
    }

    #[test]
    fn smart_exits_codegen_uses_fmax_not_std_max() {
        let src = check_smart_exits_codegen();
        assert!(src.contains("fmax("), "must use fmax for CUDA");
        assert!(
            !src.contains("std::max"),
            "must not use std::max (use fmax for CUDA)"
        );
        assert!(
            !src.contains("std::min"),
            "must not use std::min (use fmin for CUDA)"
        );
    }

    #[test]
    fn smart_exits_codegen_has_atr_fallback() {
        let src = check_smart_exits_codegen();
        assert!(
            src.contains("entry_price * 0.005"),
            "must have ATR fallback for legacy positions"
        );
    }

    #[test]
    fn smart_exits_codegen_is_nonempty() {
        let src = check_smart_exits_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- check_all_exits_codegen tests (AQC-1224) -------------------------------

    #[test]
    fn all_exits_codegen_has_correct_function_signature() {
        let src = check_all_exits_codegen();
        assert!(
            src.contains("__device__ AllExitResult check_all_exits_codegen("),
            "must declare a __device__ AllExitResult function"
        );
        assert!(src.contains("int pos_type"), "must take pos_type as int");
        assert!(
            src.contains("double entry_price"),
            "must take entry_price as double"
        );
        assert!(
            src.contains("double entry_atr"),
            "must take entry_atr as double"
        );
        assert!(
            src.contains("double current_price"),
            "must take current_price as double"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
    }

    #[test]
    fn all_exits_codegen_has_all_exit_result_struct() {
        let src = check_all_exits_codegen();
        assert!(
            src.contains("struct AllExitResult"),
            "must define AllExitResult struct"
        );
        assert!(
            src.contains("bool should_exit"),
            "AllExitResult must have should_exit field"
        );
        assert!(
            src.contains("int exit_code"),
            "AllExitResult must have exit_code field"
        );
        assert!(
            src.contains("double exit_price"),
            "AllExitResult must have exit_price field (double precision)"
        );
    }

    #[test]
    fn all_exits_codegen_uses_double_precision_for_exit_price() {
        let src = check_all_exits_codegen();
        // The struct must declare exit_price as double, not float
        assert!(
            src.contains("double exit_price"),
            "exit_price must be double precision (T2 requirement)"
        );
        // Should not have float exit_price
        assert!(
            !src.contains("float exit_price"),
            "exit_price must NOT be float — double required"
        );
    }

    #[test]
    fn all_exits_codegen_calls_compute_sl_price() {
        let src = check_all_exits_codegen();
        assert!(
            src.contains("compute_sl_price_codegen("),
            "must call compute_sl_price_codegen"
        );
    }

    #[test]
    fn all_exits_codegen_calls_compute_trailing() {
        let src = check_all_exits_codegen();
        assert!(
            src.contains("compute_trailing_codegen("),
            "must call compute_trailing_codegen"
        );
    }

    #[test]
    fn all_exits_codegen_calls_check_tp() {
        let src = check_all_exits_codegen();
        assert!(
            src.contains("check_tp_codegen("),
            "must call check_tp_codegen"
        );
    }

    #[test]
    fn all_exits_codegen_calls_check_smart_exits() {
        let src = check_all_exits_codegen();
        assert!(
            src.contains("check_smart_exits_codegen("),
            "must call check_smart_exits_codegen"
        );
    }

    #[test]
    fn all_exits_codegen_sl_has_exit_code_100() {
        let src = check_all_exits_codegen();
        // Find the SL section and verify exit_code = 100 comes before trailing
        let sl_pos = src
            .find("compute_sl_price_codegen(")
            .expect("must call compute_sl_price_codegen");
        let trail_pos = src
            .find("compute_trailing_codegen(")
            .expect("must call compute_trailing_codegen");
        assert!(
            sl_pos < trail_pos,
            "SL must be checked before trailing (priority order)"
        );
        // exit_code 100 must appear between SL call and trailing call
        let sl_section = &src[sl_pos..trail_pos];
        assert!(
            sl_section.contains("exit_code = 100"),
            "SL exit must set exit_code = 100"
        );
    }

    #[test]
    fn all_exits_codegen_trailing_has_exit_code_101() {
        let src = check_all_exits_codegen();
        let trail_pos = src
            .find("compute_trailing_codegen(")
            .expect("must call compute_trailing_codegen");
        let tp_pos = src
            .find("check_tp_codegen(")
            .expect("must call check_tp_codegen");
        assert!(
            trail_pos < tp_pos,
            "trailing must be checked before TP (priority order)"
        );
        let trail_section = &src[trail_pos..tp_pos];
        assert!(
            trail_section.contains("exit_code = 101"),
            "trailing exit must set exit_code = 101"
        );
    }

    #[test]
    fn all_exits_codegen_tp_has_exit_code_102() {
        let src = check_all_exits_codegen();
        let tp_pos = src
            .find("check_tp_codegen(")
            .expect("must call check_tp_codegen");
        let smart_pos = src
            .find("check_smart_exits_codegen(")
            .expect("must call check_smart_exits_codegen");
        assert!(
            tp_pos < smart_pos,
            "TP must be checked before smart exits (priority order)"
        );
        let tp_section = &src[tp_pos..smart_pos];
        assert!(
            tp_section.contains("exit_code = 102"),
            "TP exit must set exit_code = 102"
        );
    }

    #[test]
    fn all_exits_codegen_has_source_comment() {
        let src = check_all_exits_codegen();
        assert!(
            src.contains("Derived from bt-core/src/engine.rs"),
            "must have SSOT provenance comment"
        );
    }

    #[test]
    fn all_exits_codegen_is_nonempty() {
        let src = check_all_exits_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- compute_entry_size_codegen tests (AQC-1230) --------------------------

    #[test]
    fn sizing_codegen_has_correct_function_signature() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("__device__ SizingResultD compute_entry_size_codegen("),
            "must declare a __device__ SizingResultD function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(src.contains("double equity"), "must take equity as double");
        assert!(src.contains("double price"), "must take price as double");
        assert!(
            src.contains("unsigned int confidence"),
            "must take confidence as unsigned int"
        );
        assert!(src.contains("double atr"), "must take atr as double");
        assert!(src.contains("double adx"), "must take adx as double");
    }

    #[test]
    fn sizing_codegen_emits_result_struct() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("struct SizingResultD"),
            "must define SizingResultD struct"
        );
        assert!(
            src.contains("double size;"),
            "SizingResultD must have double size field"
        );
        assert!(
            src.contains("double margin;"),
            "SizingResultD must have double margin field"
        );
        assert!(
            src.contains("double leverage;"),
            "SizingResultD must have double leverage field"
        );
    }

    #[test]
    fn sizing_codegen_uses_double_precision() {
        let src = compute_entry_size_codegen();
        assert!(src.contains("double margin ="), "margin must be double");
        assert!(src.contains("double conf_mult"), "conf_mult must be double");
        assert!(src.contains("double adx_mult"), "adx_mult must be double");
        assert!(
            src.contains("double vol_scalar"),
            "vol_scalar must be double"
        );
        assert!(src.contains("double lev"), "lev must be double");
        assert!(src.contains("double notional"), "notional must be double");
        assert!(src.contains("double size"), "size must be double");
        // Must NOT use float for monetary variables
        assert!(
            !src.contains("float margin"),
            "margin must be double, not float"
        );
        assert!(
            !src.contains("float notional"),
            "notional must be double, not float"
        );
    }

    #[test]
    fn sizing_codegen_contains_confidence_multiplier() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.confidence_mult_high"),
            "must use confidence_mult_high from config"
        );
        assert!(
            src.contains("cfg.confidence_mult_medium"),
            "must use confidence_mult_medium from config"
        );
        assert!(
            src.contains("cfg.confidence_mult_low"),
            "must use confidence_mult_low from config"
        );
        assert!(src.contains("CONF_HIGH"), "must check CONF_HIGH");
        assert!(src.contains("CONF_LOW"), "must check CONF_LOW");
    }

    #[test]
    fn sizing_codegen_contains_adx_multiplier() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.adx_sizing_full_adx"),
            "must use adx_sizing_full_adx from config"
        );
        assert!(
            src.contains("cfg.adx_sizing_min_mult"),
            "must use adx_sizing_min_mult from config"
        );
        assert!(src.contains("adx_mult"), "must compute adx_mult");
    }

    #[test]
    fn sizing_codegen_contains_vol_scalar() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.vol_baseline_pct"),
            "must use vol_baseline_pct from config"
        );
        assert!(
            src.contains("cfg.vol_scalar_min"),
            "must use vol_scalar_min from config"
        );
        assert!(
            src.contains("cfg.vol_scalar_max"),
            "must use vol_scalar_max from config"
        );
        assert!(src.contains("vol_ratio"), "must compute vol_ratio");
        assert!(
            src.contains("1.0 / vol_ratio"),
            "vol_scalar is inverse of vol_ratio"
        );
    }

    #[test]
    fn sizing_codegen_contains_dynamic_sizing_gate() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.enable_dynamic_sizing != 0u"),
            "must gate dynamic sizing on config flag"
        );
    }

    #[test]
    fn sizing_codegen_contains_dynamic_leverage() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.enable_dynamic_leverage != 0u"),
            "must gate dynamic leverage on config flag"
        );
        assert!(
            src.contains("cfg.leverage_high"),
            "must use leverage_high from config"
        );
        assert!(
            src.contains("cfg.leverage_medium"),
            "must use leverage_medium from config"
        );
        assert!(
            src.contains("cfg.leverage_low"),
            "must use leverage_low from config"
        );
        assert!(
            src.contains("cfg.leverage_max_cap"),
            "must use leverage_max_cap from config"
        );
    }

    #[test]
    fn sizing_codegen_contains_base_leverage_fallback() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.leverage"),
            "must fall back to base leverage when dynamic leverage disabled"
        );
    }

    #[test]
    fn sizing_codegen_contains_notional_and_size() {
        let src = compute_entry_size_codegen();
        assert!(src.contains("margin * lev"), "notional = margin * leverage");
        assert!(src.contains("notional / price"), "size = notional / price");
    }

    #[test]
    fn sizing_codegen_handles_zero_price() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("price > 0.0"),
            "must guard against zero/negative price"
        );
    }

    #[test]
    fn sizing_codegen_uses_allocation_pct() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("cfg.allocation_pct"),
            "must use allocation_pct from config"
        );
        assert!(
            src.contains("equity * (double)cfg.allocation_pct"),
            "base margin = equity * allocation_pct"
        );
    }

    #[test]
    fn sizing_codegen_uses_fmax_fmin() {
        let src = compute_entry_size_codegen();
        assert!(src.contains("fmax("), "must use fmax for CUDA");
        assert!(src.contains("fmin("), "must use fmin for CUDA");
        assert!(
            !src.contains("std::max"),
            "must not use std::max (use fmax for CUDA)"
        );
        assert!(
            !src.contains("std::min"),
            "must not use std::min (use fmin for CUDA)"
        );
    }

    #[test]
    fn sizing_codegen_has_source_comment() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("Derived from bt-core/src/engine.rs sizing logic"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn sizing_codegen_applies_multipliers_to_margin() {
        let src = compute_entry_size_codegen();
        assert!(
            src.contains("margin *= conf_mult * adx_mult * vol_scalar"),
            "dynamic sizing multiplies margin by all three factors"
        );
    }

    #[test]
    fn sizing_codegen_is_nonempty() {
        let src = compute_entry_size_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    // -- is_pesc_blocked_codegen tests (AQC-1231) --------------------------------

    #[test]
    fn pesc_codegen_has_correct_function_signature() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("__device__ bool is_pesc_blocked_codegen("),
            "must declare a __device__ bool function"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must take GpuComboConfig by const ref"
        );
        assert!(src.contains("double adx"), "must take adx as double");
        assert!(
            src.contains("unsigned int current_sec"),
            "must take current_sec as unsigned int"
        );
        assert!(
            src.contains("unsigned int desired_type"),
            "must take desired_type as unsigned int"
        );
    }

    #[test]
    fn pesc_codegen_has_source_comment() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("Derived from bt-core/src/engine.rs PESC cooldown logic"),
            "must reference the Rust SSOT source file"
        );
    }

    #[test]
    fn pesc_codegen_has_disable_gate() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("cfg.reentry_cooldown_minutes == 0u"),
            "must check reentry_cooldown_minutes == 0 to disable PESC"
        );
    }

    #[test]
    fn pesc_codegen_has_no_prior_close_gate() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("close_ts == 0u"),
            "must check for no prior close recorded"
        );
    }

    #[test]
    fn pesc_codegen_has_signal_flip_gate() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("close_reason == PESC_SIGNAL_FLIP"),
            "must bypass cooldown for signal flip exits (uses PESC_SIGNAL_FLIP define)"
        );
    }

    #[test]
    fn pesc_codegen_has_direction_gate() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("close_type != desired_type"),
            "must only block same-direction re-entry"
        );
    }

    #[test]
    fn pesc_codegen_has_adx_interpolation() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("adx >= 40.0"),
            "strong trend threshold must be ADX >= 40"
        );
        assert!(
            src.contains("cooldown_mins = min_cd"),
            "strong trend uses min cooldown"
        );
        assert!(
            src.contains("adx <= 25.0"),
            "weak trend threshold must be ADX <= 25"
        );
        assert!(
            src.contains("cooldown_mins = max_cd"),
            "weak trend uses max cooldown"
        );
        assert!(
            src.contains("(adx - 25.0) / 15.0"),
            "must interpolate ADX in [25, 40] range with 15.0 denominator"
        );
        assert!(
            src.contains("max_cd + t * (min_cd - max_cd)"),
            "interpolation formula: max_cd + t * (min_cd - max_cd)"
        );
    }

    #[test]
    fn pesc_codegen_uses_double_for_adx_arithmetic() {
        let src = is_pesc_blocked_codegen();
        assert!(src.contains("double min_cd"), "min_cd must be double");
        assert!(src.contains("double max_cd"), "max_cd must be double");
        assert!(
            src.contains("double cooldown_mins"),
            "cooldown_mins must be double"
        );
        assert!(
            src.contains("double t"),
            "interpolation factor t must be double"
        );
    }

    #[test]
    fn pesc_codegen_uses_correct_config_fields() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("cfg.reentry_cooldown_minutes"),
            "must use cfg.reentry_cooldown_minutes"
        );
        assert!(
            src.contains("cfg.reentry_cooldown_min_mins"),
            "must use cfg.reentry_cooldown_min_mins"
        );
        assert!(
            src.contains("cfg.reentry_cooldown_max_mins"),
            "must use cfg.reentry_cooldown_max_mins"
        );
    }

    #[test]
    fn pesc_codegen_computes_elapsed_and_compares() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.contains("cooldown_mins * 60.0"),
            "must convert cooldown from minutes to seconds"
        );
        assert!(
            src.contains("current_sec - close_ts"),
            "must compute elapsed seconds"
        );
        assert!(
            src.contains("elapsed < cooldown_sec"),
            "must return true (blocked) when elapsed < cooldown"
        );
    }

    #[test]
    fn pesc_codegen_is_nonempty() {
        let src = is_pesc_blocked_codegen();
        assert!(
            src.len() > 200,
            "generated code must be substantial, got {} bytes",
            src.len()
        );
    }

    #[test]
    fn pesc_codegen_returns_bool() {
        let src = is_pesc_blocked_codegen();
        assert!(src.contains("__device__ bool"), "return type must be bool");
        assert!(
            src.contains("return false"),
            "must have early-return false paths for gate bypasses"
        );
        assert!(
            src.contains("return elapsed < cooldown_sec"),
            "final return must compare elapsed vs cooldown"
        );
    }

    // -- Entry cooldown tests --

    #[test]
    fn entry_cooldown_has_correct_signature() {
        let src = check_entry_cooldown_codegen();
        assert!(
            src.contains("__device__ bool check_entry_cooldown_codegen("),
            "must declare a __device__ bool function with correct name"
        );
        assert!(
            src.contains("unsigned int last_close_time_sec"),
            "must accept last_close_time_sec param"
        );
        assert!(
            src.contains("unsigned int current_time_sec"),
            "must accept current_time_sec param"
        );
        assert!(
            src.contains("unsigned int cooldown_minutes"),
            "must accept cooldown_minutes param"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must accept GpuComboConfig reference"
        );
    }

    #[test]
    fn entry_cooldown_contains_time_comparison() {
        let src = check_entry_cooldown_codegen();
        assert!(
            src.contains("elapsed_sec < cooldown_sec"),
            "must compare elapsed time against cooldown threshold"
        );
        assert!(
            src.contains("cooldown_minutes * 60u"),
            "must convert cooldown from minutes to seconds"
        );
    }

    #[test]
    fn entry_cooldown_handles_zero_last_close_time() {
        let src = check_entry_cooldown_codegen();
        assert!(
            src.contains("last_close_time_sec == 0u"),
            "must check for zero last_close_time_sec (no previous close)"
        );
        assert!(
            src.contains("if (last_close_time_sec == 0u) { return false; }"),
            "must return false (not blocked) when no previous close"
        );
    }

    #[test]
    fn entry_cooldown_is_nonempty() {
        let src = check_entry_cooldown_codegen();
        assert!(
            !src.is_empty(),
            "entry cooldown codegen must not return empty string"
        );
        assert!(
            src.len() > 100,
            "entry cooldown codegen must contain substantive CUDA code, got {} bytes",
            src.len()
        );
    }

    // -- Exit cooldown tests --

    #[test]
    fn exit_cooldown_has_correct_signature() {
        let src = check_exit_cooldown_codegen();
        assert!(
            src.contains("__device__ bool check_exit_cooldown_codegen("),
            "must declare a __device__ bool function with correct name"
        );
        assert!(
            src.contains("unsigned int entry_time_sec"),
            "must accept entry_time_sec param"
        );
        assert!(
            src.contains("unsigned int current_time_sec"),
            "must accept current_time_sec param"
        );
        assert!(
            src.contains("unsigned int min_hold_minutes"),
            "must accept min_hold_minutes param"
        );
        assert!(
            src.contains("const GpuComboConfig& cfg"),
            "must accept GpuComboConfig reference"
        );
    }

    #[test]
    fn exit_cooldown_contains_time_comparison() {
        let src = check_exit_cooldown_codegen();
        assert!(
            src.contains("held_sec < min_hold_sec"),
            "must compare held time against minimum hold threshold"
        );
        assert!(
            src.contains("min_hold_minutes * 60u"),
            "must convert min_hold from minutes to seconds"
        );
    }

    #[test]
    fn exit_cooldown_handles_zero_min_hold() {
        let src = check_exit_cooldown_codegen();
        assert!(
            src.contains("min_hold_minutes == 0u"),
            "must check for zero min_hold_minutes (feature disabled)"
        );
        assert!(
            src.contains("if (min_hold_minutes == 0u) { return false; }"),
            "must return false (not blocked) when feature disabled"
        );
    }

    #[test]
    fn exit_cooldown_is_nonempty() {
        let src = check_exit_cooldown_codegen();
        assert!(
            !src.is_empty(),
            "exit cooldown codegen must not return empty string"
        );
        assert!(
            src.len() > 100,
            "exit cooldown codegen must contain substantive CUDA code, got {} bytes",
            src.len()
        );
    }
}
