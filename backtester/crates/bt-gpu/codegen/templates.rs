//! CUDA code templates for accounting functions.
//!
//! Each template mirrors the corresponding Rust function in `bt-core/src/accounting.rs`
//! and the manual CUDA implementations in `kernels/sweep_engine.cu`.
//!
//! All monetary calculations use `double` accumulators (matching AQC-734 f64 migration)
//! to prevent accumulation drift over 10K+ trades.

/// File header for the generated CUDA source.
pub const HEADER: &str = "\
// =============================================================================
// AUTO-GENERATED from decision_kernel.rs / accounting.rs -- DO NOT EDIT
// Generated by bt-gpu/build.rs codegen
// =============================================================================
//
// These device functions mirror the Rust accounting primitives in bt-core.
// They use double-precision accumulators to match AQC-734 f64 migration.
// The manual implementations in sweep_engine.cu should be validated against
// these reference functions to guarantee CPU/GPU parity.
//
// Source of truth:
//   bt-core/src/accounting.rs  -- quantize, apply_open_fill, apply_close_fill,
//                                  build_partial_close_plan, funding_delta
//   bt-core/src/decision_kernel.rs -- step() transition function
// =============================================================================

#pragma once
";

/// Rust: `accounting::quantize(value) -> f64`
///
/// Deterministic rounding to 1e-12 resolution.
pub fn quantize_codegen() -> String {
    r#"// Mirrors: accounting::quantize (accounting.rs:18-20)
// Precision scale: 1e12 (ACCOUNTING_QUANTUM)
__device__ double quantize_codegen(double value) {
    const double ACCOUNTING_QUANTUM = 1000000000000.0;
    return round(value * ACCOUNTING_QUANTUM) / ACCOUNTING_QUANTUM;
}
"#
    .to_string()
}

/// Rust: `accounting::apply_open_fill(notional, fee_rate) -> FillAccounting`
///
/// GPU version operates directly on state (no FillAccounting struct needed).
/// Mirrors the entry accounting in sweep_engine.cu where fee is deducted from
/// balance and added to total_fees.
pub fn apply_open_codegen() -> String {
    r#"// Mirrors: accounting::apply_open_fill (accounting.rs:65-75)
// + sweep_engine.cu entry execution (lines ~1304-1308, ~1569-1572)
//
// On the GPU, entry accounting is simpler than close: no PnL, just fee deduction.
// The position struct is populated separately by the caller.
__device__ void apply_open_codegen(
    GpuComboState* state,
    double notional,
    double fee_rate
) {
    double notional_q = quantize_codegen(notional);
    double fee = quantize_codegen(notional_q * fee_rate);

    state->balance -= fee;
    state->total_fees += fee;
}
"#
    .to_string()
}

/// Rust: `accounting::apply_close_fill(is_long, entry_price, exit_price, size, fee_rate)`
///       + `decision_kernel.rs` close logic (PESC tracking, win/loss stats)
///
/// Mirrors `apply_close` in sweep_engine.cu (lines 811-852).
pub fn apply_close_codegen() -> String {
    r#"// Mirrors: accounting::apply_close_fill (accounting.rs:84-101)
// + sweep_engine.cu apply_close (lines 811-852)
//
// Full close: computes PnL, deducts fee, updates stats, records PESC, clears position.
__device__ void apply_close_codegen(
    GpuComboState* state,
    unsigned int sym,
    float fill_price,
    float fee_rate,
    bool reason_is_signal_flip
) {
    const GpuPosition& pos = state->positions[sym];
    if (pos.active == POS_EMPTY) { return; }

    // Mark-to-market PnL (double precision, mirrors accounting::mark_to_market_pnl)
    double pnl;
    if (pos.active == POS_LONG) {
        pnl = ((double)fill_price - (double)pos.entry_price) * (double)pos.size;
    } else {
        pnl = ((double)pos.entry_price - (double)fill_price) * (double)pos.size;
    }
    pnl = quantize_codegen(pnl);

    double notional = quantize_codegen((double)pos.size * (double)fill_price);
    double fee = quantize_codegen(notional * (double)fee_rate);
    double cash_delta = quantize_codegen(pnl - fee);

    // Update state accumulators
    state->balance += cash_delta;
    state->total_pnl += pnl;
    state->total_fees += fee;
    state->total_trades += 1u;
    if (pnl > 0.0) {
        state->total_wins += 1u;
        state->gross_profit += pnl;
    } else {
        state->gross_loss += fabs(pnl);
    }
    state->num_open -= 1u;

    // PESC tracking (mirrors decision_kernel.rs last_close_info update)
    state->pesc_close_time_sec[sym] = 0u; // caller must set from snapshot t_sec
    state->pesc_close_type[sym] = pos.active;
    state->pesc_close_reason[sym] = reason_is_signal_flip ? PESC_SIGNAL_FLIP : PESC_OTHER;

    // Clear position
    clear_position(&state->positions[sym]);
}
"#
    .to_string()
}

/// Rust: `accounting::build_partial_close_plan` + close fill for the closed portion.
///
/// Mirrors `apply_partial_close` in sweep_engine.cu (lines 854-890).
pub fn apply_partial_close_codegen() -> String {
    r#"// Mirrors: accounting::build_partial_close_plan (accounting.rs:112-122)
// + accounting::apply_close_fill for the closed portion
// + sweep_engine.cu apply_partial_close (lines 854-890)
//
// Partial close: closes `pct` of position, updates remaining size/margin, marks tp1.
__device__ void apply_partial_close_codegen(
    GpuComboState* state,
    unsigned int sym,
    float fill_price,
    float pct,
    float fee_rate
) {
    const GpuPosition& pos = state->positions[sym];
    if (pos.active == POS_EMPTY) { return; }

    // Build partial close plan (mirrors accounting::build_partial_close_plan)
    // Clamp fraction to [0, 1]
    double fraction = (double)pct;
    if (fraction < 0.0) { fraction = 0.0; }
    if (fraction > 1.0) { fraction = 1.0; }

    double exit_size = quantize_codegen((double)pos.size * fraction);
    double remaining_size = quantize_codegen((double)pos.size - exit_size);
    double remaining_margin = quantize_codegen((double)pos.margin_used * (1.0 - fraction));

    // Apply close fill for the closed portion
    double pnl;
    if (pos.active == POS_LONG) {
        pnl = ((double)fill_price - (double)pos.entry_price) * exit_size;
    } else {
        pnl = ((double)pos.entry_price - (double)fill_price) * exit_size;
    }
    pnl = quantize_codegen(pnl);

    double notional = quantize_codegen(exit_size * (double)fill_price);
    double fee = quantize_codegen(notional * (double)fee_rate);
    double cash_delta = quantize_codegen(pnl - fee);

    // Update state accumulators
    state->balance += cash_delta;
    state->total_pnl += pnl;
    state->total_fees += fee;
    state->total_trades += 1u;
    if (pnl > 0.0) {
        state->total_wins += 1u;
        state->gross_profit += pnl;
    } else {
        state->gross_loss += fabs(pnl);
    }

    // Reduce position (mirrors accounting::build_partial_close_plan output)
    state->positions[sym].size = (float)remaining_size;
    state->positions[sym].margin_used = (float)remaining_margin;
    state->positions[sym].tp1_taken = 1u;
    // CPU semantics: trailing SL is NOT modified on partial close.
}
"#
    .to_string()
}

/// Rust: `accounting::funding_delta(is_long, size, mark_price, rate) -> f64`
///
/// Hyperliquid-style funding formula.
pub fn funding_delta_codegen() -> String {
    r#"// Mirrors: accounting::funding_delta (accounting.rs:126-129)
//
// Hyperliquid-style funding: longs pay shorts when rate > 0.
// Returns the cash delta to add to balance.
__device__ double funding_delta_codegen(
    bool is_long,
    double size,
    double mark_price,
    double rate
) {
    double signed_size = is_long ? size : -size;
    return quantize_codegen(-signed_size * mark_price * rate);
}
"#
    .to_string()
}

/// Rust: `accounting::mark_to_market_pnl(is_long, entry_price, exit_price, size) -> f64`
pub fn mark_to_market_pnl_codegen() -> String {
    r#"// Mirrors: accounting::mark_to_market_pnl (accounting.rs:78-82)
//
// Directional PnL calculation with quantized output.
__device__ double mark_to_market_pnl_codegen(
    bool is_long,
    double entry_price,
    double exit_price,
    double size
) {
    double raw_pnl = (exit_price - entry_price) * size;
    double pnl = is_long ? raw_pnl : -raw_pnl;
    return quantize_codegen(pnl);
}
"#
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn header_contains_pragma_once() {
        assert!(HEADER.contains("#pragma once"));
    }

    #[test]
    fn quantize_uses_1e12_quantum() {
        let src = quantize_codegen();
        assert!(src.contains("1000000000000.0"));
    }

    #[test]
    fn apply_open_deducts_fee_only() {
        let src = apply_open_codegen();
        assert!(src.contains("state->balance -= fee"));
        assert!(src.contains("state->total_fees += fee"));
        // No PnL in open
        assert!(!src.contains("total_pnl"));
    }

    #[test]
    fn apply_close_handles_long_and_short() {
        let src = apply_close_codegen();
        assert!(src.contains("POS_LONG"));
        assert!(src.contains("pos.entry_price"));
        assert!(src.contains("PESC_SIGNAL_FLIP"));
    }

    #[test]
    fn partial_close_clamps_fraction() {
        let src = apply_partial_close_codegen();
        assert!(src.contains("fraction < 0.0"));
        assert!(src.contains("fraction > 1.0"));
        assert!(src.contains("tp1_taken = 1u"));
    }

    #[test]
    fn funding_delta_has_signed_size() {
        let src = funding_delta_codegen();
        assert!(src.contains("signed_size"));
        assert!(src.contains("quantize_codegen"));
    }
}
