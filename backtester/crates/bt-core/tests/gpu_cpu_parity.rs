//! CPU-only GPU/CPU parity harness.
//!
//! CI typically does not have a CUDA runtime. We therefore commit a small
//! expected GPU sweep output (generated by maintainers) and compare the CPU
//! simulation result against it within a tolerance envelope.

use std::path::{Path, PathBuf};

use bt_core::candle::{CandleData, OhlcvBar};
use bt_core::{engine, report};
use serde::Deserialize;

#[derive(Debug, Deserialize)]
struct FixtureBar {
    t: i64,
    t_close: Option<i64>,
    o: f64,
    h: f64,
    l: f64,
    c: f64,
    v: f64,
    n: i32,
}

#[derive(Debug, Deserialize)]
struct ExpectedGpuSweepResult {
    config_id: String,
    #[allow(dead_code)]
    total_pnl: f64,
    final_balance: f64,
    total_trades: u32,
    #[allow(dead_code)]
    total_wins: u32,
    win_rate: f64,
    profit_factor: f64,
    max_drawdown_pct: f64,
}

// ---------------------------------------------------------------------------
// Configurable tolerances
// ---------------------------------------------------------------------------

fn tolerance(env_key: &str, default: f64) -> f64 {
    let multiplier: f64 = std::env::var("AQC_GPU_PARITY_TOLERANCE")
        .ok()
        .and_then(|v| v.parse().ok())
        .unwrap_or(1.0);
    let base: f64 = std::env::var(env_key)
        .ok()
        .and_then(|v| v.parse().ok())
        .unwrap_or(default);
    base * multiplier
}

// ---------------------------------------------------------------------------
// Diff report
// ---------------------------------------------------------------------------

struct ParityCheck {
    metric: &'static str,
    cpu_value: f64,
    gpu_value: f64,
    delta: f64,
    tolerance: f64,
    passed: bool,
}

fn print_parity_table(checks: &[ParityCheck]) {
    eprintln!();
    eprintln!("┌───────────────────┬────────────┬────────────┬────────────┬────────────┬────────┐");
    eprintln!("│ Metric            │ CPU        │ GPU        │ Delta      │ Tolerance  │ Status │");
    eprintln!("├───────────────────┼────────────┼────────────┼────────────┼────────────┼────────┤");
    for c in checks {
        let status = if c.passed { "PASS" } else { "FAIL" };
        eprintln!(
            "│ {:<17} │ {:>10.4} │ {:>10.4} │ {:>10.4} │ {:>10.4} │ {:<6} │",
            c.metric, c.cpu_value, c.gpu_value, c.delta, c.tolerance, status
        );
    }
    eprintln!("└───────────────────┴────────────┴────────────┴────────────┴────────────┴────────┘");
    eprintln!();
}

// ---------------------------------------------------------------------------
// Fixture loaders
// ---------------------------------------------------------------------------

fn load_candles_fixture(path: &Path) -> CandleData {
    let raw =
        std::fs::read_to_string(path).unwrap_or_else(|e| panic!("Failed to read {path:?}: {e}"));
    let parsed: std::collections::BTreeMap<String, Vec<FixtureBar>> =
        serde_json::from_str(&raw).unwrap_or_else(|e| panic!("Invalid JSON in {path:?}: {e}"));

    let mut out: CandleData = CandleData::default();
    for (sym, bars) in parsed {
        let mut v: Vec<OhlcvBar> = Vec::with_capacity(bars.len());
        for b in bars {
            v.push(OhlcvBar {
                t: b.t,
                t_close: b.t_close.unwrap_or(b.t),
                o: b.o,
                h: b.h,
                l: b.l,
                c: b.c,
                v: b.v,
                n: b.n,
            });
        }
        out.insert(sym, v);
    }
    out
}

fn load_expected(path: &Path) -> ExpectedGpuSweepResult {
    let raw =
        std::fs::read_to_string(path).unwrap_or_else(|e| panic!("Failed to read {path:?}: {e}"));
    serde_json::from_str(&raw).unwrap_or_else(|e| panic!("Invalid JSON in {path:?}: {e}"))
}

// ---------------------------------------------------------------------------
// Test
// ---------------------------------------------------------------------------

#[test]
fn gpu_cpu_parity_fixture_is_within_tolerance() {
    let crate_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let fixture_dir = crate_root.join("../../testdata/gpu_cpu_parity");

    // Graceful skip when fixture files are missing (CI without GPU data).
    if !fixture_dir.exists() {
        eprintln!("SKIP: GPU/CPU parity fixture not found at {fixture_dir:?}");
        return;
    }

    let candles_path = fixture_dir.join("candles_1h.json");
    let expected_path = fixture_dir.join("expected_gpu_sweep.json");
    let cfg_path = fixture_dir.join("strategy.yaml");

    let candles = load_candles_fixture(&candles_path);
    let cfg = bt_core::config::load_config(&cfg_path.to_string_lossy(), None, false);
    let expected = load_expected(&expected_path);

    let initial_balance = 10_000.0;
    let lookback = 200;

    let sim = engine::run_simulation(engine::RunSimulationInput {
        candles: &candles,
        cfg: &cfg,
        initial_balance,
        lookback,
        exit_candles: None,
        entry_candles: None,
        funding_rates: None,
        init_state: None,
        from_ts: None,
        to_ts: None,
    });

    let rpt = report::build_report(report::BuildReportInput {
        trades: &sim.trades,
        signals: &sim.signals,
        equity_curve: &sim.equity_curve,
        gate_stats: &sim.gate_stats,
        initial_balance,
        final_balance: sim.final_balance,
        config_id: "cpu_parity",
        include_trades: false,
        include_equity_curve: false,
    });

    assert!(
        rpt.total_trades > 0,
        "Fixture produced no trades; adjust strategy.yaml or candles fixture"
    );
    assert!(
        expected.total_trades > 0,
        "Expected GPU fixture produced no trades; regenerate expected_gpu_sweep.json"
    );

    // Ensure the fixture files stay in sync with the generator.
    assert!(
        expected.config_id.is_empty(),
        "Expected GPU config_id should be empty for an empty sweep spec, got: {:?}",
        expected.config_id
    );

    // -----------------------------------------------------------------------
    // Compute all parity metrics
    // -----------------------------------------------------------------------

    let cpu_net_pnl = rpt.final_balance - initial_balance;
    let gpu_net_pnl = expected.final_balance - initial_balance;

    assert!(
        cpu_net_pnl.signum() == gpu_net_pnl.signum(),
        "PnL sign mismatch (cpu={:.2} gpu={:.2})",
        cpu_net_pnl,
        gpu_net_pnl
    );

    // Tolerances — tightened from the original loose bounds.
    let tol_pnl = tolerance("AQC_PARITY_TOL_PNL", 0.005);
    let tol_dd = tolerance("AQC_PARITY_TOL_DD", 0.01);
    let tol_wr = tolerance("AQC_PARITY_TOL_WR", 0.05);
    let tol_tc = tolerance("AQC_PARITY_TOL_TC", 0.02);
    let tol_pf = tolerance("AQC_PARITY_TOL_PF", 0.5);

    let net_pnl_rel_err = (cpu_net_pnl - gpu_net_pnl).abs() / initial_balance;
    let dd_delta = (rpt.max_drawdown_pct - expected.max_drawdown_pct).abs();
    let wr_delta = (rpt.win_rate - expected.win_rate).abs();
    let trade_ratio = rpt.total_trades as f64 / expected.total_trades as f64;
    let trade_ratio_delta = (trade_ratio - 1.0).abs();
    let pf_delta = (rpt.profit_factor - expected.profit_factor).abs();

    // -----------------------------------------------------------------------
    // Build diff report
    // -----------------------------------------------------------------------

    let checks = vec![
        ParityCheck {
            metric: "Net PnL (rel)",
            cpu_value: cpu_net_pnl,
            gpu_value: gpu_net_pnl,
            delta: net_pnl_rel_err,
            tolerance: tol_pnl,
            passed: net_pnl_rel_err <= tol_pnl,
        },
        ParityCheck {
            metric: "Max Drawdown %",
            cpu_value: rpt.max_drawdown_pct,
            gpu_value: expected.max_drawdown_pct,
            delta: dd_delta,
            tolerance: tol_dd,
            passed: dd_delta <= tol_dd,
        },
        ParityCheck {
            metric: "Win Rate",
            cpu_value: rpt.win_rate,
            gpu_value: expected.win_rate,
            delta: wr_delta,
            tolerance: tol_wr,
            passed: wr_delta <= tol_wr,
        },
        ParityCheck {
            metric: "Trade Count (±%)",
            cpu_value: rpt.total_trades as f64,
            gpu_value: expected.total_trades as f64,
            delta: trade_ratio_delta,
            tolerance: tol_tc,
            passed: trade_ratio_delta <= tol_tc,
        },
        ParityCheck {
            metric: "Profit Factor",
            cpu_value: rpt.profit_factor,
            gpu_value: expected.profit_factor,
            delta: pf_delta,
            tolerance: tol_pf,
            passed: pf_delta <= tol_pf,
        },
    ];

    // Always print the table so CI logs are easy to scan.
    print_parity_table(&checks);

    let failures: Vec<&ParityCheck> = checks.iter().filter(|c| !c.passed).collect();
    assert!(
        failures.is_empty(),
        "GPU↔CPU parity failed for {} metric(s): [{}]",
        failures.len(),
        failures
            .iter()
            .map(|c| c.metric)
            .collect::<Vec<_>>()
            .join(", ")
    );
}
