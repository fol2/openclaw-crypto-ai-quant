//! CPU-only GPU/CPU parity harness.
//!
//! CI typically does not have a CUDA runtime. We therefore commit a small
//! expected GPU sweep output (generated by maintainers) and compare the CPU
//! simulation result against it within a tolerance envelope.

use std::path::{Path, PathBuf};

use bt_core::candle::{CandleData, OhlcvBar};
use bt_core::{engine, report};
use serde::Deserialize;

#[derive(Debug, Deserialize)]
struct FixtureBar {
    t: i64,
    t_close: Option<i64>,
    o: f64,
    h: f64,
    l: f64,
    c: f64,
    v: f64,
    n: i32,
}

#[derive(Debug, Deserialize)]
struct ExpectedGpuSweepResult {
    config_id: String,
    #[allow(dead_code)]
    total_pnl: f64,
    final_balance: f64,
    total_trades: u32,
    total_wins: u32,
    win_rate: f64,
    profit_factor: f64,
    max_drawdown_pct: f64,
}

fn load_candles_fixture(path: &Path) -> CandleData {
    let raw = std::fs::read_to_string(path).unwrap_or_else(|e| panic!("Failed to read {path:?}: {e}"));
    let parsed: std::collections::BTreeMap<String, Vec<FixtureBar>> =
        serde_json::from_str(&raw).unwrap_or_else(|e| panic!("Invalid JSON in {path:?}: {e}"));

    let mut out: CandleData = CandleData::default();
    for (sym, bars) in parsed {
        let mut v: Vec<OhlcvBar> = Vec::with_capacity(bars.len());
        for b in bars {
            v.push(OhlcvBar {
                t: b.t,
                t_close: b.t_close.unwrap_or(b.t),
                o: b.o,
                h: b.h,
                l: b.l,
                c: b.c,
                v: b.v,
                n: b.n,
            });
        }
        out.insert(sym, v);
    }
    out
}

fn load_expected(path: &Path) -> ExpectedGpuSweepResult {
    let raw = std::fs::read_to_string(path).unwrap_or_else(|e| panic!("Failed to read {path:?}: {e}"));
    serde_json::from_str(&raw).unwrap_or_else(|e| panic!("Invalid JSON in {path:?}: {e}"))
}

#[test]
fn gpu_cpu_parity_fixture_is_within_tolerance() {
    let crate_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let fixture_dir = crate_root.join("../../testdata/gpu_cpu_parity");

    let candles_path = fixture_dir.join("candles_1h.json");
    let expected_path = fixture_dir.join("expected_gpu_sweep.json");
    let cfg_path = fixture_dir.join("strategy.yaml");

    let candles = load_candles_fixture(&candles_path);
    let cfg = bt_core::config::load_config(&cfg_path.to_string_lossy(), None, false);
    let expected = load_expected(&expected_path);

    let initial_balance = 10_000.0;
    let lookback = 200;

    let sim = engine::run_simulation(
        &candles,
        &cfg,
        initial_balance,
        lookback,
        None,
        None,
        None,
        None,
        None,
        None,
    );

    let rpt = report::build_report(
        &sim.trades,
        &sim.signals,
        &sim.equity_curve,
        &sim.gate_stats,
        initial_balance,
        sim.final_balance,
        "cpu_parity",
        false,
        false,
    );

    assert!(rpt.total_trades > 0, "Fixture produced no trades; adjust strategy.yaml or candles fixture");
    assert!(expected.total_trades > 0, "Expected GPU fixture produced no trades; regenerate expected_gpu_sweep.json");

    // Ensure the fixture files stay in sync with the generator.
    assert!(
        expected.config_id.is_empty(),
        "Expected GPU config_id should be empty for an empty sweep spec, got: {:?}",
        expected.config_id
    );

    // Compare net PnL via final_balance to avoid differences in how `total_pnl`
    // is reported between GPU and CPU (fees/rounding).
    let cpu_net_pnl = rpt.final_balance - initial_balance;
    let gpu_net_pnl = expected.final_balance - initial_balance;

    assert!(
        cpu_net_pnl.signum() == gpu_net_pnl.signum(),
        "PnL sign mismatch (cpu={:.2} gpu={:.2})",
        cpu_net_pnl,
        gpu_net_pnl
    );

    // Tolerance envelope: keep these intentionally loose. This harness exists
    // to catch major drift, not to enforce perfect equality.
    let net_pnl_rel_err = (cpu_net_pnl - gpu_net_pnl).abs() / initial_balance;
    assert!(
        net_pnl_rel_err <= 0.03,
        "Net PnL drifted too far (cpu={:.2} gpu={:.2} rel_err={:.3})",
        cpu_net_pnl,
        gpu_net_pnl,
        net_pnl_rel_err
    );

    let dd_delta = (rpt.max_drawdown_pct - expected.max_drawdown_pct).abs();
    assert!(
        dd_delta <= 0.03,
        "Max drawdown pct drifted too far (cpu={:.3} gpu={:.3} delta={:.3})",
        rpt.max_drawdown_pct,
        expected.max_drawdown_pct,
        dd_delta
    );

    assert!(
        (rpt.win_rate - expected.win_rate).abs() <= 0.20,
        "Win rate drifted too far (cpu={:.4} gpu={:.4})",
        rpt.win_rate,
        expected.win_rate
    );

    // Profit factor tends to be noisy when gross_loss is small. Keep this wide.
    let pf_delta = (rpt.profit_factor - expected.profit_factor).abs();
    assert!(
        pf_delta <= 3.0,
        "Profit factor drifted too far (cpu={:.3} gpu={:.3} delta={:.3})",
        rpt.profit_factor,
        expected.profit_factor,
        pf_delta
    );

    // Trade counts are expected to differ (GPU uses a simplified trade kernel).
    // Keep a very loose bound here to catch pathological changes.
    let trade_ratio = rpt.total_trades as f64 / expected.total_trades as f64;
    assert!(
        (0.25..=4.0).contains(&trade_ratio),
        "Trade count ratio is out of bounds (cpu={} gpu={} ratio={:.3})",
        rpt.total_trades,
        expected.total_trades,
        trade_ratio
    );

    let win_ratio = rpt.total_wins as f64 / expected.total_wins.max(1) as f64;
    assert!(
        (0.25..=4.0).contains(&win_ratio),
        "Win count ratio is out of bounds (cpu={} gpu={} ratio={:.3})",
        rpt.total_wins,
        expected.total_wins,
        win_ratio
    );
}
